
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Notional machine &#8212; Comp308: Principles of Programming Languages v1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Growing the language" href="growing.html" />
    <link rel="prev" title="A mental model for the machine" href="machine.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="notional-machine">
<h1>Notional machine<a class="headerlink" href="#notional-machine" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">author</dt>
<dd class="field-odd"><p>Srikumar K. S.</p>
</dd>
<dt class="field-even">date</dt>
<dd class="field-even"><p>5 Aug 2023</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section contains notes for the same content as the previous
section <a class="reference internal" href="machine.html"><span class="doc">A mental model for the machine</span></a>, except that it is presented in the context of what
students in the 2023 July batch had worked on up to this point. It also
takes a more “gentle” approach to the topic.</p>
</div>
<p>A “notional machine” offers a mental model of how computation happens in a
machine. Making these machines explicit as programs gives us concrete artifacts
that we can study as we build up our programming language.</p>
<p>We’ve so far built an interpreter that relies on Racket’s semantics to do its
job. In this session, we’ll be diving into what these semantics are and lifting
the hood to peek under the machinery a bit.</p>
<p>First the base definitions we need –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="kn">#lang </span><span class="nn">typed/racket</span>

<span class="p">(</span><span class="k">require</span> <span class="s2">&quot;color.rkt&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">require</span> <span class="s2">&quot;picture-lib.rkt&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">require</span> <span class="n">racket/match</span><span class="p">)</span>

<span class="c1">; Sugar free</span>
<span class="p">(</span><span class="k">struct</span> <span class="n">Circle</span> <span class="p">([</span><span class="n">radius</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                <span class="p">[</span><span class="n">thickness</span> <span class="n">:</span> <span class="n">Float</span><span class="p">])</span>
  <span class="kd">#:transparent</span><span class="p">)</span>
<span class="p">(</span><span class="k">struct</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="n">Overlay</span> <span class="p">([</span><span class="n">pic1</span> <span class="n">:</span> <span class="n">t</span><span class="p">]</span>
                     <span class="p">[</span><span class="n">pic2</span> <span class="n">:</span> <span class="n">t</span><span class="p">])</span>
  <span class="kd">#:transparent</span><span class="p">)</span>
<span class="p">(</span><span class="k">struct</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="n">Colorize</span> <span class="p">([</span><span class="n">a</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                      <span class="p">[</span><span class="n">r</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                      <span class="p">[</span><span class="n">g</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                      <span class="p">[</span><span class="n">b</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                      <span class="p">[</span><span class="n">pic</span> <span class="n">:</span> <span class="n">t</span><span class="p">])</span>
  <span class="kd">#:transparent</span><span class="p">)</span>
<span class="p">(</span><span class="k">struct</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="n">Affine</span> <span class="p">([</span><span class="n">mxx</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                    <span class="p">[</span><span class="n">mxy</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                    <span class="p">[</span><span class="n">myx</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                    <span class="p">[</span><span class="n">myy</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                    <span class="p">[</span><span class="n">dx</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                    <span class="p">[</span><span class="n">dy</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                    <span class="p">[</span><span class="n">pic</span> <span class="n">:</span> <span class="n">t</span><span class="p">])</span>
  <span class="kd">#:transparent</span><span class="p">)</span>

<span class="c1">; Sugar form</span>
<span class="p">(</span><span class="k">struct</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="n">Translate</span> <span class="p">([</span><span class="n">dx</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                       <span class="p">[</span><span class="n">dy</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                       <span class="p">[</span><span class="n">pic</span> <span class="n">:</span> <span class="n">t</span><span class="p">])</span>
  <span class="kd">#:transparent</span><span class="p">)</span>

<span class="p">(</span><span class="n">define-type</span> <span class="n">PicSugar</span> <span class="p">(</span><span class="n">U</span> <span class="n">Circle</span>
                         <span class="p">(</span><span class="n">Overlay</span> <span class="n">PicSugar</span><span class="p">)</span>
                         <span class="p">(</span><span class="n">Colorize</span> <span class="n">PicSugar</span><span class="p">)</span>
                         <span class="p">(</span><span class="n">Affine</span> <span class="n">PicSugar</span><span class="p">)</span>
                         <span class="p">(</span><span class="n">Translate</span> <span class="n">PicSugar</span><span class="p">)))</span>

<span class="p">(</span><span class="n">define-type</span> <span class="n">PicCore</span> <span class="p">(</span><span class="n">U</span> <span class="n">Circle</span>
                        <span class="p">(</span><span class="n">Overlay</span> <span class="n">PicCore</span><span class="p">)</span>
                        <span class="p">(</span><span class="n">Colorize</span> <span class="n">PicCore</span><span class="p">)</span>
                        <span class="p">(</span><span class="n">Affine</span> <span class="n">PicCore</span><span class="p">)))</span>

<span class="p">(</span><span class="n">:</span> <span class="n">interpret-picexpr</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="n">PicCore</span> <span class="n">Picture</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">interpret-picexpr</span> <span class="n">picexpr</span><span class="p">)</span>
  <span class="p">(</span><span class="k">match</span> <span class="n">picexpr</span>
    <span class="p">[(</span><span class="n">Circle</span> <span class="n">radius</span> <span class="n">thickness</span><span class="p">)</span>
     <span class="p">(</span><span class="n">circle</span> <span class="n">radius</span> <span class="n">thickness</span><span class="p">)]</span>
    <span class="p">[(</span><span class="n">Affine</span> <span class="n">mxx</span> <span class="n">mxy</span> <span class="n">myx</span> <span class="n">myy</span> <span class="n">dx</span> <span class="n">dy</span> <span class="n">picexpr2</span><span class="p">)</span>
     <span class="p">(</span><span class="n">affine</span> <span class="n">mxx</span> <span class="n">mxy</span> <span class="n">myx</span> <span class="n">myy</span> <span class="n">dx</span> <span class="n">dy</span> <span class="p">(</span><span class="n">interpret-picexpr</span> <span class="n">picexpr2</span><span class="p">))]</span>
    <span class="p">[(</span><span class="n">Overlay</span> <span class="n">picexpr1</span> <span class="n">picexpr2</span><span class="p">)</span>
     <span class="p">(</span><span class="n">overlay</span> <span class="p">(</span><span class="n">interpret-picexpr</span> <span class="n">picexpr1</span><span class="p">)</span>
              <span class="p">(</span><span class="n">interpret-picexpr</span> <span class="n">picexpr2</span><span class="p">))]</span>
    <span class="p">[(</span><span class="n">Colorize</span> <span class="n">a</span> <span class="n">r</span> <span class="n">g</span> <span class="n">b</span> <span class="n">pic</span><span class="p">)</span>
     <span class="p">(</span><span class="n">colorize</span> <span class="n">a</span> <span class="n">r</span> <span class="n">g</span> <span class="n">b</span> <span class="p">(</span><span class="n">interpret-picexpr</span> <span class="n">pic</span><span class="p">))]))</span>

<span class="c1">; Note that the desugar operation is the same whether the result</span>
<span class="c1">; is fed into the interpreter or the compiler.</span>
<span class="p">(</span><span class="n">:</span> <span class="n">desugar</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="n">PicSugar</span> <span class="n">PicCore</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">desugar</span> <span class="n">picexpr</span><span class="p">)</span>
  <span class="p">(</span><span class="k">match</span> <span class="n">picexpr</span>
    <span class="p">[(</span><span class="n">Translate</span> <span class="n">dx</span> <span class="n">dy</span> <span class="n">picexpr2</span><span class="p">)</span>
     <span class="p">(</span><span class="n">Affine</span> <span class="mf">1.0</span> <span class="mf">0.0</span> <span class="mf">0.0</span> <span class="mf">1.0</span> <span class="n">dx</span> <span class="n">dy</span> <span class="p">(</span><span class="n">desugar</span> <span class="n">picexpr2</span><span class="p">))]</span>
    <span class="p">[(</span><span class="n">Colorize</span> <span class="n">a</span> <span class="n">r</span> <span class="n">g</span> <span class="n">b</span> <span class="n">picexpr2</span><span class="p">)</span>
     <span class="p">(</span><span class="n">Colorize</span> <span class="n">a</span> <span class="n">r</span> <span class="n">g</span> <span class="n">b</span> <span class="p">(</span><span class="n">desugar</span> <span class="n">picexpr2</span><span class="p">))]</span>
    <span class="p">[(</span><span class="n">Overlay</span> <span class="n">picexpr1</span> <span class="n">picexpr2</span><span class="p">)</span>
     <span class="p">(</span><span class="n">Overlay</span> <span class="p">(</span><span class="n">desugar</span> <span class="n">picexpr1</span><span class="p">)</span> <span class="p">(</span><span class="n">desugar</span> <span class="n">picexpr2</span><span class="p">))]</span>
    <span class="p">[(</span><span class="n">Circle</span> <span class="n">radius</span> <span class="n">thickness</span><span class="p">)</span>
     <span class="p">(</span><span class="n">Circle</span> <span class="n">radius</span> <span class="n">thickness</span><span class="p">)]))</span>
</pre></div>
</div>
<p>We’ll also define a sample “picture expression” that we can use
as an aid to think through how we want to compute the result
picture.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">picexpr</span> <span class="n">:</span> <span class="n">PicSugar</span>
  <span class="p">(</span><span class="n">Overlay</span>
   <span class="p">(</span><span class="n">Colorize</span> <span class="mf">1.0</span> <span class="mf">1.0</span> <span class="mf">0.0</span> <span class="mf">0.0</span>
             <span class="p">(</span><span class="n">Circle</span> <span class="mf">0.75</span> <span class="mf">0.1</span><span class="p">))</span>
   <span class="p">(</span><span class="n">Translate</span> <span class="mf">0.5</span> <span class="mf">0.0</span>
              <span class="p">(</span><span class="n">Colorize</span> <span class="mf">1.0</span> <span class="mf">0.0</span> <span class="mf">0.0</span> <span class="mf">1.0</span>
                    <span class="p">(</span><span class="n">Circle</span> <span class="mf">1.5</span> <span class="mf">0.1</span><span class="p">)))))</span>
</pre></div>
</div>
<p>Let’s look at what the steps our interpreter takes to evaluate
this expression and come up with a picture. First let’s translate it
into “core” form.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">picexpr-core</span> <span class="n">:</span> <span class="n">PicCore</span>
  <span class="p">(</span><span class="n">desugar</span> <span class="n">picexpr</span><span class="p">))</span>
</pre></div>
</div>
<div class="section" id="instruction-sequence">
<h2>Instruction sequence<a class="headerlink" href="#instruction-sequence" title="Permalink to this headline">¶</a></h2>
<p>Let’s write down the individual steps it does. We’ll note only
those steps where actual computation happens - i.e. our Racket
functions that calculate pictures are called.</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(Circle</span> <span class="pre">0.75</span> <span class="pre">0.1)</span></code> gets evaluated using <code class="docutils literal notranslate"><span class="pre">(circle</span> <span class="pre">0.75</span> <span class="pre">0.1)</span></code> to get, say,
<code class="docutils literal notranslate"><span class="pre">result1</span></code></p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">result1</span></code> is used to calculate <code class="docutils literal notranslate"><span class="pre">(Colorize</span> <span class="pre">1.0</span> <span class="pre">1.0</span> <span class="pre">0.0</span> <span class="pre">0.0</span> <span class="pre">result1)</span></code>
using <code class="docutils literal notranslate"><span class="pre">(colorize</span> <span class="pre">1.0</span> <span class="pre">1.0</span> <span class="pre">0.0</span> <span class="pre">0.0</span> <span class="pre">result1)</span></code> to get <code class="docutils literal notranslate"><span class="pre">result2</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(Circle</span> <span class="pre">1.5</span> <span class="pre">0.1)</span></code> gets evaluated using <code class="docutils literal notranslate"><span class="pre">(circle</span> <span class="pre">1.5</span> <span class="pre">0.1)</span></code> to get <code class="docutils literal notranslate"><span class="pre">result3</span></code></p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">result3</span></code> is used to calculate <code class="docutils literal notranslate"><span class="pre">(colorize</span> <span class="pre">1.0</span> <span class="pre">0.0</span> <span class="pre">0.0</span> <span class="pre">1.0</span> <span class="pre">result3)</span></code> to
get <code class="docutils literal notranslate"><span class="pre">result4</span></code></p></li>
<li><p>That <code class="docutils literal notranslate"><span class="pre">result4</span></code> is then used to calculate <code class="docutils literal notranslate"><span class="pre">(Translate</span> <span class="pre">0.5</span> <span class="pre">0.0</span> <span class="pre">result4)</span></code> to
get <code class="docutils literal notranslate"><span class="pre">result5</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">result2</span></code> and <code class="docutils literal notranslate"><span class="pre">result5</span></code> are then used to calculate <code class="docutils literal notranslate"><span class="pre">(overlay</span> <span class="pre">result2</span>
<span class="pre">result5)</span></code></p></li>
<li><p>The result of step 6 is the final picture.</p></li>
</ol>
<p>If we were to write that out as a Racket function that computes the picture,
we’d do it like this.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">picexpr-in-racket</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="n">result1</span> <span class="p">(</span><span class="n">circle</span> <span class="mf">0.75</span> <span class="mf">0.1</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="n">result2</span> <span class="p">(</span><span class="n">colorize</span> <span class="mf">1.0</span> <span class="mf">1.0</span> <span class="mf">0.0</span> <span class="mf">0.0</span> <span class="n">result1</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="n">result3</span> <span class="p">(</span><span class="n">circle</span> <span class="mf">1.5</span> <span class="mf">0.1</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="n">result4</span> <span class="p">(</span><span class="n">colorize</span> <span class="mf">1.0</span> <span class="mf">0.0</span> <span class="mf">0.0</span> <span class="mf">1.0</span> <span class="n">result3</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="n">result5</span> <span class="p">(</span><span class="n">translate</span> <span class="mf">0.5</span> <span class="mf">0.0</span> <span class="n">result4</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="n">result6</span> <span class="p">(</span><span class="n">overlay</span> <span class="n">result2</span> <span class="n">result5</span><span class="p">))</span>
  <span class="n">result6</span><span class="p">)</span>
</pre></div>
</div>
<p>Some observations to be made. We need result1 to compute result2 but not any of
the results following that. Similarly we need result3 to compute result4, and
need result4 to compute result5 but we don’t need result3 and result4 after we
compute result5.</p>
<p>We could use those observations to rewrite it this way using fewer “result”
variables.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">picexpr-in-racket2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="n">result1</span> <span class="p">(</span><span class="n">circle</span> <span class="mf">0.75</span> <span class="mf">0.1</span><span class="p">))</span>
  <span class="p">(</span><span class="k">set!</span> <span class="n">result1</span> <span class="p">(</span><span class="n">colorize</span> <span class="mf">1.0</span> <span class="mf">1.0</span> <span class="mf">0.0</span> <span class="mf">0.0</span> <span class="n">result1</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="n">result2</span> <span class="p">(</span><span class="n">circle</span> <span class="mf">1.5</span> <span class="mf">0.1</span><span class="p">))</span>
  <span class="p">(</span><span class="k">set!</span> <span class="n">result2</span> <span class="p">(</span><span class="n">colorize</span> <span class="mf">1.0</span> <span class="mf">0.0</span> <span class="mf">0.0</span> <span class="mf">1.0</span> <span class="n">result2</span><span class="p">))</span>
  <span class="p">(</span><span class="k">set!</span> <span class="n">result2</span> <span class="p">(</span><span class="n">translate</span> <span class="mf">0.5</span> <span class="mf">0.0</span> <span class="n">result2</span><span class="p">))</span>
  <span class="p">(</span><span class="k">set!</span> <span class="n">result1</span> <span class="p">(</span><span class="n">overlay</span> <span class="n">result1</span> <span class="n">result2</span><span class="p">))</span>
  <span class="n">result1</span><span class="p">)</span>
</pre></div>
</div>
<p>We see that we needed only two variables to complete the computation. Also,
Racket is pulling off a lot of tricks of performing this specific series of
computations when given our recursive interpreter.</p>
</div>
<div class="section" id="instructions-for-our-machine">
<h2>Instructions for our “machine”<a class="headerlink" href="#instructions-for-our-machine" title="Permalink to this headline">¶</a></h2>
<p>So let’s step in and look at a more “barebones machine”. A “program” in the
simplest sense can be thought of as a list of instructions that a computer
performs from start to end and then stops.</p>
<p>What will this list of instructions look like? Let’s make some structs to
capture that. We’ll define new struct names for the purpose of this discussion.</p>
<p>The circle instruction is straightforward.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">struct</span> <span class="n">SCircle</span> <span class="p">([</span><span class="n">radius</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                 <span class="p">[</span><span class="n">thickness</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]))</span>
</pre></div>
</div>
<p>Consider the “colorize” instruction.
Should it be the following one?</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">struct</span> <span class="n">SColorize1</span> <span class="p">([</span><span class="n">a</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                    <span class="p">[</span><span class="n">r</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                    <span class="p">[</span><span class="n">g</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                    <span class="p">[</span><span class="n">b</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                    <span class="p">[</span><span class="n">pic</span> <span class="n">:</span> <span class="n">NewPicExpression</span><span class="p">]))</span>
</pre></div>
</div>
<p>What should NewPicExpression be then? We were formerly thinking in terms of
“expressions” and “values” they “evaluate” to, and leveraged the semantics of
Racket which also offers expressions evaluate to concrete values as part of its
semantics. We’re now thinking in terms of “instructions sent to a computer”
instead. We want to capture the data required to instruct “pick a picture from
your storage, colorize it with the given ARGB color, and store the result
colorized picture into the storage”. This is an “instruction” - which involves
a “fetch”, “perform” and “store” sequence. You’ll find this a characteristic of
“low level” languages like Assembly, for example. Since we have no concept of
an “embedded expression” when we’re looking at sending “instructions”, our data
structures correspondingly change. Our SColorize should simply be -</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">struct</span> <span class="n">SColorize</span> <span class="p">([</span><span class="n">a</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                   <span class="p">[</span><span class="n">r</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                   <span class="p">[</span><span class="n">g</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                   <span class="p">[</span><span class="n">b</span> <span class="n">:</span> <span class="n">Float</span><span class="p">])</span>
  <span class="kd">#:transparent</span><span class="p">)</span>
</pre></div>
</div>
<p>with the implication that when this instruction is processed, a picture will be
fetched from “storage”, colorized, and the result will be placed back into the
“storage”.</p>
</div>
<div class="section" id="storage">
<h2>Storage<a class="headerlink" href="#storage" title="Permalink to this headline">¶</a></h2>
<p>We haven’t made any consideration for what we should use for “storage”.
Earlier, we’d relied on Racket semantics to handle the storage part for us too,
by relying on function call/return semantics and binding values to identifiers
(either using let or lambda).</p>
<p>Let’s pick the simplest “storage” we can for starters – the humble list. So
when we need a value to be taken from our “storage”, we’ll pick the head
element of the list we’re using to represent our storage. When we want to store
something, we’ll extend our list at the head with the new value. In our case,
the only types of values we’re dealing with are <code class="docutils literal notranslate"><span class="pre">Picture</span></code> values, so we don’t
need to worry about any others.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">define-type</span> <span class="n">Storage</span> <span class="p">(</span><span class="n">Listof</span> <span class="n">Picture</span><span class="p">))</span>

<span class="p">(</span><span class="n">:</span> <span class="n">new-storage</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="n">Storage</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">new-storage</span><span class="p">)</span> <span class="nb">empty</span><span class="p">)</span>

<span class="p">(</span><span class="n">:</span> <span class="n">store</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="n">Picture</span> <span class="n">Storage</span> <span class="n">Storage</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">store</span> <span class="n">pic</span> <span class="n">storage</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons</span> <span class="n">pic</span> <span class="n">storage</span><span class="p">))</span>

<span class="p">(</span><span class="n">:</span> <span class="n">take1</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="n">Storage</span> <span class="p">(</span><span class="n">List</span> <span class="n">Picture</span> <span class="n">Storage</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">take1</span> <span class="n">storage</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">empty?</span> <span class="n">storage</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">error</span> <span class="s2">&quot;Empty storage&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">first</span> <span class="n">storage</span><span class="p">)</span> <span class="p">(</span><span class="nb">rest</span> <span class="n">storage</span><span class="p">))))</span>

<span class="p">(</span><span class="n">:</span> <span class="n">take2</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="n">Storage</span> <span class="p">(</span><span class="n">List</span> <span class="n">Picture</span> <span class="n">Picture</span> <span class="n">Storage</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">take2</span> <span class="n">storage</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">v1</span> <span class="p">(</span><span class="n">take1</span> <span class="n">storage</span><span class="p">)])</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">v2</span> <span class="p">(</span><span class="n">take1</span> <span class="p">(</span><span class="nb">second</span> <span class="n">v1</span><span class="p">))])</span>
            <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">first</span> <span class="n">v1</span><span class="p">)</span> <span class="p">(</span><span class="nb">first</span> <span class="n">v2</span><span class="p">)</span> <span class="p">(</span><span class="nb">second</span> <span class="n">v2</span><span class="p">)))))</span>
</pre></div>
</div>
<p>Now that we’re clear about both the nature of our “instructions” and
our computer’s “storage”, let’s make them all explicit.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">struct</span> <span class="n">SCircle</span> <span class="p">([</span><span class="n">radius</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                 <span class="p">[</span><span class="n">thickness</span> <span class="n">:</span> <span class="n">Float</span><span class="p">])</span>
    <span class="kd">#:transparent</span><span class="p">)</span>

<span class="p">(</span><span class="k">struct</span> <span class="n">SColorize</span> <span class="p">([</span><span class="n">a</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                   <span class="p">[</span><span class="n">r</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                   <span class="p">[</span><span class="n">g</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                   <span class="p">[</span><span class="n">b</span> <span class="n">:</span> <span class="n">Float</span><span class="p">])</span>
    <span class="kd">#:transparent</span><span class="p">)</span>

<span class="p">(</span><span class="k">struct</span> <span class="n">STranslate</span> <span class="p">([</span><span class="n">dx</span> <span class="n">:</span> <span class="n">Float</span><span class="p">]</span>
                    <span class="p">[</span><span class="n">dy</span> <span class="n">:</span> <span class="n">Float</span><span class="p">])</span>
    <span class="kd">#:transparent</span><span class="p">)</span>

<span class="p">(</span><span class="k">struct</span> <span class="n">SOverlay</span> <span class="p">()</span>
    <span class="kd">#:transparent</span><span class="p">)</span>

<span class="p">(</span><span class="n">define-type</span> <span class="n">Instruction</span> <span class="p">(</span><span class="n">U</span> <span class="n">SCircle</span>
                            <span class="n">SColorize</span>
                            <span class="n">STranslate</span>
                            <span class="n">SOverlay</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="instruction-processor">
<h2>Instruction processor<a class="headerlink" href="#instruction-processor" title="Permalink to this headline">¶</a></h2>
<p>So our “machine” for processing instructions needs to have a very
simple type – we need to give it the storage to work on,
a list of instructions and it will need to give us back the
storage at the end of processing all the instructions. So
its type will simply be -</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">:</span> <span class="n">run-machine</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="n">Storage</span> <span class="p">(</span><span class="n">Listof</span> <span class="n">Instruction</span><span class="p">)</span> <span class="n">Storage</span><span class="p">))</span>
</pre></div>
</div>
<p>… and our machine is such a simpleton that it is nearly trivial
to specify what it does.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">run-machine</span> <span class="n">storage</span> <span class="n">instructions</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">empty?</span> <span class="n">instructions</span><span class="p">)</span>
        <span class="n">storage</span>
        <span class="p">(</span><span class="n">run-machine</span> <span class="p">(</span><span class="n">process-instruction</span> <span class="n">storage</span> <span class="p">(</span><span class="nb">first</span> <span class="n">instructions</span><span class="p">))</span>
                 <span class="p">(</span><span class="nb">rest</span> <span class="n">instructions</span><span class="p">))))</span>
</pre></div>
</div>
<p>Here we’ve delegated the job of figuring out what to do for each type of
instruction to another function <code class="docutils literal notranslate"><span class="pre">process-instruction</span></code>. What this is expected
to do, for each type of instruction, is the three steps we saw earlier -</p>
<ol class="arabic simple">
<li><p><strong>Fetch</strong> any input it needs from the storage. It is ok for an
instruction to not need any input too.</p></li>
<li><p><strong>Work</strong> on the input according to the instruction and produce
an output result.</p></li>
<li><p><strong>Store</strong> the output result into the storage and return the
storage.</p></li>
</ol>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">:</span> <span class="n">process-instruction</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="n">Storage</span> <span class="n">Instruction</span> <span class="n">Storage</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">process-instruction</span> <span class="n">storage</span> <span class="n">instruction</span><span class="p">)</span>
    <span class="p">(</span><span class="k">match</span> <span class="n">instruction</span>
        <span class="p">[(</span><span class="n">SCircle</span> <span class="n">radius</span> <span class="n">thickness</span><span class="p">)</span>
         <span class="p">(</span><span class="n">store</span> <span class="p">(</span><span class="n">circle</span> <span class="n">radius</span> <span class="n">thickness</span><span class="p">)</span> <span class="n">storage</span><span class="p">)]</span>
        <span class="p">[(</span><span class="n">SColorize</span> <span class="n">a</span> <span class="n">r</span> <span class="n">g</span> <span class="n">b</span><span class="p">)</span>
         <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">input</span> <span class="p">(</span><span class="n">take1</span> <span class="n">storage</span><span class="p">)])</span>
            <span class="p">(</span><span class="n">store</span> <span class="p">(</span><span class="n">colorize</span> <span class="n">a</span> <span class="n">r</span> <span class="n">g</span> <span class="n">b</span> <span class="p">(</span><span class="nb">first</span> <span class="n">input</span><span class="p">))</span> <span class="p">(</span><span class="nb">second</span> <span class="n">input</span><span class="p">)))]</span>
        <span class="p">[(</span><span class="n">STranslate</span> <span class="n">dx</span> <span class="n">dy</span><span class="p">)</span>
         <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">input</span> <span class="p">(</span><span class="n">take1</span> <span class="n">storage</span><span class="p">)])</span>
            <span class="p">(</span><span class="n">store</span> <span class="p">(</span><span class="n">translate</span> <span class="n">dx</span> <span class="n">dy</span> <span class="p">(</span><span class="nb">first</span> <span class="n">input</span><span class="p">))</span> <span class="p">(</span><span class="nb">second</span> <span class="n">input</span><span class="p">)))]</span>
        <span class="p">[(</span><span class="n">SOverlay</span><span class="p">)</span>
         <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">input</span> <span class="p">(</span><span class="n">take2</span> <span class="n">storage</span><span class="p">)])</span>
            <span class="p">(</span><span class="n">store</span> <span class="p">(</span><span class="n">overlay</span> <span class="p">(</span><span class="nb">first</span> <span class="n">input</span><span class="p">)</span> <span class="p">(</span><span class="nb">second</span> <span class="n">input</span><span class="p">))</span> <span class="p">(</span><span class="nb">third</span> <span class="n">input</span><span class="p">)))]))</span>
</pre></div>
</div>
<p>So how do we invoke this machine to produce the same picture we computed
earlier using <code class="docutils literal notranslate"><span class="pre">picexpr</span></code> and <code class="docutils literal notranslate"><span class="pre">interpret-picexpr</span></code>?</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">result</span>
    <span class="p">(</span><span class="n">run-machine</span> <span class="p">(</span><span class="n">new-storage</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="n">SCircle</span> <span class="mf">0.75</span> <span class="mf">0.1</span><span class="p">)</span>
                       <span class="p">(</span><span class="n">SColorize</span> <span class="mf">1.0</span> <span class="mf">1.0</span> <span class="mf">0.0</span> <span class="mf">0.0</span><span class="p">)</span>
                       <span class="p">(</span><span class="n">SCircle</span> <span class="mf">1.5</span> <span class="mf">0.1</span><span class="p">)</span>
                       <span class="p">(</span><span class="n">SColorize</span> <span class="mf">1.0</span> <span class="mf">0.0</span> <span class="mf">0.0</span> <span class="mf">1.0</span><span class="p">)</span>
                       <span class="p">(</span><span class="n">STranslate</span> <span class="mf">0.5</span> <span class="mf">0.0</span><span class="p">)</span>
                       <span class="p">(</span><span class="n">SOverlay</span><span class="p">))))</span>
</pre></div>
</div>
<p>What our “machine” does with the given “program” is the following –</p>
<ol class="arabic simple">
<li><p>It makes a new circle and puts it into storage.</p></li>
<li><p>It pulls the circle picture from storage, colorizes it and puts that back
into storage, removing the previous circle.</p></li>
<li><p>It puts another circle into storage.</p></li>
<li><p>It pulls the latest circle, colorizes it and puts it into storage. Now our
storage contains two colorized circles.</p></li>
<li><p>It pulls the latest colorized circle from storage, translates it and puts
that back into storage. Now our storage contains one colorized circle and
one translated colorized circle.</p></li>
<li><p>It pulls two pictures from storage and overlays one on top of the other, and
puts the result overlaid picture into the storage. Finally our storage
contains only one picture which is the result.</p></li>
</ol>
<p>This closely mimics the way we wrote what our first version of the interpreter
did when it processed things recursively. Except that now, we have an “under
the hood” understanding of what the interpreter is doing. We may not work
extensively with this “notional machine”, but it is a very useful construct to
keep in mind and try to work out in parallel as we add more capabilities to our
interpreter.</p>
</div>
<div class="section" id="reflections">
<h2>Reflections<a class="headerlink" href="#reflections" title="Permalink to this headline">¶</a></h2>
<p>We’d used generic words like “storage” and “instructions” here. If you look
carefully at how our storage operates, you can see that it behaves like a
“stack” – i.e. a “last-in first-out” data structure. We might as well have
written our storage to be like this –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">define-type</span> <span class="n">Stack</span> <span class="p">(</span><span class="n">Listof</span> <span class="n">Picture</span><span class="p">))</span>

<span class="p">(</span><span class="n">:</span> <span class="n">push</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="n">Picture</span> <span class="n">Stack</span> <span class="n">Stack</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">push</span> <span class="n">val</span> <span class="n">stack</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons</span> <span class="n">val</span> <span class="n">stack</span><span class="p">))</span>

<span class="p">(</span><span class="n">:</span> <span class="n">pop1</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="n">Stack</span> <span class="n">Stack</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">pop1</span> <span class="n">stack</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">rest</span> <span class="n">stack</span><span class="p">))</span>

<span class="p">(</span><span class="n">:</span> <span class="n">pop2</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="n">Stack</span> <span class="n">Stack</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">pop2</span> <span class="n">stack</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">rest</span> <span class="p">(</span><span class="nb">rest</span> <span class="n">stack</span><span class="p">)))</span>
</pre></div>
</div>
<p>… and use the usual <code class="docutils literal notranslate"><span class="pre">first</span></code> and <code class="docutils literal notranslate"><span class="pre">second</span></code> to access the top two elements
of our stack.</p>
<p>This stack machine is not an unusual construct and actually entire programming
languages such as Forth, J and Postscript are built around this approach. yes,
Postscript (and by extension PDF) is not merely a data format, but PS files are
actually programs that draw things into the device. This is the way we get PDF
and PS documents to behave correctly independent of device resolution.</p>
<p>Because it takes very little to build up such a “stack based programming
language”, you’ll find such languages in very low level programmable hardware
as well. For example, OpenFirmware is a protocol for control of computing
hardware and I/O devices and it is programmed in Forth.</p>
<p>Originally, we wanted to rely less on Racket’s semantics to implement our
interpreter. But we again find ourselves using Racket’s function call
semantics including recursion – our <code class="docutils literal notranslate"><span class="pre">run-machine</span></code> function calls
itself. However there is one crucial difference that suggests that we’re
relying less. The recursive step in <code class="docutils literal notranslate"><span class="pre">run-machine</span></code> appears in what is
called the “tail position”. It is the last step when evaluating a particular
<code class="docutils literal notranslate"><span class="pre">run-machine</span></code> call. This means there is no need to remember all the state
and history of calling <code class="docutils literal notranslate"><span class="pre">run-machine</span></code> earlier and we can simply move to
processing the next instruction. This is also the trick that Racket/Scheme
use to perform “tail recursive” procedures without blowing the stack.
To see the difference, try the following two functions – one in Racket
and the other in Javascript in your browser.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">sum</span> <span class="n">m</span> <span class="n">n</span> <span class="n">total</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span>
        <span class="p">(</span><span class="n">sum</span> <span class="p">(</span><span class="nb">+</span> <span class="n">m</span> <span class="mi">1</span><span class="p">)</span> <span class="n">n</span> <span class="p">(</span><span class="nb">+</span> <span class="n">m</span> <span class="n">total</span><span class="p">))</span>
        <span class="n">total</span><span class="p">))</span>

<span class="p">(</span><span class="n">sum</span> <span class="mi">1</span> <span class="mi">1000000</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">total</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">m</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">m</span><span class="o">+</span><span class="mf">1</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="o">+</span><span class="nx">total</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">total</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">sum</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">1000000</span><span class="p">,</span> <span class="mf">0</span><span class="p">)</span>
</pre></div>
</div>
<p>To evaluate the Javascript code, you can open your browser, go to the
“developer console” and paste the code in. Firefox, for example,
will complain of “too much recursion”, whereas for Racket, the
recursion is equivalent to doing the following in Javascript -</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">total</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">m</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">next_m</span> <span class="o">=</span> <span class="nx">m</span> <span class="o">+</span> <span class="mf">1</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">next_total</span> <span class="o">=</span> <span class="nx">total</span> <span class="o">+</span> <span class="nx">m</span><span class="p">;</span>
        <span class="nx">m</span> <span class="o">=</span> <span class="nx">next_m</span><span class="p">;</span>
        <span class="nx">total</span> <span class="o">=</span> <span class="nx">next_total</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">total</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="introducing-identifiers">
<h2>Introducing identifiers<a class="headerlink" href="#introducing-identifiers" title="Permalink to this headline">¶</a></h2>
<p>We’re now ready to dip our toes into permitting some degree of abstraction in
our “picture expressions”. We now have a machine that performs a <em>sequence</em> of
instructions while threading a “storage mechanism” through the steps. We can
now support simple reuse of computation by associating identifiers with
computed results so they can be reused when needed. What we’ll be doing here is
not the most powerful “core” approach, but since it will introduce a few
mechanisms we’ll need later on, it serves as a useful intermediate step.</p>
<p>We’ll define a new term that lets us associate an identifier with a picture
expression, with the expectation that the picture computation will be performed
and the resultant picture associated with the identifier in our storage. Note
that we actually don’t need to include an expression to compute to determine
what the id needs to be bound do. We can simply pick up that value from our
storage.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">define-type</span> <span class="n">Identifier</span> <span class="n">Symbol</span><span class="p">)</span>
<span class="p">(</span><span class="k">struct</span> <span class="n">SDefine</span> <span class="p">([</span><span class="n">id</span> <span class="n">:</span> <span class="n">Identifier</span><span class="p">]))</span>

<span class="c1">; We&#39;ll also have to augment our instruction set to permit</span>
<span class="c1">; this new construct.</span>

<span class="p">(</span><span class="n">define-type</span> <span class="n">Instruction</span> <span class="p">(</span><span class="n">U</span> <span class="n">SCircle</span>
                            <span class="n">SColorize</span>
                            <span class="n">STranslate</span>
                            <span class="n">SOverlay</span>
                            <span class="n">SDefine</span><span class="p">))</span>
</pre></div>
</div>
<p>Now, how will we use this defined identifier to construct other pictures?
Recall that an instruction like <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">Colorize</span></span> <span class="name"><span class="pre">a</span></span> <span class="name"><span class="pre">r</span></span> <span class="name"><span class="pre">g</span></span> <span class="name"><span class="pre">b</span></span><span class="punctuation"><span class="pre">)</span></span></code> will fetch the
input picture from storage, colorize it and place the result back into
the storage. So all we need to add is a way to lookup the picture associated
with an identifier and place the picture into our storage, to be picked
up by subsequent instructions. This is a simple enough instruction.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">struct</span> <span class="n">SUse</span> <span class="p">([</span><span class="n">id</span> <span class="n">:</span> <span class="n">Identifier</span><span class="p">]))</span>
<span class="p">(</span><span class="n">define-type</span> <span class="n">Instruction</span> <span class="p">(</span><span class="n">U</span> <span class="n">SCircle</span>
                            <span class="n">SColorize</span>
                            <span class="n">STranslate</span>
                            <span class="n">SOverlay</span>
                            <span class="n">SDefine</span>
                            <span class="n">SUse</span><span class="p">))</span>
</pre></div>
</div>
<p>We also need to augment our storage with a new component – something that can
let us associate identifiers with values and lets us look it up. For simplicity,
we’ll reuse the same list structure of our storage, except that we’ll augment
what we can put into it with a new “Binding” type. We’ll search through the
storage linearly for the first occurrence of the value we’re interested in
and pick that up. So we’ll modify the getter functions accordingly.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="c1">; Note that we&#39;re binding an *evaluated* picture here.</span>
<span class="p">(</span><span class="k">struct</span> <span class="n">Binding</span> <span class="p">([</span><span class="n">id</span> <span class="n">:</span> <span class="n">Identifier</span><span class="p">]</span>
                 <span class="p">[</span><span class="n">value</span> <span class="n">:</span> <span class="n">Picture</span><span class="p">]))</span>

<span class="p">(</span><span class="n">define-type</span> <span class="n">Datum</span> <span class="p">(</span><span class="n">U</span> <span class="n">Picture</span> <span class="n">Binding</span><span class="p">))</span>
<span class="p">(</span><span class="n">define-type</span> <span class="n">Storage</span> <span class="p">(</span><span class="n">Listof</span> <span class="n">Datum</span><span class="p">))</span>

<span class="p">(</span><span class="n">:</span> <span class="n">new-storage</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="n">Storage</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">new-storage</span><span class="p">)</span> <span class="nb">empty</span><span class="p">)</span>

<span class="p">(</span><span class="n">:</span> <span class="n">store</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="n">Datum</span> <span class="n">Storage</span> <span class="n">Storage</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">store</span> <span class="n">datum</span> <span class="n">storage</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons</span> <span class="n">datum</span> <span class="n">storage</span><span class="p">))</span>

<span class="p">(</span><span class="n">:</span> <span class="n">take1</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="n">Storage</span> <span class="p">(</span><span class="n">List</span> <span class="n">Picture</span> <span class="n">Storage</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">take1</span> <span class="n">storage</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">empty?</span> <span class="n">storage</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">error</span> <span class="s2">&quot;Empty storage&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">top</span> <span class="p">(</span><span class="nb">first</span> <span class="n">storage</span><span class="p">)])</span>
            <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">Binding?</span> <span class="n">top</span><span class="p">)</span>
                <span class="c1">; Keep bindings while dropping values from storage.</span>
                <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">v</span> <span class="p">(</span><span class="n">take1</span> <span class="p">(</span><span class="nb">rest</span> <span class="n">storage</span><span class="p">))])</span>
                    <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">first</span> <span class="n">v</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="n">top</span> <span class="p">(</span><span class="nb">second</span> <span class="n">v</span><span class="p">))))</span>
                <span class="p">(</span><span class="nb">list</span> <span class="n">top</span> <span class="p">(</span><span class="nb">rest</span> <span class="n">storage</span><span class="p">))))))</span>
</pre></div>
</div>
<p>Since we defined <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">take2</span></span></code> in terms of <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">take1</span></span></code>, its definition remains
the same since it was defined independent of the internal structure of Storage.
We also need a function to lookup a bound identifier from the storage.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">:</span> <span class="n">lookup</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="n">Storage</span> <span class="n">Identifier</span> <span class="n">Picture</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">lookup</span> <span class="n">storage</span> <span class="n">id</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">empty?</span> <span class="n">storage</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">raise-user-error</span> <span class="o">&#39;</span><span class="ss">unbound-identifier</span> <span class="s2">&quot;Identifier &#39;~s&#39; is not defined&quot;</span> <span class="n">id</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">v</span> <span class="p">(</span><span class="nb">first</span> <span class="n">storage</span><span class="p">)])</span>
            <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="n">Binding?</span> <span class="n">v</span><span class="p">)</span>
                     <span class="p">(</span><span class="nb">equal?</span> <span class="p">(</span><span class="n">Binding-id</span> <span class="n">v</span><span class="p">)</span> <span class="n">id</span><span class="p">))</span>
                <span class="p">(</span><span class="n">Binding-value</span> <span class="n">v</span><span class="p">)</span>
                <span class="p">(</span><span class="n">lookup</span> <span class="p">(</span><span class="nb">rest</span> <span class="n">storage</span><span class="p">)</span> <span class="n">id</span><span class="p">)))))</span>
</pre></div>
</div>
<p>Using these two, we can modify our <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">process-instruction</span></span></code> to account for
making and using definitions as follows -</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">:</span> <span class="n">process-instruction</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="n">Storage</span> <span class="n">Instruction</span> <span class="n">Storage</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">process-instruction</span> <span class="n">storage</span> <span class="n">instruction</span><span class="p">)</span>
    <span class="p">(</span><span class="k">match</span> <span class="n">instruction</span>
        <span class="c1">; Definitions for SCircle etc.</span>
        <span class="p">[(</span><span class="n">SDefine</span> <span class="n">id</span><span class="p">)</span>
         <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">input</span> <span class="p">(</span><span class="n">take1</span> <span class="n">storage</span><span class="p">)])</span>
            <span class="p">(</span><span class="n">store</span> <span class="p">(</span><span class="n">Binding</span> <span class="n">id</span> <span class="p">(</span><span class="nb">first</span> <span class="n">input</span><span class="p">))</span> <span class="p">(</span><span class="nb">second</span> <span class="n">input</span><span class="p">)))]</span>
        <span class="p">[(</span><span class="n">SUse</span> <span class="n">id</span><span class="p">)</span>
         <span class="p">(</span><span class="n">store</span> <span class="p">(</span><span class="n">lookup</span> <span class="n">storage</span> <span class="n">id</span><span class="p">)</span> <span class="n">storage</span><span class="p">)]))</span>
</pre></div>
</div>
<p>With these two additions, we can now have some degree of reuse
when constructing pictures using our “language”.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">result</span>
    <span class="p">(</span><span class="n">run-machine</span> <span class="p">(</span><span class="n">new-storage</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="n">SCircle</span> <span class="mf">0.75</span> <span class="mf">0.1</span><span class="p">)</span>
                       <span class="p">(</span><span class="n">SDefine</span> <span class="o">&#39;</span><span class="ss">pic</span><span class="p">)</span> <span class="c1">; After this, the pic in storage is dropped.</span>
                       <span class="p">(</span><span class="n">SUse</span> <span class="o">&#39;</span><span class="ss">pic</span><span class="p">)</span>    <span class="c1">; ... so we need to add it back.</span>
                       <span class="p">(</span><span class="n">SColorize</span> <span class="mf">1.0</span> <span class="mf">1.0</span> <span class="mf">0.0</span> <span class="mf">0.0</span><span class="p">)</span>
                       <span class="p">(</span><span class="n">SUse</span> <span class="o">&#39;</span><span class="ss">pic</span><span class="p">)</span>
                       <span class="p">(</span><span class="n">SColorize</span> <span class="mf">1.0</span> <span class="mf">0.0</span> <span class="mf">0.0</span> <span class="mf">1.0</span><span class="p">)</span>
                       <span class="p">(</span><span class="n">STranslate</span> <span class="mf">0.5</span> <span class="mf">0.0</span><span class="p">)</span>
                       <span class="p">(</span><span class="n">SOverlay</span><span class="p">))))</span>
</pre></div>
</div>
<p>We can now compute a picture once and reuse it in as many parts as we want to.
Usually, such reuse of computations results in a bit of efficiency gain and
sure it does in this case, but only a tiny bit because much of the computation
in our case is spent not evaluating pictures, but in rendering pictures to
images. As we saw with <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">compiler.rkt</span></span></code>, addressing that is a different kind
of “optimization”.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Study the consequences of how we’ve implemented identifier binding and
lookup. In particular, supposing we bind one identifier twice, which of the
two values would the rest of the instructions end up using? How would we
recall the earlier binding if we wanted that? Is there any meaning to
asking for that in the context of our language?</p>
</div>
</div>
<div class="section" id="blocks-of-instructions">
<h2>Blocks of instructions<a class="headerlink" href="#blocks-of-instructions" title="Permalink to this headline">¶</a></h2>
<p>We can now capture the result of a computation and reuse it with other
combinators. However, we don’t yet have a mechanism to encapsulate computations
that we might want to perform repeatedly. Such a facility will give us some
additional abstraction power, though still weak in a number of ways.</p>
<p>An interesting way to look at this addition is that we have a Racket-level
<code class="docutils literal notranslate"><span class="pre">run-machine</span></code> function that can process a sequence of instructions.
That sounds like pretty much what we want for our facility. In other words,
we’re taking what we have available at Racket-level and making it available
within <strong>our language</strong>. We’ll see many instances of this thinking when
developing our language.</p>
<p>A “block” is a sequence of instructions that we’d like to be able to create,
store and “run”. So we need to augment our store to hold Block type values, and
define new instructions to make blocks and to run a block picked from storage.
Note that <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">SDefine</span></span></code> and <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">SUse</span></span></code> would also be expected to work with
blocks in addition to <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">Picture</span></span></code> values.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">struct</span> <span class="n">Block</span> <span class="p">([</span><span class="n">instructions</span> <span class="n">:</span> <span class="p">(</span><span class="n">Listof</span> <span class="n">Instruction</span><span class="p">)]))</span>

<span class="p">(</span><span class="n">define-type</span> <span class="n">Value</span> <span class="p">(</span><span class="n">U</span> <span class="n">Picture</span> <span class="n">Block</span><span class="p">))</span>

<span class="c1">; Note that we&#39;re binding an *evaluated* picture here.</span>
<span class="p">(</span><span class="k">struct</span> <span class="n">Binding</span> <span class="p">([</span><span class="n">id</span> <span class="n">:</span> <span class="n">Identifier</span><span class="p">]</span>
                 <span class="p">[</span><span class="n">value</span> <span class="n">:</span> <span class="n">Value</span><span class="p">]))</span>

<span class="p">(</span><span class="n">define-type</span> <span class="n">Datum</span> <span class="p">(</span><span class="n">U</span> <span class="n">Value</span> <span class="n">Binding</span><span class="p">))</span>
<span class="p">(</span><span class="n">define-type</span> <span class="n">Storage</span> <span class="p">(</span><span class="n">Listof</span> <span class="n">Datum</span><span class="p">))</span>

<span class="p">(</span><span class="k">struct</span> <span class="n">SBlock</span> <span class="p">([</span><span class="n">instructions</span> <span class="n">:</span> <span class="p">(</span><span class="n">Listof</span> <span class="n">Instruction</span><span class="p">)]))</span>
<span class="p">(</span><span class="k">struct</span> <span class="n">SRun</span> <span class="p">())</span>

<span class="p">(</span><span class="n">define-type</span> <span class="n">Instruction</span> <span class="p">(</span><span class="n">U</span> <span class="n">SCircle</span>
                            <span class="n">SColorize</span>
                            <span class="n">STranslate</span>
                            <span class="n">SOverlay</span>
                            <span class="n">SDefine</span>
                            <span class="n">SUse</span>
                            <span class="n">SBlock</span>
                            <span class="n">SRun</span><span class="p">))</span>

<span class="p">(</span><span class="n">:</span> <span class="n">process-instruction</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="n">Storage</span> <span class="n">Instruction</span> <span class="n">Storage</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">process-instruction</span> <span class="n">storage</span> <span class="n">instruction</span><span class="p">)</span>
    <span class="p">(</span><span class="k">match</span> <span class="n">instruction</span>
        <span class="c1">; Definitions for SCircle etc. up to SDefine and SUse</span>
        <span class="p">[(</span><span class="n">SBlock</span> <span class="n">instructions</span><span class="p">)</span>
         <span class="p">(</span><span class="n">store</span> <span class="p">(</span><span class="n">Block</span> <span class="n">instructions</span><span class="p">)</span> <span class="n">storage</span><span class="p">)]</span>
        <span class="p">[(</span><span class="n">SRun</span><span class="p">)</span>
         <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">b</span> <span class="p">(</span><span class="n">take1</span> <span class="n">storage</span><span class="p">)])</span>
            <span class="p">(</span><span class="n">run-machine</span> <span class="p">(</span><span class="nb">second</span> <span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="n">Block-instructions</span> <span class="p">(</span><span class="nb">first</span> <span class="n">b</span><span class="p">))))]))</span>
</pre></div>
</div>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>It looks like we’re done? Are we? Think through what the newly introduced
<code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">Block</span></span></code> object ends up providing us. Try different combinations and
compare what meaning you’d <strong>want</strong> to attribute to the program and whether
our machine actually implements <strong>that</strong> meaning or something else.</p>
</div>
</div>
<div class="section" id="reuse-versus-encapsulation">
<h2>Reuse versus encapsulation<a class="headerlink" href="#reuse-versus-encapsulation" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Think through the “exercises” before reading further. Spoilers ahead.</p>
</div>
<p>We’ve taken a couple of steps to “improving” our notional machine and its
instruction set with facilities to help with “reuse”. However, focusing on
“reuse” alone ends up leaving us with many gaps in our design that are,
broadly, detrimental to a general purpose programming language. Here are some.</p>
<p>The way we defined our <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">SBlock</span></span></code> instruction and the corresponding
<code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">Block</span></span></code> value and the <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">SRun</span></span></code> instruction, a block is free to consume
from and produce values into our storage. Not only that, it is also free to
lookup any identifiers from our storage as well as add new bindings to it. Once
a block completes “running”, an identifier that was earlier bound to a value
<span class="math notranslate nohighlight">\(a\)</span> may end up being bound to another value <span class="math notranslate nohighlight">\(b\)</span> afterwards.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Think about whether that behaviour is a “feature” or a “bug” in our
language? Think about how you would compose two such “block” computations.
Can a block create any “temporary bindings” within its instruction
sequence? If it can, can it do so with a guarantee of non-interference with
other blocks?</p>
</div>
<p>While “reuse” is a reasonable expectation of a programming language, a more
important and powerful expectation is “composeability of abstractions”, which
entails facilities for “encapsulating computations”.</p>
<p>An abstraction involves leaving out details not relevant in some particular
context. For example, an abstract notion of “addition” can be “there is a zero
which serves as identity, a + b is of the same type as a and b, and a + b = b +
a”. In that case, we leave out the specifics of <strong>how</strong> to add, and indeed
we’ve not said anything about “numbers” at all!</p>
<p>So in designing an encapsulation facility in a language, we need mechanisms to
hide “irrelevant details” like what temporary variables a block may introduce
for the purpose of its computation so that blocks of computation can be
composed without having to reason about each situation on a case by case basis.</p>
<p>λ-calculus already provides us with a powerful encapsulation mechanism –
functions – and an algebra around them. The implication of the α-renaming and
β-reduction rules is that a λ-term fully encapsulates the computation it
expresses so that it can be composed with other λ-terms consistently.</p>
<p>So our next stop will be to add functions to our language, proper.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Comp308: Principles of Programming Languages</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Welcome note</a></li>
<li class="toctree-l1"><a class="reference internal" href="racket-intro.html">A quick introduction to Racket and Scheme</a></li>
<li class="toctree-l1"><a class="reference internal" href="lambda.html">Lambda - the everything</a></li>
<li class="toctree-l1"><a class="reference internal" href="church.html">Lambda - via β-abstraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="piclang.html">A language for pictures</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine.html">A mental model for the machine</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Notional machine</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#instruction-sequence">Instruction sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#instructions-for-our-machine">Instructions for our “machine”</a></li>
<li class="toctree-l2"><a class="reference internal" href="#storage">Storage</a></li>
<li class="toctree-l2"><a class="reference internal" href="#instruction-processor">Instruction processor</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reflections">Reflections</a></li>
<li class="toctree-l2"><a class="reference internal" href="#introducing-identifiers">Introducing identifiers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#blocks-of-instructions">Blocks of instructions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reuse-versus-encapsulation">Reuse versus encapsulation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="growing.html">Growing the language</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun.html">Functions and scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="stacks-and-scope.html">Stacks and scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun-in-piclang.html">Functions in PicLang</a></li>
<li class="toctree-l1"><a class="reference internal" href="mutations.html">Mutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="control.html">Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="objects.html">Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="generators.html">Generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="appsem.html">Alternative application semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html">Types: Checking some program invariants statically</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="machine.html" title="previous chapter">A mental model for the machine</a></li>
      <li>Next: <a href="growing.html" title="next chapter">Growing the language</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Srikumar K. S..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/notional-machine.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>