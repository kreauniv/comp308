<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Lambda - via β-abstraction &#8212; Comp308: Principles of Programming Languages v1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=3d3fbe02" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=12dfc556" />
    <script src="_static/documentation_options.js?v=5cb08e4e"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="A language for pictures" href="piclang.html" />
    <link rel="prev" title="λ - the everything" href="lambda.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="lambda-via-abstraction">
<h1>Lambda - via β-abstraction<a class="headerlink" href="#lambda-via-abstraction" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">author<span class="colon">:</span></dt>
<dd class="field-odd"><p>Srikumar K. S.</p>
</dd>
<dt class="field-even">date<span class="colon">:</span></dt>
<dd class="field-even"><p>29 July 2023</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section is a repeat of the previous one but presents a slightly
different take on the topic via extensive use of β-abstraction. <strong>You can
skip this if you’re comfortable with the topic</strong>.</p>
</div>
<p>As we saw, Alonzo Church established that a “calculus” of functions is adequate
to express anything computable. He further shows how to start from “just
functions” and produce representations for what we normally need in expressing
various algorithms. A key part of this demonstration is a representation for
numbers that’s come to be known as “Church numerals”. We also saw how the idea
of recursion can also be expressed in terms of various “fixed point
combinators”.</p>
<p>Of course, nobody really programs with Church numerals, not to mention that
they are woefully in adequate for the absolute basics such as subtraction and
representing full integers. And we don’t really use fixed point combinators
very often in “real world programming”. <a class="footnote-reference brackets" href="#fpc" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> So what purpose does learning
these serve us?</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fpc" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>We’ll see some places where they are useful tools, even though these
largely arise when building up programming languages and not usually when
using a language to build programs.</p>
</aside>
</aside>
<p>When we program, we’re repeatedly dealing with abstraction and encapsulation.
We’ve seen that functions and function composition perform the job of
encapsulating computations and making them reusable. Working through Church
numerals and the fixed point combinators serves as a great exercise to practice
β-abstraction, which offers a systematic and explorative way to work our way up
from “we know how to do this” to “what is this exactly as a concept?”.</p>
<p>So this writeup focuses on a re-presentation of these ideas through the lens of
β-abstraction. I’m going to try and be explicit about the use of β-abstraction
throughout and at times that might feel trivial or laborious, but I hope you
gain enough fluency with the idea by the end that you don’t need to think hard
to leverage it in the future.</p>
<section id="calculus">
<h2>λ-calculus<a class="headerlink" href="#calculus" title="Link to this heading">¶</a></h2>
<p>So the basics first – expressed in Racket notation using s-expressions.</p>
<section id="its-stuff">
<h3>Its “stuff”<a class="headerlink" href="#its-stuff" title="Link to this heading">¶</a></h3>
<p>We call an expression of the notion of a “function” a “λ-term”.</p>
</section>
<section id="its-structure">
<h3>Its “structure”<a class="headerlink" href="#its-structure" title="Link to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>An identifier like <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, called “variables” due to the mathematical origin
of λ-calculus, is a “λ-term”.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are λ-terms, then <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">y)</span></code> is also a λ-term. This is
how function application is expressed.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is an identifier and <code class="docutils literal notranslate"><span class="pre">E[x]</span></code> is a λ-term that uses <code class="docutils literal notranslate"><span class="pre">x</span></code> in some
way (including not using it at all), then <code class="docutils literal notranslate"><span class="pre">(λ</span> <span class="pre">(x)</span> <span class="pre">E[x])</span></code> is a λ-term.</p></li>
</ol>
</section>
<section id="its-properties">
<h3>Its “properties”<a class="headerlink" href="#its-properties" title="Link to this heading">¶</a></h3>
<p><strong>α-renaming</strong></p>
<blockquote>
<div><p>Two λ-terms that differ only in a change of variable are equivalent.
<code class="docutils literal notranslate"><span class="pre">(λ</span> <span class="pre">(x)</span> <span class="pre">E[x])</span></code> is equivalent to and may be exchanged anywhere for
<code class="docutils literal notranslate"><span class="pre">(λ</span> <span class="pre">(y)</span> <span class="pre">E[y])</span></code>. Here <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are identifiers.</p>
</div></blockquote>
<p><strong>β-reduction</strong></p>
<blockquote>
<div><p>A λ-term of the form <code class="docutils literal notranslate"><span class="pre">((λ</span> <span class="pre">(x)</span> <span class="pre">E[x])</span> <span class="pre">y)</span></code> may be “reduced” to <code class="docutils literal notranslate"><span class="pre">E[y]</span></code>.
Here <code class="docutils literal notranslate"><span class="pre">y</span></code> is a λ-term. Note that if <code class="docutils literal notranslate"><span class="pre">y</span></code> features any “free variables”
(variables not bound to identifiers introduced by a <code class="docutils literal notranslate"><span class="pre">(λ</span> <span class="pre">(id)</span> <span class="pre">...)</span></code> term
that contains <code class="docutils literal notranslate"><span class="pre">y</span></code>), you’ll have to consider that the <code class="docutils literal notranslate"><span class="pre">(λ</span> <span class="pre">(x)</span> <span class="pre">E[x])</span></code> is
first α-renamed using unique identifiers before performing the
substitution.</p>
</div></blockquote>
<p><strong>β-abstraction</strong></p>
<blockquote>
<div><p>You can go the other way too. A λ-term of the form <code class="docutils literal notranslate"><span class="pre">E[y]</span></code> can be
“abstracted” to <code class="docutils literal notranslate"><span class="pre">((λ</span> <span class="pre">(x)</span> <span class="pre">E[x])</span> <span class="pre">y)</span></code>, provided <code class="docutils literal notranslate"><span class="pre">y</span></code> (a λ-term) does not
feature variables bound to other enclosing <code class="docutils literal notranslate"><span class="pre">(λ</span> <span class="pre">(id)</span> <span class="pre">...)</span></code> terms.</p>
</div></blockquote>
<p><strong>η-reduction</strong></p>
<blockquote>
<div><p>A λ-term <code class="docutils literal notranslate"><span class="pre">y</span></code> is considered equivalent to <code class="docutils literal notranslate"><span class="pre">(λ</span> <span class="pre">(x)</span> <span class="pre">(y</span> <span class="pre">x))</span></code> provided the
identifier <code class="docutils literal notranslate"><span class="pre">x</span></code> does not occur as a free variable in <code class="docutils literal notranslate"><span class="pre">y</span></code>. Note that all
terms in λ-calculus are what we’d call “functions”, so this equivalence can
be understood as one kind of equivalence of functions.</p>
</div></blockquote>
</section>
</section>
<section id="allowances">
<h2>Allowances<a class="headerlink" href="#allowances" title="Link to this heading">¶</a></h2>
<p>Strictly speaking, λ-calculus only talks about functions of one variable.
We can extend the idea to functions of multiple variables because this
case can be reduced to functions of one variable like this –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="n">E</span><span class="p">[</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="p">])</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="n">E</span><span class="p">[</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="p">]))</span>
</pre></div>
</div>
<p>We’ll also “define” identifiers to λ-terms using the usual Racket <code class="docutils literal notranslate"><span class="pre">(define</span>
<span class="pre">...)</span></code> construct.</p>
</section>
<section id="making-pairs">
<h2>Making pairs<a class="headerlink" href="#making-pairs" title="Link to this heading">¶</a></h2>
<p>Our starting point for building the edifice of useful computational objects
is the absolute basic data structure – the humble “pair” that associates
two objects. We need to be able to make pairs of objects, which are,
in our case, functions (we have nothing else to speak of).</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">.first</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">.second</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<p>Now we can pick one of two arguments using <code class="docutils literal notranslate"><span class="pre">(.first</span> <span class="pre">x</span> <span class="pre">y)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(.second</span> <span class="pre">x</span> <span class="pre">y)</span></code>. If we β-abstract on the first term in these two
expressions, we get –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="c1">; 1</span>
<span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="n">.first</span><span class="p">)</span>

<span class="c1">; and 2</span>
<span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="n">.second</span><span class="p">)</span>
</pre></div>
</div>
<p>We see that the head λ-terms are both identical up to α-renaming,
but still specific to <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>. So β-abstracting that term
on both <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> gives us the <code class="docutils literal notranslate"><span class="pre">pair</span></code> function.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span>
<span class="c1">; =&gt;</span>
<span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)))</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">swap</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="n">.second</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="n">.first</span><span class="p">))))</span>
</pre></div>
</div>
<p>We can now make pairs using <code class="docutils literal notranslate"><span class="pre">pair</span></code> and get its contents out using <code class="docutils literal notranslate"><span class="pre">.first</span></code>
and <code class="docutils literal notranslate"><span class="pre">.second</span></code>. The value of having the ability to make pairs is that we
can build pretty much any other data structure out of it. But we’ll first
need some basics like numbers to store in these data structures.</p>
</section>
<section id="church-numerals">
<h2>Church numerals<a class="headerlink" href="#church-numerals" title="Link to this heading">¶</a></h2>
<p>The word “numeral” refers to a way of expressing or representing a number.
So 123, 01111011, CXXIII, १२३ are all representations of the same <em>number</em>.
Church numerals are such a representation of numbers (whole numbers to be
precise) in λ-calculus.</p>
<p>The key idea behind Church numerals is to represent a whole number <code class="docutils literal notranslate"><span class="pre">n</span></code>
as “n applications of a function to a value”. Let’s write that down first.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">f</span><span class="w">   </span><span class="p">(</span><span class="n">f</span><span class="w">    </span><span class="p">(</span><span class="n">f</span><span class="w">   </span><span class="k">...</span><span class="w">   </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="k">...</span><span class="p">)))</span>
<span class="c1">; --- n occurrences of f ----</span>
</pre></div>
</div>
<p>So if <code class="docutils literal notranslate"><span class="pre">n</span></code> is a Church numeral representing the concept “n applications of f”,
we write <code class="docutils literal notranslate"><span class="pre">(n</span> <span class="pre">f)</span></code> when we’re considering it being applied to <code class="docutils literal notranslate"><span class="pre">f</span></code>. But we’re
talking of “n applications of f to x”, so we take the “n applications of f”
and apply it to <code class="docutils literal notranslate"><span class="pre">x</span></code>, to get <code class="docutils literal notranslate"><span class="pre">((n</span> <span class="pre">f)</span> <span class="pre">x)</span></code>. Therefore <code class="docutils literal notranslate"><span class="pre">n</span></code> will have the form
<code class="docutils literal notranslate"><span class="pre">(λ</span> <span class="pre">(f)</span> <span class="pre">(λ</span> <span class="pre">(x)</span> <span class="pre">...))</span></code>. Remember this, since we need to stick to this form for
all Church numerals and operators that combine them to produce other numerals.</p>
<p>Let’s look at “one application of f on x” first.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>But what are these <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code>. The answer in λ-calculus is “some two
functions”. Since these are “some two functions”, we can consider the
β-abstracted form of them that abstracts over both.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>The λ term <code class="docutils literal notranslate"><span class="pre">(λ</span> <span class="pre">(f)</span> <span class="pre">(λ</span> <span class="pre">(x)</span> <span class="pre">(f</span> <span class="pre">x)))</span></code> now captures the idea of “one
application of a function to an argument”. We use this λ-term to
represent the number “one”. Zero offers a simple case by extension.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-one</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-zero</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span>
</pre></div>
</div>
<section id="successor">
<h3>Successor<a class="headerlink" href="#successor" title="Link to this heading">¶</a></h3>
<p>To define representations for other numbers, we need a way to define
the idea of a “successor” function <code class="docutils literal notranslate"><span class="pre">ch-succ</span></code>, that can take us
from <code class="docutils literal notranslate"><span class="pre">zero</span></code> to <code class="docutils literal notranslate"><span class="pre">one</span></code> –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">ch-succ</span><span class="w"> </span><span class="n">ch-zero</span><span class="p">)</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">ch-one</span>
</pre></div>
</div>
<p>So how do we define <code class="docutils literal notranslate"><span class="pre">ch-succ</span></code>? We want <code class="docutils literal notranslate"><span class="pre">(ch-succ</span> <span class="pre">n)</span></code> to stand for “n+1
applications of f to x” or rather “one more application of f to x after n
applications”. We can therefore express this as <code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">((n</span> <span class="pre">f)</span> <span class="pre">x))</span></code>. Beta
abstracting over <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> first gives us the representation of “n+1” for
a specific n. This is <code class="docutils literal notranslate"><span class="pre">(λ</span> <span class="pre">(f)</span> <span class="pre">(λ</span> <span class="pre">(x)</span> <span class="pre">(f</span> <span class="pre">((n</span> <span class="pre">f)</span> <span class="pre">x))))</span></code>. To generalize over
<code class="docutils literal notranslate"><span class="pre">n</span></code>, we β-abstract over it to get <code class="docutils literal notranslate"><span class="pre">ch-succ</span></code>.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-succ</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">))))))</span>
</pre></div>
</div>
</section>
<section id="converting-between-racket-and-church-numerals">
<h3>Converting between Racket and Church numerals<a class="headerlink" href="#converting-between-racket-and-church-numerals" title="Link to this heading">¶</a></h3>
<p>To play with these concretely in Racket, you can use the following functions to
convert from Racket’s number representation to Church numerals.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="c1">; Here n is a Racket numeral</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;ch</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="n">ch-zero</span>
<span class="w">      </span><span class="p">(</span><span class="n">ch-succ</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;ch</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)))))</span>

<span class="c1">; Here n is a Church numeral</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">ch-&gt;i</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">  </span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="addition">
<h3>Addition<a class="headerlink" href="#addition" title="Link to this heading">¶</a></h3>
<p>Now how do you add two Church numerals? Given <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code> represent
their respective number of applications of a function <code class="docutils literal notranslate"><span class="pre">f</span></code> to an <code class="docutils literal notranslate"><span class="pre">x</span></code>,
we seek to calculate <code class="docutils literal notranslate"><span class="pre">((m</span> <span class="pre">f)</span> <span class="pre">((n</span> <span class="pre">f)</span> <span class="pre">x))</span></code>. As before, we β-abstract
over <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> to get the standard “Church numeral protocol”.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="n">m</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">))))</span>
</pre></div>
</div>
<p>The above is specific to some given <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code>. To generalize
to addition of arbitrary <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code>, we need to, once more,
β-abstract over them to get <code class="docutils literal notranslate"><span class="pre">ch-add</span></code>. This time though, we’ll
take the comfort of multi-argument functions since it is easier
to think of addition as a binary operator.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-add</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="n">m</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">))))))</span>

<span class="c1">; Try this out</span>
<span class="p">(</span><span class="n">ch-&gt;i</span><span class="w"> </span><span class="p">(</span><span class="n">ch-add</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;ch</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;ch</span><span class="w"> </span><span class="mi">3</span><span class="p">)))</span>
</pre></div>
</div>
<p>Taking advantage of the <code class="docutils literal notranslate"><span class="pre">compose</span></code> function defined as –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="nb">compose</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="p">)))))</span>
</pre></div>
</div>
<p>, we see that the above <code class="docutils literal notranslate"><span class="pre">ch-add</span></code> definition can be re-expressed in slightly
more abstracted form as –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-add</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">compose</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">f</span><span class="p">)))))</span>
</pre></div>
</div>
<p>This form brings out some of the symmetry between <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code> in the
operation, even though <code class="docutils literal notranslate"><span class="pre">compose</span></code> is a non-commutative operation in general.</p>
<p>Now, we can’t claim to have understood something if we can only explain it in
one way. Our representation for numbers is pretty abstract now – in that it is
talking about applications of an <strong>arbitrary</strong> function to an <strong>arbitrary</strong>
value. So we can also re-imagine the idea of <span class="math notranslate nohighlight">\(m+n\)</span> as “m’th successor of
n” or in other words, “m applications of <code class="docutils literal notranslate"><span class="pre">ch-succ</span></code> to n”. So <span class="math notranslate nohighlight">\(m+n\)</span> can
simply be expressed as <code class="docutils literal notranslate"><span class="pre">((m</span> <span class="pre">ch-succ)</span> <span class="pre">n)</span></code>. So indeed, we have, after
abstracting on <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code> –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-add</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="n">m</span><span class="w"> </span><span class="n">ch-succ</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="p">)))</span>
</pre></div>
</div>
<p>… which is an equally valid (and clearer) definition of <code class="docutils literal notranslate"><span class="pre">ch-add</span></code>.</p>
</section>
<section id="multiplication">
<h3>Multiplication<a class="headerlink" href="#multiplication" title="Link to this heading">¶</a></h3>
<p>Now how do we multiply two numbers? If <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code> are two Church numerals
standing for “m applications of f” and “n applications of f”, we seek to capture
the idea of “m applications of n applications of f”. This is easily expressed
as <code class="docutils literal notranslate"><span class="pre">(m</span> <span class="pre">(n</span> <span class="pre">f))</span></code> with the <code class="docutils literal notranslate"><span class="pre">x</span></code> already abstracted out. Therefore multiplication
is simply β-abstracting over <code class="docutils literal notranslate"><span class="pre">f</span></code> first, followed by a two-argument abstraction
over <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code> –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-mul</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">f</span><span class="p">)))))</span>
<span class="c1">; ... or equivalently simply</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-mul</span><span class="w"> </span><span class="nb">compose</span><span class="p">)</span>

<span class="c1">; Try this</span>
<span class="p">(</span><span class="n">ch-&gt;i</span><span class="w"> </span><span class="p">(</span><span class="n">ch-mul</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;ch</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;ch</span><span class="w"> </span><span class="mi">3</span><span class="p">)))</span>
</pre></div>
</div>
<p>We also note that this is ordinary function composition of <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
</section>
<section id="subtraction">
<h3>Subtraction<a class="headerlink" href="#subtraction" title="Link to this heading">¶</a></h3>
<p>How do you then get subtraction? Can we do a “predecessor” operator?</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">ch-&gt;i</span><span class="w"> </span><span class="p">(</span><span class="n">ch-pred</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;ch</span><span class="w"> </span><span class="mi">5</span><span class="p">)))</span>
<span class="c1">; Should print 4</span>
</pre></div>
</div>
<p>Let’s write a naïve version –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-pred</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="n">b-inverse</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">))))))</span>
</pre></div>
</div>
<p>i.e. if only we had access to <span class="math notranslate nohighlight">\(f^{-1}\)</span> as a function, we can just
use that and apply it once after applying <span class="math notranslate nohighlight">\(f\)</span> <code class="docutils literal notranslate"><span class="pre">n</span></code> times.</p>
<p>Supposing we change our representation of the function that we’re applying
<code class="docutils literal notranslate"><span class="pre">n</span></code> times, to include information about the inverse. Supposing our
functions always come in pairs and we can take the first part to get
the original function and the second part to get its inverse. So our
“protocol” now changes slightly and the <code class="docutils literal notranslate"><span class="pre">f</span></code> argument is now to be
treated as a <code class="docutils literal notranslate"><span class="pre">pair</span></code> of <span class="math notranslate nohighlight">\((f,f^{-1})\)</span>. Then we have the following
concept representations –</p>
<ol class="arabic simple">
<li><p>“successor” is one more application of the <strong>first</strong> part of the joint function
and can be written as <code class="docutils literal notranslate"><span class="pre">((f</span> <span class="pre">.first)</span> <span class="pre">((n</span> <span class="pre">f)</span> <span class="pre">x))</span></code>. (Think about what if <code class="docutils literal notranslate"><span class="pre">n</span></code>
stood for a negative number.)</p></li>
<li><p>“predecessor” is one more application of the <strong>second</strong> part of the joint function
and can be written as <code class="docutils literal notranslate"><span class="pre">((f</span> <span class="pre">.second)</span> <span class="pre">((n</span> <span class="pre">f)</span> <span class="pre">x))</span></code>.</p></li>
<li><p><span class="math notranslate nohighlight">\(m+n\)</span> can be thought of in the same way as for Church numerals, so we
can write <code class="docutils literal notranslate"><span class="pre">((m</span> <span class="pre">f)</span> <span class="pre">((n</span> <span class="pre">f)</span> <span class="pre">x))</span></code>. Here, the <code class="docutils literal notranslate"><span class="pre">f</span></code> is expected to be an
<span class="math notranslate nohighlight">\((f,f^{-1})\)</span> pair.</p></li>
<li><p><span class="math notranslate nohighlight">\(-n\)</span> (i.e. “negation”) is represented by swapping the pair of functions,
so we get <code class="docutils literal notranslate"><span class="pre">(n</span> <span class="pre">(swap</span> <span class="pre">f))</span></code> as the representation of <span class="math notranslate nohighlight">\(-n\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(m*n\)</span> is again thought of as “m applications of n applications f”, but
this time, the “m applications” part needs to receive a “pair”
representation, and <code class="docutils literal notranslate"><span class="pre">(n</span> <span class="pre">f)</span></code> does not produce a pair value. Furthermore, if
<code class="docutils literal notranslate"><span class="pre">m</span></code> is positive, we ned to use <code class="docutils literal notranslate"><span class="pre">(n</span> <span class="pre">f)</span></code> and if it is negative, we need to
use <span class="math notranslate nohighlight">\(-n\)</span> which we know is <code class="docutils literal notranslate"><span class="pre">(n</span> <span class="pre">(swap</span> <span class="pre">f))</span></code>. These two are inverses of
each other, so the idea of <span class="math notranslate nohighlight">\(m*n\)</span> is captured by <code class="docutils literal notranslate"><span class="pre">(m</span> <span class="pre">(pair</span> <span class="pre">(n</span> <span class="pre">f)</span> <span class="pre">(n</span>
<span class="pre">(swap</span> <span class="pre">f))))</span></code>. Think a bit more about how that’d play out for various
combinations of signs for <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p></li>
</ol>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Apply β-abstraction to those terms to define <code class="docutils literal notranslate"><span class="pre">b-zero</span></code>, <code class="docutils literal notranslate"><span class="pre">b-succ</span></code>,
<code class="docutils literal notranslate"><span class="pre">b-pred</span></code>, <code class="docutils literal notranslate"><span class="pre">b-add</span></code>, <code class="docutils literal notranslate"><span class="pre">b-sub</span></code> and <code class="docutils literal notranslate"><span class="pre">b-mul</span></code>.</p>
</div>
<p>We also need to define new converters between Racket and these “b”
representations (“b” chosen for “Brahmagupta” - see <a class="reference external" href="https://sriku.org/posts/church-brahmagupta-numerals/">Church-Brahmagupta
numerals</a>).</p>
<div class="highlight-Racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">b-&gt;i</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">  </span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="nb">add1</span><span class="w"> </span><span class="nb">sub1</span><span class="p">))</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;b</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="n">b-zero</span>
<span class="w">      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="n">b-succ</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;b</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span>
<span class="w">        </span><span class="p">(</span><span class="n">b-pred</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;b</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">))))))</span>

<span class="c1">; Try this</span>
<span class="p">(</span><span class="n">b-&gt;i</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;b</span><span class="w"> </span><span class="mi">-10</span><span class="p">))</span>
<span class="p">(</span><span class="n">b-&gt;i</span><span class="w"> </span><span class="p">(</span><span class="n">b-add</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;b</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;b</span><span class="w"> </span><span class="mi">3</span><span class="p">)))</span>
<span class="p">(</span><span class="n">b-&gt;i</span><span class="w"> </span><span class="p">(</span><span class="n">b-sub</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;b</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;b</span><span class="w"> </span><span class="mi">5</span><span class="p">)))</span>
<span class="p">(</span><span class="n">b-&gt;i</span><span class="w"> </span><span class="p">(</span><span class="n">b-mul</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;b</span><span class="w"> </span><span class="mi">-5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;b</span><span class="w"> </span><span class="mi">3</span><span class="p">)))</span>
<span class="p">(</span><span class="n">b-&gt;i</span><span class="w"> </span><span class="p">(</span><span class="n">b-mul</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;b</span><span class="w"> </span><span class="mi">-5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;b</span><span class="w"> </span><span class="mi">-3</span><span class="p">)))</span>
</pre></div>
</div>
</section>
</section>
<section id="understanding-recursion">
<h2>Understanding recursion<a class="headerlink" href="#understanding-recursion" title="Link to this heading">¶</a></h2>
<p>We have the whole of integers done now. However, we haven’t solved the case of
repetition – a.k.a. “iteration” – which in functional terms we express using
the concept of “recursion”. In fact, even in the previous section, in our
definitions of the conversion functions, we assumed the ability to define and
use recursive functions … and that’s not in our λ-calculus formalism.</p>
<p>So we need to be able to express recursion using ordinary λ-terms.</p>
<p>Let’s take an example – the Newton-Raphson solver for the root of a function
near a given guess point.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">eps</span><span class="p">)</span>
<span class="w">             </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">eps</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">eps</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">eps</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">solve</span>
<span class="w">  </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">xn</span><span class="w"> </span><span class="n">zero-eps</span><span class="w"> </span><span class="n">d-eps</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="p">(</span><span class="nb">abs</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">xn</span><span class="p">))</span><span class="w"> </span><span class="n">zero-eps</span><span class="p">)</span>
<span class="w">         </span><span class="n">xn</span>
<span class="w">         </span><span class="p">(</span><span class="n">solve</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">xn</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">xn</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">xn</span><span class="w"> </span><span class="n">d-eps</span><span class="p">)))</span><span class="w"> </span><span class="n">zero-eps</span><span class="w"> </span><span class="n">d-eps</span><span class="p">))))</span>
</pre></div>
</div>
<p>At the point at which we’re “define”-ing <code class="docutils literal notranslate"><span class="pre">solve</span></code>, we’re already assuming
its availability in the body of the definition. This is not a facility we
included in λ-calculus. So we’d either have to cave in and include this
new possibility, thereby extending the “language” or show how the concept
can be captured with the currently available facilities.</p>
<p>First, we recognize that we don’t know what the value of <code class="docutils literal notranslate"><span class="pre">solve</span></code> in the
inner definition part should be. So how do we account for it? Yes, we
β-abstract it out and make it an argument like this –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">solve/cheat</span>
<span class="w">  </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">solve</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">xn</span><span class="w"> </span><span class="n">zero-eps</span><span class="w"> </span><span class="n">d-eps</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="p">(</span><span class="nb">abs</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">xn</span><span class="p">))</span><span class="w"> </span><span class="n">zero-eps</span><span class="p">)</span>
<span class="w">            </span><span class="n">xn</span>
<span class="w">            </span><span class="p">(</span><span class="n">solve</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">xn</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">xn</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">xn</span><span class="w"> </span><span class="n">d-eps</span><span class="p">)))</span><span class="w"> </span><span class="n">zero-eps</span><span class="w"> </span><span class="n">d-eps</span><span class="p">)))))</span>
</pre></div>
</div>
<p>Now, when we actually have the <code class="docutils literal notranslate"><span class="pre">solve</span></code> function available, we can pass it to
<code class="docutils literal notranslate"><span class="pre">solve/cheat</span></code> like <code class="docutils literal notranslate"><span class="pre">(solve/cheat</span> <span class="pre">solve)</span></code> to get … the <code class="docutils literal notranslate"><span class="pre">solve</span></code> function!
i.e. we have the equation <code class="docutils literal notranslate"><span class="pre">solve</span> <span class="pre">=</span> <span class="pre">(solve/cheat</span> <span class="pre">solve)</span></code>. The gap here is that
while <code class="docutils literal notranslate"><span class="pre">solve/cheat</span></code> is a well formed λ-term and captures the calculation we
intend to do, we still don’t know how to get <code class="docutils literal notranslate"><span class="pre">solve</span></code> out of it.</p>
<p>In mathematical terminology, a value <span class="math notranslate nohighlight">\(x\)</span> that satisfies <span class="math notranslate nohighlight">\(f(x) = x\)</span>
for some given function <span class="math notranslate nohighlight">\(f\)</span> is said to be a “fixed point” of <span class="math notranslate nohighlight">\(f\)</span>.
The “fixed” comes from trying to apply <span class="math notranslate nohighlight">\(f\)</span> repeatedly to a value. If you
choose an <span class="math notranslate nohighlight">\(x\)</span> such that <span class="math notranslate nohighlight">\(x = f(x)\)</span>, then no matter how many times
you apply it, the value doesn’t change – i.e. stays “fixed”. So we’re in
essence seeking the “fixed point” of <code class="docutils literal notranslate"><span class="pre">solve/cheat</span></code>.</p>
<p>One other trick we can do is to rewrite <code class="docutils literal notranslate"><span class="pre">solve</span></code> using an extra argument,
in which slot we intend to pass itself.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">solve2</span>
<span class="w">  </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">xn</span><span class="w"> </span><span class="n">zero-eps</span><span class="w"> </span><span class="n">d-eps</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="p">(</span><span class="nb">abs</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">xn</span><span class="p">))</span><span class="w"> </span><span class="n">zero-eps</span><span class="p">)</span>
<span class="w">         </span><span class="n">xn</span>
<span class="w">         </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">xn</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">xn</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">xn</span><span class="w"> </span><span class="n">d-eps</span><span class="p">)))</span><span class="w"> </span><span class="n">zero-eps</span><span class="w"> </span><span class="n">d-eps</span><span class="p">))))</span>
</pre></div>
</div>
<p>Now instead of <code class="docutils literal notranslate"><span class="pre">solve</span></code>, we can call the well-formed <code class="docutils literal notranslate"><span class="pre">solve2</span></code> like
<code class="docutils literal notranslate"><span class="pre">(solve2</span> <span class="pre">solve2</span> <span class="pre">f</span> <span class="pre">xn</span> <span class="pre">zero-eps</span> <span class="pre">d-eps)</span></code>. This is “almost usable” and
it looks like we have a mechanical way to deal with recursive functions.
If it is truly mechanical, we need to be able to express the transformation
from <code class="docutils literal notranslate"><span class="pre">solve/cheat</span></code> to a form that can be used exactly like <code class="docutils literal notranslate"><span class="pre">solve</span></code>
using an appropriate λ-term definintion.</p>
<p>First, we rewrite <code class="docutils literal notranslate"><span class="pre">solve2</span></code> by pulling out the first argument.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">solve/good</span>
<span class="w">  </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">xn</span><span class="w"> </span><span class="n">zero-eps</span><span class="w"> </span><span class="n">d-eps</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="p">(</span><span class="nb">abs</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">xn</span><span class="p">))</span><span class="w"> </span><span class="n">zero-eps</span><span class="p">)</span>
<span class="w">            </span><span class="n">xn</span>
<span class="w">            </span><span class="p">((</span><span class="n">g</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">xn</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">xn</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">xn</span><span class="w"> </span><span class="n">d-eps</span><span class="p">)))</span><span class="w"> </span><span class="n">zero-eps</span><span class="w"> </span><span class="n">d-eps</span><span class="p">)))))</span>
</pre></div>
</div>
<p>Now, we see that <code class="docutils literal notranslate"><span class="pre">solve</span> <span class="pre">=</span> <span class="pre">(solve/good</span> <span class="pre">solve/good)</span></code>.</p>
<p>We can also therefore see that –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">solve/good</span><span class="w"> </span><span class="n">solve/good</span><span class="p">)</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="n">solve/cheat</span><span class="w"> </span><span class="p">(</span><span class="n">solve/good</span><span class="w"> </span><span class="n">solve/good</span><span class="p">))</span>
</pre></div>
</div>
<p>For brevity, we’ll drop the “solve/” prefixes for now and just write –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="n">solve</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="n">good</span><span class="w"> </span><span class="n">good</span><span class="p">)</span>
<span class="p">(</span><span class="n">good</span><span class="w"> </span><span class="n">good</span><span class="p">)</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="w"> </span><span class="p">(</span><span class="n">good</span><span class="w"> </span><span class="n">good</span><span class="p">))</span>
</pre></div>
</div>
<p>We also see <code class="docutils literal notranslate"><span class="pre">(good</span> <span class="pre">f)</span> <span class="pre">=</span> <span class="pre">(cheat</span> <span class="pre">(f</span> <span class="pre">f))</span></code> by simple β-reduction of <code class="docutils literal notranslate"><span class="pre">cheat</span></code>.</p>
<p>So we have <code class="docutils literal notranslate"><span class="pre">good</span> <span class="pre">=</span> <span class="pre">(λ</span> <span class="pre">(f)</span> <span class="pre">(cheat</span> <span class="pre">(f</span> <span class="pre">f)))</span></code>.</p>
<p>This gets us –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="n">solve</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="n">good</span><span class="w"> </span><span class="n">good</span><span class="p">)</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">g</span><span class="p">))</span><span class="w"> </span><span class="n">good</span><span class="p">)</span>
<span class="w">      </span><span class="nb">=</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">g</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">f</span><span class="p">))))</span>
</pre></div>
</div>
<p>β-abstracting over cheat gets us –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="n">solve</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">g</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">f</span><span class="p">)))))</span><span class="w"> </span><span class="n">cheat</span><span class="p">)</span>
</pre></div>
</div>
<p>The λ-term being applied to <code class="docutils literal notranslate"><span class="pre">cheat</span></code> is now producing a solution of
the equation <code class="docutils literal notranslate"><span class="pre">solve</span> <span class="pre">=</span> <span class="pre">(cheat</span> <span class="pre">solve)</span></code> and captures the entire process of
the transformation! This “fixed point combinator” is called the “Y combinator”.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">g</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">f</span><span class="p">))))))</span>
</pre></div>
</div>
<p><strong>Take a moment</strong> to savour that! We now have a function that can take a
<strong>specification</strong> of a recursive/iterative/repetitive evaluation and actually
produce a function that does the repetition. We’ve completed the “mechanical
transformation” demand we set out to meet!</p>
<p>Now, given a “cheat” function, we can get the actual recursive function
using <code class="docutils literal notranslate"><span class="pre">(Y</span> <span class="pre">solve/cheat)</span></code>.</p>
<p>Taking a step back, we’re actually trying to find a function <code class="docutils literal notranslate"><span class="pre">F</span></code> such that</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">F</span><span class="w"> </span><span class="n">cheat</span><span class="p">)</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="w"> </span><span class="p">(</span><span class="n">F</span><span class="w"> </span><span class="n">cheat</span><span class="p">))</span>
</pre></div>
</div>
<p>This <code class="docutils literal notranslate"><span class="pre">F</span></code> seems to be itself recursively defined and we seem to be back at
square one. However, we can apply our “good” trick to <code class="docutils literal notranslate"><span class="pre">F</span></code>.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="w"> </span><span class="p">(</span><span class="n">F</span><span class="w"> </span><span class="n">cheat</span><span class="p">))))</span>
<span class="c1">; =&gt;</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">G</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="w"> </span><span class="p">((</span><span class="n">h</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="n">cheat</span><span class="p">)))))</span>
<span class="c1">; =&gt; F = (G G)</span>
<span class="c1">; =&gt; F = ((λ (g) (g g)) G)</span>
<span class="c1">; =&gt;</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">g</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="w"> </span><span class="p">((</span><span class="n">h</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="n">cheat</span><span class="p">)))))</span>
</pre></div>
</div>
<p>This gets us <strong>another</strong> fixed point combinator called the “Turing combinator”
also written as the <span class="math notranslate nohighlight">\(\Theta\)</span>-combinator.</p>
<p>Note that neither <code class="docutils literal notranslate"><span class="pre">Y</span></code> nor <code class="docutils literal notranslate"><span class="pre">Θ</span></code> in the above forms work in normal Racket.
They require the <code class="docutils literal notranslate"><span class="pre">#lang</span> <span class="pre">lazy</span></code> language because we’ve been doing equational
reasoning that’s only valid as long as we’re not eagerly performing
β-reductions everywhere.</p>
<p>One way to make, say, <code class="docutils literal notranslate"><span class="pre">Θ</span></code> work in ordinary “eager” Racket is to realize that
the the problematic eager expansion is the <code class="docutils literal notranslate"><span class="pre">((h</span> <span class="pre">h)</span> <span class="pre">cheat)</span></code> part. Since this
whole expression is a function, we can use η-transformation on this to delay
its computation to the point when it is needed within the body of <code class="docutils literal notranslate"><span class="pre">cheat</span></code>, by
writing it as <code class="docutils literal notranslate"><span class="pre">(λ</span> <span class="pre">(x)</span> <span class="pre">(((h</span> <span class="pre">h)</span> <span class="pre">cheat)</span> <span class="pre">x))</span></code>. With this, the <code class="docutils literal notranslate"><span class="pre">((h</span> <span class="pre">h)</span> <span class="pre">cheat)</span></code>
won’t get evaluated until <code class="docutils literal notranslate"><span class="pre">cheat</span></code> needs it, at which point it will invoke it
with an appropriate argument.</p>
<p>So the “eager” version of the Turing combinator is written as –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">Θ</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">g</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(((</span><span class="n">h</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="n">cheat</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">)))))))</span>
</pre></div>
</div>
<p>If you have the careful eye, you’d notice that <code class="docutils literal notranslate"><span class="pre">x</span></code> is the argument we’d want to
pass to our original recursive function and we had many arguments to pass. So
it would’ve been more appropriate to write that as –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">Θ</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">g</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="p">((</span><span class="n">h</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="n">cheat</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">)))))))</span>
</pre></div>
</div>
<p>Here, if an identifier is given without parentheses, Racket will bind it to
the entire list of arguments that will be given to the λ, and <code class="docutils literal notranslate"><span class="pre">apply</span></code>
applies a function to a given <strong>list</strong> of arguments.</p>
<p>Similarly, we can also make the Y combinator eager like this –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">g</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">)))))))</span>
</pre></div>
</div>
</section>
<section id="moral-of-the-story">
<h2>Moral of the story<a class="headerlink" href="#moral-of-the-story" title="Link to this heading">¶</a></h2>
<p>We started with low level ideas and have systematically moved to work with
higher level concepts using β-abstraction. In particular, arriving at the
general “fixed point combinators” starting from concrete specifications of
recursive/iterative/repetitive computations was done through β-abstraction
steps too. Now we’re in a position where we can study these resultant artifacts
to understand the essence of recursive computations, whereas originally we were
forced to pick concrete examples to think about. In that sense, we can <strong>now</strong>
claim that we “understand” the idea of recursion because we know how to
mechanize it. Even if Racket didn’t give us a way to express recursive
computations by letting us use a name before it being fully defined, we now
know how to deal with that <strong>mechanically</strong> and can give ourselves recursion.</p>
<p>This pattern crops up in many situations where we start off with a cursory and
weak understanding of concrete aspects and through systematic and judicial
application of β-abstraction, we can arrive at the key concepts important to
the domain. This is therefore a powerful process of “theory building” for a
domain that we can do as programmers.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Comp308: Principles of Programming Languages</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Welcome note</a></li>
<li class="toctree-l1"><a class="reference internal" href="racket-intro.html">A quick introduction to Racket and Scheme</a></li>
<li class="toctree-l1"><a class="reference internal" href="lambda.html">λ - the everything</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Lambda - via β-abstraction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#calculus">λ-calculus</a></li>
<li class="toctree-l2"><a class="reference internal" href="#allowances">Allowances</a></li>
<li class="toctree-l2"><a class="reference internal" href="#making-pairs">Making pairs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#church-numerals">Church numerals</a></li>
<li class="toctree-l2"><a class="reference internal" href="#understanding-recursion">Understanding recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="#moral-of-the-story">Moral of the story</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="piclang.html">A language for pictures</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine.html">A mental model for the machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="notional-machine.html">Notional machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="growing.html">Growing the language</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun.html">Functions and scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="stacks-and-scope.html">Stacks and scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun-in-piclang.html">Functions in PicLang</a></li>
<li class="toctree-l1"><a class="reference internal" href="mutations.html">Mutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="control.html">Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="errornot.html">On the choice between “error” and “do something reasonable” in design</a></li>
<li class="toctree-l1"><a class="reference internal" href="objects.html">Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="objects-self.html">Objects - the Self way</a></li>
<li class="toctree-l1"><a class="reference internal" href="dispatch.html">Polymorphism via dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="generators.html">Generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="appsem.html">Alternative application semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html">Types: Checking some program invariants statically</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="lambda.html" title="previous chapter">λ - the everything</a></li>
      <li>Next: <a href="piclang.html" title="next chapter">A language for pictures</a></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2022, Srikumar K. S..
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="_sources/church.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>