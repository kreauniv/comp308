
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Lambda - the everything &#8212; Comp308: Principles of Programming Languages v1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="A language for pictures" href="piclang.html" />
    <link rel="prev" title="A quick introduction to Racket and Scheme" href="racket-intro.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="lambda-the-everything">
<h1>Lambda - the everything<a class="headerlink" href="#lambda-the-everything" title="Permalink to this heading">¶</a></h1>
<p>If Alonzo Church were asked “how far does the computational rabbit hole go?”,
he might have answered “It’s <code class="code highlight racket docutils literal highlight-racket"><span class="k">lambda</span><span class="w"></span></code> all the way through.”.</p>
<p>Alonzo Church, in the 1930s (yes, that’s getting to be a century ago!), and his
students formulated what could be called the essence of anything computable.
The insight they had was that given functions and function applications,
anything that can be computed is expressible. Note that we aren’t talking about
functions of numbers or strings or booleans or anything else. The only entities
in Church’s world are functions, and the only thing you can do with them is to
apply them to other things (which are … functions) … and he claimed that
all of what’s computable is expressible using these! What’s known as the
<a class="reference external" href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">Church-Turing thesis</a> is the proof that Church’s “lambda calculus” is
equivalent in its universality to Alan Turing’s “Turing machine”.</p>
<p>Take a moment to digest that large claim, for the <code class="code highlight racket docutils literal highlight-racket"><span class="k">lambda</span><span class="w"></span></code> construct in
Scheme is directly based on that foundational insight. In studying programming
languages, we repeatedly encounter this idea of “we can express X in terms of
Y” and where we make larger sets of these “X”s for our convenience where a much
smaller set of “Y”s will suffice for the job. This “extra”, we call “syntactic
sugar”, which draws from Alan Perlis’ joke - “Syntactic sugar causes cancer of
the semicolon.” – made in reference to unessential syntactic cruft often added
on to programming languages by their creators without a taste for minimalism.</p>
<p>The process of taking an expression that’s rich in “syntactic sugar” and
producing an equivalent expression using fewer “primitives” is something we’ll
refer to as “desugaring”. Such a reduction is useful because it is usually
easier to reason about properties of a program if we have to deal with fewer
basic entities in it, than if we complicate it with … well, “syntactic
sugar”. Since desugaring is a kind of translation, it could also be taken as a
kind of “compilation”, but in case that scares you, don’t worry and just stick
to “desugaring”.</p>
<p>The point of lambdas is that lambdas are at the end of the entire stack of
sugarings. The buck stops with them.</p>
<section id="so-what-s-lambda">
<h2>So what’s <code class="code highlight racket docutils literal highlight-racket"><span class="k">lambda</span><span class="w"></span></code><a class="headerlink" href="#so-what-s-lambda" title="Permalink to this heading">¶</a></h2>
<p>In Scheme, a “lambda expression” is an expression of the general form
shown below –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">..&lt;list-of-var-names&gt;..</span><span class="p">)</span><span class="w"> </span><span class="n">&lt;expr-using-vars-in-the-list&gt;</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>It represents a packaged computation that can be performed when given concrete
values for the variables listed after <code class="code highlight racket docutils literal highlight-racket"><span class="k">lambda</span><span class="w"></span></code> in the above expression.</p>
<p>For example, <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"></span></code> is the function that squares numbers.
When given a number <code class="code highlight racket docutils literal highlight-racket"><span class="mi">2</span><span class="w"></span></code>, by substituting <code class="code highlight racket docutils literal highlight-racket"><span class="n">x</span><span class="w"></span></code> with <code class="code highlight racket docutils literal highlight-racket"><span class="mi">2</span><span class="w"></span></code>, you can
compute the result of what the lambda expression denotes – which is <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="mi">4</span><span class="w"></span></code>.</p>
<p>There are two main rules you need to know when working with <code class="code highlight racket docutils literal highlight-racket"><span class="k">lambda</span><span class="w"></span></code>
expressions (the abstract ones).</p>
<dl>
<dt><strong>α-renaming</strong></dt><dd><p>If <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">E</span><span class="p">[</span><span class="n">x</span><span class="p">])</span><span class="w"></span></code> is a lambda expression in one argument where <code class="code highlight racket docutils literal highlight-racket"><span class="n">E</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"></span></code>
denotes some expression involving the variable <code class="code highlight racket docutils literal highlight-racket"><span class="n">x</span><span class="w"></span></code>, then you can change
the name of <code class="code highlight racket docutils literal highlight-racket"><span class="n">x</span><span class="w"></span></code> to anything else and what the expression denotes is
considered to be the same. i.e. You can rewrite it to <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="n">E</span><span class="p">[</span><span class="n">y</span><span class="p">])</span><span class="w"></span></code>
(where we use the same <code class="code highlight racket docutils literal highlight-racket"><span class="n">E</span><span class="w"></span></code>) and it means the same thing … as long as
E doesn’t already use <code class="code highlight racket docutils literal highlight-racket"><span class="n">y</span><span class="w"></span></code> as a free variable.</p>
</dd>
<dt><strong>β-reduction</strong></dt><dd><p>If you have an expression of the form <code class="code highlight racket docutils literal highlight-racket"><span class="p">((</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">E1</span><span class="p">[</span><span class="n">x</span><span class="p">])</span><span class="w"> </span><span class="n">E2</span><span class="p">)</span><span class="w"></span></code> where <code class="code highlight racket docutils literal highlight-racket"><span class="n">E1</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"></span></code>
is an expression that (optionally) uses the variable <code class="code highlight racket docutils literal highlight-racket"><span class="n">x</span><span class="w"></span></code> and <code class="code highlight racket docutils literal highlight-racket"><span class="n">E2</span><span class="w"></span></code> is some other
expression, then it is equivalent to <code class="code highlight racket docutils literal highlight-racket"><span class="n">E1</span><span class="p">[</span><span class="n">E2</span><span class="p">]</span><span class="w"></span></code>. i.e.</p>
<blockquote>
<div><p><code class="code highlight racket docutils literal highlight-racket"><span class="p">((</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">E1</span><span class="p">[</span><span class="n">x</span><span class="p">])</span><span class="w"> </span><span class="n">E2</span><span class="p">)</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">E1</span><span class="p">[</span><span class="n">E2</span><span class="p">]</span><span class="w"></span></code></p>
</div></blockquote>
<p>It is important to note that when we say “is equivalent to”, it means you
can rewrite a sub-expression that looks like one side to the other form
<strong>anywhere</strong>. We refer to the above left-to-right rewrite as “β-reduction”
and the corresponding right-to-left rewrite as “β-abstraction”.</p>
<p>Just as lambdas offer a conceptual basis of all of computation, all
abstraction in computing can be seen through β-abstraction.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>“<strong>β-reduction</strong>” can be considered a fancy term for “substitution”,
for that’s what it is. We don’t have a corresponding simple term for the
opposite transformation though. So we’ll continue to call it
“<strong>β-abstraction</strong>”. We’ll refer to the transformation <code class="code highlight racket docutils literal highlight-racket"><span class="n">E1</span><span class="p">[</span><span class="n">E2</span><span class="p">]</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"></span>
<span class="p">((</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">E1</span><span class="p">[</span><span class="n">x</span><span class="p">])</span><span class="w"> </span><span class="n">E2</span><span class="p">)</span><span class="w"></span></code> as “β-abstracting over <code class="code highlight racket docutils literal highlight-racket"><span class="n">E2</span><span class="w"></span></code>”. In most cases,
when we’re performing such a transformation, we’re no longer really
interested in the <code class="code highlight racket docutils literal highlight-racket"><span class="n">E2</span><span class="w"></span></code> and will usually focus on the preceding
<code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">E1</span><span class="p">[</span><span class="n">x</span><span class="p">])</span><span class="w"></span></code> and loosely talk about that as the β-abstracted
expression.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When performing a β-reduction step in Scheme, you need to be careful
not to substitute symbols within a <code class="code highlight racket docutils literal highlight-racket"><span class="k">quote</span><span class="w"></span></code> sub-expression. For example,
<code class="code highlight racket docutils literal highlight-racket"><span class="p">((</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">quote</span><span class="w"> </span><span class="p">(</span><span class="ss">+</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">x</span><span class="p">)))</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"></span></code> reduces to the list <code class="code highlight racket docutils literal highlight-racket"><span class="o">&#39;</span><span class="p">(</span><span class="ss">+</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">x</span><span class="p">)</span><span class="w"></span></code>
whereas <code class="code highlight racket docutils literal highlight-racket"><span class="p">((</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"></span></code> reduces to <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="mi">6</span><span class="w"></span></code>.</p>
</div>
<p>Take the expression <code class="code highlight racket docutils literal highlight-racket"><span class="p">((</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">((</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span></code> and
try to apply the reduction rules. If you took the “β-reduction” rule in the
naive way, you might end up with <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">((</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w"></span></code> and
then scratch your head about what you have at hand and what to do with it next!
To do this correctly, you must see that the original expression is the same as
<code class="code highlight racket docutils literal highlight-racket"><span class="p">((</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">((</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span></code> .. where we’ve “α-renamed”
the inner lambda’s <code class="code highlight racket docutils literal highlight-racket"><span class="n">x</span><span class="w"></span></code> variable to <code class="code highlight racket docutils literal highlight-racket"><span class="n">y</span><span class="w"></span></code>, because, well they’re supposed to
be equivalent right? If you now do β-reduction on this equivalent expression,
you won’t be left with the confused expression.</p>
<p>So the two rules are taken to be <strong>always</strong> applicable in evaluating an
expression and all correct applications of the rules must evaluate to
the same result no matter the sequence in which they’re applied.</p>
</section>
<section id="tall-claims-need-taller-evidence">
<h2>Tall claims need taller evidence<a class="headerlink" href="#tall-claims-need-taller-evidence" title="Permalink to this heading">¶</a></h2>
<p>Back to Church, what he made was a tall claim – that all computable functions
are expressible in terms of lambdas. When we make such a claim, we have to back
it up though. To recap, he’s saying that you don’t need <code class="code highlight racket docutils literal highlight-racket"><span class="nb">cons</span><span class="w"></span></code>, <code class="code highlight racket docutils literal highlight-racket"><span class="nb">car</span><span class="w"></span></code>,
<code class="code highlight racket docutils literal highlight-racket"><span class="nb">cdr</span><span class="w"></span></code>, <code class="code highlight racket docutils literal highlight-racket"><span class="k">if</span><span class="w"></span></code>, <code class="code highlight racket docutils literal highlight-racket"><span class="k">let</span><span class="w"></span></code>, <code class="code highlight racket docutils literal highlight-racket"><span class="k">cond</span><span class="w"></span></code>, booleans or numbers or strings or whatever
we’re used to in normal programming. He claimed that all of these are
representable using lambdas <strong>alone</strong> .. and showed how to do it.</p>
<p>We’ll now work through how to represent basic things in terms of which we
can build a whole computational edifice.</p>
<section id="pairs">
<h3>Pairs<a class="headerlink" href="#pairs" title="Permalink to this heading">¶</a></h3>
<p>Pairs are the simplest of data structures. Once you can make a pair of two
things like <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span></code> or the equivalent in a programming language, you can
get lists using –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="k">...</span><span class="w"> </span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">sentinel</span><span class="p">)))</span><span class="w"> </span><span class="k">...</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>where we use a <code class="code highlight racket docutils literal highlight-racket"><span class="n">sentinel</span><span class="w"></span></code> to indicate end of the list. You can also make
trees using nested structures like –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">f</span><span class="p">)))</span><span class="w"></span>
</pre></div>
</div>
<p>Or tables as a list of lists. Or even graphs. So if we can show we can
represent pairs using just <code class="code highlight racket docutils literal highlight-racket"><span class="k">lambda</span><span class="w"></span></code>, we’re good with the other structures.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">...</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>What should we put within the <code class="code highlight racket docutils literal highlight-racket"><span class="k">...</span><span class="w"></span></code>? In fact, what <strong>can</strong> we put in there
when all we have are functions (i.e. lambda expressions)? So we’re now
looking at –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="k">...</span><span class="p">)))</span><span class="w"></span>
</pre></div>
</div>
<p>Again, what can we put in there? We have a <code class="code highlight racket docutils literal highlight-racket"><span class="n">p</span><span class="w"></span></code> and some two arbitrary values
<code class="code highlight racket docutils literal highlight-racket"><span class="n">x</span><span class="w"></span></code> and <code class="code highlight racket docutils literal highlight-racket"><span class="n">y</span><span class="w"></span></code> that we’re expected to “store” in the pair. About the only
thing we can do (apart from nesting lambda once more, which would seem
pointless) is to apply <code class="code highlight racket docutils literal highlight-racket"><span class="n">p</span><span class="w"></span></code> to the <code class="code highlight racket docutils literal highlight-racket"><span class="n">x</span><span class="w"></span></code> and <code class="code highlight racket docutils literal highlight-racket"><span class="n">y</span><span class="w"></span></code>.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))))</span><span class="w"></span>
</pre></div>
</div>
<p>We can now make “pairs” like below –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">100</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>(taking the liberty to use numbers just to illustrate). Since <code class="code highlight racket docutils literal highlight-racket"><span class="n">p1</span><span class="w"></span></code> is a function
that takes one argument, the only thing we can do with it is call it. Since its
argument is also a function that’s applied to 2 arguments, let’s consider
some simple 2-argument functions shown below –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">.first</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">.second</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>The functions ignore one of their arguments and just evaluate to the other.
Now what happens when you apply <code class="code highlight racket docutils literal highlight-racket"><span class="n">p1</span><span class="w"></span></code> to these two functions.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">p1</span><span class="w"> </span><span class="n">.first</span><span class="p">)</span><span class="w"></span>
<span class="k">=&gt;</span><span class="w"> </span><span class="p">((</span><span class="n">pair</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="c1">; substitute their definitions</span><span class="w"></span>
<span class="k">=&gt;</span><span class="w"> </span><span class="p">(((</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)))</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"></span>
<span class="c1">; β-reduce the first term</span><span class="w"></span>
<span class="k">=&gt;</span><span class="w"> </span><span class="p">((</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">100</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"></span>
<span class="c1">; β-reduce the expression again</span><span class="w"></span>
<span class="k">=&gt;</span><span class="w"> </span><span class="p">((</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"></span>
<span class="c1">; β-reduce the expression again</span><span class="w"></span>
<span class="k">=&gt;</span><span class="w"> </span><span class="mi">12</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Work it out similarly and show that <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">p1</span><span class="w"> </span><span class="n">.second</span><span class="p">)</span><span class="w"></span></code> results in <code class="code highlight racket docutils literal highlight-racket"><span class="mi">100</span><span class="w"></span></code>.</p>
</div>
<p>So we have a function now named <code class="code highlight racket docutils literal highlight-racket"><span class="n">pair</span><span class="w"></span></code> that can make so-called “pair objects”
and we can get the individual values out of the pair object using the
“accessor” functions <code class="code highlight racket docutils literal highlight-racket"><span class="n">.first</span><span class="w"></span></code> and <code class="code highlight racket docutils literal highlight-racket"><span class="n">.second</span><span class="w"></span></code>.</p>
<p>Many of you are familiar with “object oriented languages” like Python and will
see the reasoning behind naming the accessor functions that way .. since the
expression <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">p1</span><span class="w"> </span><span class="n">.first</span><span class="p">)</span><span class="w"></span></code> looks very similar to <code class="code highlight racket docutils literal highlight-racket"><span class="n">p1.first</span><span class="w"></span></code> typical of such
languages.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The ones with a careful eye might’ve noticed that while we claimed to
only use lambdas, we ended up using <code class="code highlight racket docutils literal highlight-racket"><span class="k">define</span><span class="w"></span></code> in the above definitions. We
use it here only as a substitute for writing the mathematical definitional
equality <span class="math notranslate nohighlight">\(pair = (λ\ (x\ y)\ (λ\ (p)\ (p\ x\ y)))\)</span> and because it
actually permits you to type it into Racket and check things out for
yourself. We therefore lose no generality by using <code class="code highlight racket docutils literal highlight-racket"><span class="k">define</span><span class="w"></span></code> in the above
code. Also, lambda calculus deals only with one-argument functions and we’ve
used two here. However, <span class="math notranslate nohighlight">\((λ\ (x\ y)\ E[x,y])\)</span> can be mechanically
rewritten to <span class="math notranslate nohighlight">\((λ\ (x)\ (λ\ (y)\ E[x,y]))\)</span> with corresponding changes
to substitution steps without loss of logical correctness. So we’ll take
that additional liberty here too.</p>
</div>
</section>
<section id="booleans">
<h3>Booleans<a class="headerlink" href="#booleans" title="Permalink to this heading">¶</a></h3>
<p>From this section on, it will be valuable for us to use the <code class="code highlight racket docutils literal highlight-racket"><span class="kn">#lang </span><span class="nn">lazy</span><span class="w"></span></code>
language instead since we’re going to be doing equational reasoning which will
work only in a lazy scheme and not when using eager evaluation. The syntax and
meaning are generally the same, except that the values of expressions will be
computed only when they are needed and not before.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>The only place we use boolean values is to do a branch within an <code class="code highlight racket docutils literal highlight-racket"><span class="k">if</span><span class="w"></span></code>
condition. So if we can implement <code class="code highlight racket docutils literal highlight-racket"><span class="k">if</span><span class="w"></span></code> purely using <code class="code highlight racket docutils literal highlight-racket"><span class="k">lambda</span><span class="w"></span></code>, we’re
good. For this exercise, you’ll need to consider “lazy evaluation” instead
of “eager evaluation” to keep things simple. In fact, for the rest of this
demonstration, we’ll use lazy evaluation with <code class="code highlight racket docutils literal highlight-racket"><span class="kn">#lang </span><span class="nn">lazy</span><span class="w"></span></code>. The earlier
ones will also work with <code class="code highlight racket docutils literal highlight-racket"><span class="kn">#lang </span><span class="nn">lazy</span><span class="w"></span></code>. So complete the definition below –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">IF</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">bool</span><span class="w"> </span><span class="n">then-expr</span><span class="w"> </span><span class="n">else-expr</span><span class="p">)</span><span class="w"> </span><span class="n">....</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>Remember the trick we used with <code class="code highlight racket docutils literal highlight-racket"><span class="n">pair</span><span class="w"></span></code>. You have all you need in that
code.</p>
</div>
</section>
<section id="let">
<h3><code class="docutils literal notranslate"><span class="pre">let</span></code><a class="headerlink" href="#let" title="Permalink to this heading">¶</a></h3>
<p>It is quite easy to see that we can rewrite <code class="code highlight racket docutils literal highlight-racket"><span class="k">let</span><span class="w"></span></code> expressions using <code class="code highlight racket docutils literal highlight-racket"><span class="k">lambda</span><span class="w"></span></code>.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">var1</span><span class="w"> </span><span class="n">expr1</span><span class="p">]</span><span class="w"></span>
<span class="w">      </span><span class="p">[</span><span class="n">var2</span><span class="w"> </span><span class="n">expr2</span><span class="p">]</span><span class="w"></span>
<span class="w">      </span><span class="k">...</span><span class="w"></span>
<span class="w">      </span><span class="p">[</span><span class="n">varn</span><span class="w"> </span><span class="n">exprn</span><span class="p">])</span><span class="w"></span>
<span class="w">  </span><span class="n">&lt;body-using-var1..n&gt;</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Can be rewritten as –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">((</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">var1</span><span class="w"> </span><span class="n">var2</span><span class="w"> </span><span class="k">...</span><span class="w"> </span><span class="n">varn</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">&lt;body-using-var1..n&gt;</span><span class="p">)</span><span class="w"></span>
<span class="w"> </span><span class="n">expr1</span><span class="w"> </span><span class="n">expr2</span><span class="w"> </span><span class="k">...</span><span class="w"> </span><span class="n">exprn</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>So <code class="code highlight racket docutils literal highlight-racket"><span class="k">let</span><span class="w"></span></code> is just “syntactic sugar” on top of lambda - i.e. is for our
convenience without offering additional “expressive power”. These notions will
become clearer (and more formal) as we go along. For now, if you have a sense
of what they are, that’s sufficient.</p>
</section>
<section id="numbers">
<h3>Numbers<a class="headerlink" href="#numbers" title="Permalink to this heading">¶</a></h3>
<p>Numbers are a big one to claim to be representable using <code class="code highlight racket docutils literal highlight-racket"><span class="k">lambda</span><span class="w"></span></code> alone!
Numbers (i.e. basic arithmetic with whole numbers) hold a “threshold” place in
mathematical logic too – that every “formal system” <a class="footnote-reference brackets" href="#fs" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> is representable
using numbers.</p>
<aside class="footnote brackets" id="fs" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>A “formal system” is a collection of postulates – i.e. “theorems” that
are assumed to be true – that serve as a starting point, and a collection
of rules that tell us how to derive new theorems from other known theorems.</p>
</aside>
<p>In lambda calculus, all we have are functions and function application. What can
we apply functions to? The answer to that question is also “functions”! So how
can we capture the idea of natural numbers using functions alone?</p>
<p>Given a function, what can we do with it? We can apply it to some value. What
kind of a value can we apply it to (at least within lambda calculus)? We can
apply it to another function. So Alonzo Church came up with a representation
for numbers as the idea of applying a function a certain number of times.</p>
<p>If we consider applying a function <code class="code highlight racket docutils literal highlight-racket"><span class="n">f</span><span class="w"></span></code> to a value <code class="code highlight racket docutils literal highlight-racket"><span class="n">x</span><span class="w"></span></code> a number
of times, we could write that sequence as –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w">                     </span><span class="c1">; 0</span><span class="w"></span>
<span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">                 </span><span class="c1">; 1</span><span class="w"></span>
<span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">             </span><span class="c1">; 2</span><span class="w"></span>
<span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span><span class="w">         </span><span class="c1">; 3</span><span class="w"></span>
<span class="c1">;... and so on</span><span class="w"></span>
</pre></div>
</div>
<p>But we don’t know what these <code class="code highlight racket docutils literal highlight-racket"><span class="n">f</span><span class="w"></span></code> and <code class="code highlight racket docutils literal highlight-racket"><span class="n">x</span><span class="w"></span></code> are. The only thing we know
about them is that the function <code class="code highlight racket docutils literal highlight-racket"><span class="n">f</span><span class="w"></span></code> must have the property that its domain
and co-domain are the same. The nice thing here is that you can “β-abstraction”
on the two in order to postpone the problem of what values we want them to take
on. So instead of the above, we can consider the sequence below as a
representation of numbers –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">               </span><span class="c1">; 0</span><span class="w"></span>
<span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span><span class="w">           </span><span class="c1">; 1</span><span class="w"></span>
<span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">))))</span><span class="w">       </span><span class="c1">; 2</span><span class="w"></span>
<span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">)))))</span><span class="w">   </span><span class="c1">; 3</span><span class="w"></span>
<span class="c1">;... and so on</span><span class="w"></span>
</pre></div>
</div>
<p>Observe by reading the lambda expression for each “number” that a Church
numeral <code class="code highlight racket docutils literal highlight-racket"><span class="n">n</span><span class="w"></span></code> stands for the idea of “n applications of f on x” given some
<code class="code highlight racket docutils literal highlight-racket"><span class="n">f</span><span class="w"></span></code> and <code class="code highlight racket docutils literal highlight-racket"><span class="n">x</span><span class="w"></span></code>.</p>
<p>We can’t exhaustively list all such numbers. Even if we could, that wouldn’t
capture the structure inherent in the numbers that’s laid out in Peano’s
axioms -</p>
<ol class="arabic simple">
<li><p>“Zero” is a number</p></li>
<li><p>Every number has a “successor”.</p></li>
</ol>
<p>Let’s now try to apply Peano’s axioms to capture the idea of successorship
for Church numerals.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-zero</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-succ</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="k">...</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>How should we now define <code class="code highlight racket docutils literal highlight-racket"><span class="n">ch-succ</span><span class="w"></span></code>? Before we get there, let’s pull in
some preparatory functions that we encountered before –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))))</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">.first</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">.second</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">swap</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="n">.second</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="n">.first</span><span class="p">))))</span><span class="w"></span>

<span class="c1">; The function composition operation .. as a function</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">comp</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="p">)))))</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Try to define <code class="code highlight racket docutils literal highlight-racket"><span class="n">ch-succ</span><span class="w"></span></code> yourself before reading on, for you have spoilers below.</p>
</div>
<p>Let’s write out in words what the expression <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">ch-succ</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span></code> for some specific
Church numeral <code class="code highlight racket docutils literal highlight-racket"><span class="n">n</span><span class="w"></span></code> is supposed to mean – “n+1 applications of some function f on an x”.
In other words, if we have “n applications of some function f on an x”, we need to apply
f once more on that to get “n+1 applications of some function f on an x”.</p>
<p>To make things concrete, let’s look at the definition for “3” and see if we can
express it in terms of our definition for “2”.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-two</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">)))))</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-three</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">))))))</span><span class="w"></span>

<span class="c1">; See that the expression (f (f x)) is ((ch-two f) x)</span><span class="w"></span>
<span class="c1">; Replacing the inner most (f (f x)) in ch-three with ((ch-two f) x)</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-three</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">((</span><span class="n">ch-two</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">)))))</span><span class="w"></span>
</pre></div>
</div>
<p>It’s not hard to see now that we could do that for any pair of <span class="math notranslate nohighlight">\((n,n+1)\)</span>.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-nplus1</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">((</span><span class="n">ch-n</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">)))))</span><span class="w"></span>
</pre></div>
</div>
<p>What we want for our <code class="code highlight racket docutils literal highlight-racket"><span class="n">ch-succ</span><span class="w"></span></code> function is for the relation “<code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">ch-succ</span><span class="w"> </span><span class="n">ch-n</span><span class="p">)</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">ch-nplus1</span><span class="w"></span></code>
to hold. So if we β-abstract over <code class="code highlight racket docutils literal highlight-racket"><span class="n">ch-n</span><span class="w"></span></code>, we get –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-nplus1</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">)))))</span><span class="w"> </span><span class="n">ch-n</span><span class="p">))</span><span class="w"></span>

<span class="c1">; Then due to the equality which we just stated above, we have</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-succ</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">))))))</span><span class="w"></span>

<span class="c1">; We can simplify it further though. Notice that</span><span class="w"></span>
<span class="c1">; (λ (x) (f ((n f) x)))</span><span class="w"></span>
<span class="c1">; is just the function composition of f and (n f).</span><span class="w"></span>
<span class="c1">; i.e. (λ (f) (comp f (n f))) = (λ (f) (λ (x) (f ((n f) x))))</span><span class="w"></span>
<span class="c1">; Therefore we can also write -</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-succ</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">comp</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">f</span><span class="p">)))))</span><span class="w"></span>
</pre></div>
</div>
<p>I hope it is much easier to read the last definition as “n applications of f
followed by one more” (reading the function composition from right-to-left).</p>
<p>We’ll take a break here and define two utility functions outside of
Church’s lambda calculus that will help us make Church numerals and display
them in notation we understand - i.e. as decimal numbers.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;ch</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="n">ch-zero</span><span class="w"></span>
<span class="w">       </span><span class="p">(</span><span class="n">ch-succ</span><span class="w"> </span><span class="p">(</span><span class="n">i-&gt;ch</span><span class="w"> </span><span class="p">(</span><span class="nb">sub1</span><span class="w"> </span><span class="n">i</span><span class="p">)))))</span><span class="w"></span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">ch-&gt;i</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="nb">add1</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>We can now use <code class="code highlight racket docutils literal highlight-racket"><span class="n">i-&gt;ch</span><span class="w"></span></code> to make Church numerals given Scheme numbers and
<code class="code highlight racket docutils literal highlight-racket"><span class="n">ch-&gt;i</span><span class="w"></span></code> to make Scheme numbers given Church numerals.</p>
<p>Ok how about adding two Church numerals? Again, try to figure it out yourself
before reading on.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-add</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="k">...</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>Given an <code class="code highlight racket docutils literal highlight-racket"><span class="n">n</span><span class="w"></span></code> (a Church numeral), we can express the idea of “m+n” as
“m applications of <code class="code highlight racket docutils literal highlight-racket"><span class="n">ch-succ</span><span class="w"></span></code> on n”. This translates easily enough to
a lambda expression like below –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-add</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="n">m</span><span class="w"> </span><span class="n">ch-succ</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="p">)))</span><span class="w"></span>
</pre></div>
</div>
<p>Let’s up the game now. How do we implement multiplication of Church numerals? i.e.
a two argument function <code class="code highlight racket docutils literal highlight-racket"><span class="n">ch-mul</span><span class="w"></span></code> used as <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">ch-mul</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span></code>.</p>
<p>If <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"></span></code> (for a given <code class="code highlight racket docutils literal highlight-racket"><span class="n">f</span><span class="w"></span></code>) yields <code class="code highlight racket docutils literal highlight-racket"><span class="n">n</span><span class="w"></span></code> applications of <code class="code highlight racket docutils literal highlight-racket"><span class="n">f</span><span class="w"></span></code>,
then we need to do this <code class="code highlight racket docutils literal highlight-racket"><span class="n">m</span><span class="w"></span></code> times. That’s an easy enough expression too.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-mul</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">f</span><span class="p">)))))</span><span class="w"></span>
</pre></div>
</div>
<p>However, the inner part of that <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">f</span><span class="p">)))</span><span class="w"></span></code> looks very familiar
doesn’t it? It is simple <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">comp</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span></code>. So we have.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-mul</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">comp</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="p">)))</span><span class="w"></span>
</pre></div>
</div>
<p>Or to put it even more simply, <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-mul</span><span class="w"> </span><span class="n">comp</span><span class="p">)</span><span class="w"></span></code>!! i.e. the multiplication
operation for Church numerals is simply the function composition operation!</p>
<p>I’ve been avoiding a problem so far though – how would we do subtraction? To
do that, we’ll need to implement <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">ch-pred</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span></code> which behaves such that
<code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">ch-succ</span><span class="w"> </span><span class="p">(</span><span class="n">ch-pred</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"></span></code>. Since we don’t have the capability to check
for equality yet, we cannot search the natural numbers starting from
<code class="code highlight racket docutils literal highlight-racket"><span class="n">ch-zero</span><span class="w"></span></code> and work our way upwards until we find a value <code class="code highlight racket docutils literal highlight-racket"><span class="n">k</span><span class="w"></span></code> such
that <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">ch-succ</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"></span></code>. We also don’t know how to compute the “inverse of
a given function <code class="code highlight racket docutils literal highlight-racket"><span class="n">f</span><span class="w"></span></code>” in the general case, so we can apply the inverse
after <code class="code highlight racket docutils literal highlight-racket"><span class="n">n</span><span class="w"></span></code> applications.</p>
<p>This problem apparently stumped Church too. However, his student Stephen Kleene
came up with a solution to it. His solution was to use pairs of Church numerals
in a particular sequence - the first number in the sequence is <span class="math notranslate nohighlight">\((0,0)\)</span>
and if an entry is <span class="math notranslate nohighlight">\((m,n)\)</span>, the next entry in the sequence is <span class="math notranslate nohighlight">\((n,n+1)\)</span>.
This gives us the following sequence –</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>   <span class="p">;</span> <span class="mi">0</span>
<span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>   <span class="p">;</span> <span class="mi">1</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>   <span class="p">;</span> <span class="mi">2</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>   <span class="p">;</span> <span class="mi">3</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>   <span class="p">;</span> <span class="mi">4</span>
<span class="o">...</span>
</pre></div>
</div>
<p>In the above sequence, the first value of the pair gives the predecessor of
the second value which is the same as the row number. The only irksome bit
in this that we have to put up with is that we have to assume that “the
predecessor of 0 is 0”.</p>
<p>So if we define <code class="code highlight racket docutils literal highlight-racket"><span class="n">k-zero</span><span class="w"></span></code> as <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">k-zero</span><span class="w"> </span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="n">ch-zero</span><span class="w"> </span><span class="n">ch-zero</span><span class="p">))</span><span class="w"></span></code>
and <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">k-succ</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">kp</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="p">(</span><span class="n">kp</span><span class="w"> </span><span class="n">.second</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">ch-succ</span><span class="w"> </span><span class="p">(</span><span class="n">kp</span><span class="w"> </span><span class="n">.second</span><span class="p">)))))</span><span class="w"></span></code>,
we can produce the sequence through repeated applications of <code class="code highlight racket docutils literal highlight-racket"><span class="n">k-succ</span><span class="w"></span></code>
on <code class="code highlight racket docutils literal highlight-racket"><span class="n">k-zero</span><span class="w"></span></code>. That’s a concept we already understand. So to produce
the row corresponding to number <code class="code highlight racket docutils literal highlight-racket"><span class="n">n</span><span class="w"></span></code>, we need to do <code class="code highlight racket docutils literal highlight-racket"><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="n">k-succ</span><span class="p">)</span><span class="w"> </span><span class="n">k-zero</span><span class="p">)</span><span class="w"></span></code>.
Thereafter, all that remains is to pick the first value of the pair to get the
predecessor of <code class="code highlight racket docutils literal highlight-racket"><span class="n">n</span><span class="w"></span></code>. So …</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">k-zero</span><span class="w"> </span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="n">ch-zero</span><span class="w"> </span><span class="n">ch-zero</span><span class="p">))</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">k-succ</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">kp</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="p">(</span><span class="n">kp</span><span class="w"> </span><span class="n">.second</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">ch-succ</span><span class="w"> </span><span class="p">(</span><span class="n">kp</span><span class="w"> </span><span class="n">.second</span><span class="p">)))))</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ch-pred</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(((</span><span class="n">n</span><span class="w"> </span><span class="n">k-succ</span><span class="p">)</span><span class="w"> </span><span class="n">k-zero</span><span class="p">)</span><span class="w"> </span><span class="n">.first</span><span class="p">)))</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise:</strong></p>
<p>Define <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">ch-sub</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span></code> for <span class="math notranslate nohighlight">\(m &gt;= n\)</span> using <code class="code highlight racket docutils literal highlight-racket"><span class="n">ch-pred</span><span class="w"></span></code>.</p>
</div>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise:</strong></p>
<p>Can you come up with a representation for integers? – i.e. numbers
that can be positive or negative or zero. You’ll also have to implement
the corresponding addition, subtraction, multiplication and division
operators. You can throw in a “negation” too.</p>
</div>
</section>
</section>
<section id="interlude-on-abstraction">
<h2>Interlude on β-abstraction<a class="headerlink" href="#interlude-on-abstraction" title="Permalink to this heading">¶</a></h2>
<p>You’ve seen above how useful β-abstraction turns out to be when exploring
representations that we do not initially fully understand. We were able to
postpone specific choices of functions until we understood things better, we
could transform expressions to extract common patterns, etc. As mentioned
earlier, all abstractions boil down to β-abstractions at the end. This means
you can use β-abstraction to great effect when when working with domains that
you’re just about beginning to understand. That’s useful even if you are not
using a functional programming language, because once you construct those
abstractions, it is usually a mechanical matter to translate them into other
languages that may not be functional. How can we be sure of that? That’s what
this whole section is about – that <code class="code highlight racket docutils literal highlight-racket"><span class="k">lambda</span><span class="w"></span></code> is enough to represent all of
computation, so any general purpose language (i.e. “Turing complete language”)
can be understood in terms of it.</p>
<p>The key to exploiting β-abstraction is practice.</p>
</section>
<section id="recursion">
<h2>Recursion<a class="headerlink" href="#recursion" title="Permalink to this heading">¶</a></h2>
<p>Recursion underlies all repetition in Scheme – in the sense that you can
express any looping construct using recursion. However, we have a problem
at this point. We typically define a recursive function such as <code class="code highlight racket docutils literal highlight-racket"><span class="n">sqrt/rec</span><span class="w"></span></code>
using <code class="code highlight racket docutils literal highlight-racket"><span class="k">define</span><span class="w"></span></code> like this –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">sqrt/rec</span><span class="w"></span>
<span class="w">   </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">xk</span><span class="w"> </span><span class="n">eps</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="p">(</span><span class="nb">abs</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">xk</span><span class="w"> </span><span class="n">xk</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="n">eps</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">xk</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="n">sqrt/rec</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">xk</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">xk</span><span class="p">)))</span><span class="w"> </span><span class="n">eps</span><span class="p">))))</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We’ll use the <code class="code highlight racket docutils literal highlight-racket"><span class="n">sqrt/rec</span><span class="w"></span></code> function to illustrate, but whatever
we’re doing with that we can also do to any other recursive function
definition you may want to solve. I picked this ‘cos I gave this function
to you to practice recursion.</p>
</div>
<p>Scheme works with this definition just fine, but that’s because it already provides
a mechanism for you to assume the existence of the inner <code class="code highlight racket docutils literal highlight-racket"><span class="n">sqrt/rec</span><span class="w"></span></code> function
when typing to evaluate a particular call. Somehow, the repeated unfolding of the
code is avoided by using names to tie the function’s structure to itself. We <strong>don’t</strong>
have that concept in lambda calculus and so will need to show that we can do this
without such a naming+delayed-binding trick.</p>
<p>So, for our purposes, we do not know what function to use to effect the recursive
call within the body of the above <code class="code highlight racket docutils literal highlight-racket"><span class="n">sqrt/rec</span><span class="w"></span></code> definition.</p>
<p>By now, you should’ve already guessed what we’re going to do when we’re faced
with an unknown like this. Yup - we’ll β-abstract over <code class="code highlight racket docutils literal highlight-racket"><span class="n">sqrt/rec</span><span class="w"></span></code>!</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">cheat</span><span class="w"></span>
<span class="w">   </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">xk</span><span class="w"> </span><span class="n">eps</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="p">(</span><span class="nb">abs</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">xk</span><span class="w"> </span><span class="n">xk</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="n">eps</span><span class="p">)</span><span class="w"></span>
<span class="w">             </span><span class="n">xk</span><span class="w"></span>
<span class="w">             </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">xk</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">xk</span><span class="p">)))</span><span class="w"> </span><span class="n">eps</span><span class="p">)))))</span><span class="w"></span>
</pre></div>
</div>
<p>Now, we can see how <span class="math notranslate nohighlight">\(\text{sqrt/rec} = (\text{cheat}\ \text{sqrt/rec})\)</span>,
provided we know <code class="code highlight racket docutils literal highlight-racket"><span class="n">sqrt/rec</span><span class="w"></span></code> already (hence the name “cheat”). To find
out <code class="code highlight racket docutils literal highlight-racket"><span class="n">sqrt/rec</span><span class="w"></span></code> given <code class="code highlight racket docutils literal highlight-racket"><span class="n">cheat</span><span class="w"></span></code>, we need to “solve” the above equation.
Because applying <code class="code highlight racket docutils literal highlight-racket"><span class="n">cheat</span><span class="w"></span></code> to <code class="code highlight racket docutils literal highlight-racket"><span class="n">sqrt/rec</span><span class="w"></span></code> produces the same function,
<code class="code highlight racket docutils literal highlight-racket"><span class="n">sqrt/rec</span><span class="w"></span></code> is called the “fixed point” of <code class="code highlight racket docutils literal highlight-racket"><span class="n">cheat</span><span class="w"></span></code>. In mathematics,
a fixed point of a function <span class="math notranslate nohighlight">\(f(x)\)</span> is a value <span class="math notranslate nohighlight">\(x\)</span> such that
<span class="math notranslate nohighlight">\(x = f(x)\)</span>.</p>
<p>However, our <code class="code highlight racket docutils literal highlight-racket"><span class="n">cheat</span><span class="w"></span></code> function is not of much use though it captures the
essentials of the algorithm. We called it “cheat” because to get the
<code class="code highlight racket docutils literal highlight-racket"><span class="n">sqrt/rec</span><span class="w"></span></code> function from it, you have to pass it to it in the first place,
which seems to defeat the point. What we really want is for the whole machinery
of the <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">xk</span><span class="w"> </span><span class="n">eps</span><span class="p">)</span><span class="w"> </span><span class="k">...</span><span class="p">)</span><span class="w"></span></code> part of <code class="code highlight racket docutils literal highlight-racket"><span class="n">cheat</span><span class="w"></span></code> to be available in place
of <code class="code highlight racket docutils literal highlight-racket"><span class="n">f</span><span class="w"></span></code> when we’re calling it. Since <code class="code highlight racket docutils literal highlight-racket"><span class="n">cheat</span><span class="w"></span></code> is fully defined (we do
not refer to it recursively), what if we could just pass it to itself as an
argument (bound to <code class="code highlight racket docutils literal highlight-racket"><span class="n">f</span><span class="w"></span></code>)?</p>
<p>Another way to ask that question is “what if we just had an extra argument to
<code class="code highlight racket docutils literal highlight-racket"><span class="nb">sqrt</span><span class="w"></span></code> function and we just passed <code class="code highlight racket docutils literal highlight-racket"><span class="nb">sqrt</span><span class="w"></span></code> itself in its place – like
this –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">sqrt/norec</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">xk</span><span class="w"> </span><span class="n">eps</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="p">(</span><span class="nb">abs</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">xk</span><span class="w"> </span><span class="n">xk</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="n">eps</span><span class="p">)</span><span class="w"></span>
<span class="w">           </span><span class="n">xk</span><span class="w"></span>
<span class="w">           </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">xk</span><span class="w"> </span><span class="n">eps</span><span class="p">))))</span><span class="w"></span>
</pre></div>
</div>
<p>So you can calculate square-roots using <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">sqrt/norec</span><span class="w"> </span><span class="n">sqrt/norec</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="mi">64</span><span class="w"></span>
<span class="mf">0.1</span><span class="p">)</span><span class="w"></span></code>. This actually lets us do recursive function calls without using a
recursive definition! However, it is somewhat awkward to pass this additional
argument all the time. Let’s see how we can improve it. First, we can
lift that <code class="code highlight racket docutils literal highlight-racket"><span class="n">f</span><span class="w"></span></code> argument out so we can “Curry” it like this –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">good</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">xk</span><span class="w"> </span><span class="n">eps</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="p">(</span><span class="nb">abs</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">xk</span><span class="w"> </span><span class="n">xk</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="n">eps</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="n">xk</span><span class="w"></span>
<span class="w">              </span><span class="p">((</span><span class="n">f</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">xk</span><span class="w"> </span><span class="n">eps</span><span class="p">)))))</span><span class="w"></span>
</pre></div>
</div>
<p>… and we can now do our square-root algorithm using <code class="code highlight racket docutils literal highlight-racket"><span class="n">good</span><span class="w"></span></code>
like this –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">((</span><span class="n">good</span><span class="w"> </span><span class="n">good</span><span class="p">)</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="mf">0.1</span><span class="p">)</span><span class="w"></span>
<span class="c1">; Prints out 8.005147977880979</span><span class="w"></span>
<span class="c1">; which is an approximate square root indeed.</span><span class="w"></span>
</pre></div>
</div>
<p>Now, you see that <code class="code highlight racket docutils literal highlight-racket"><span class="n">sqrt/rec</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="n">good</span><span class="w"> </span><span class="n">good</span><span class="p">)</span><span class="w"></span></code> .. which is … good as we have
an explicit function that behaves exactly as our original recursive definition
… without any extra arguments.</p>
<p>To summarize, we’ve now figured out a trick by which we can turn a recursively
defined function into one that isn’t recursive but can effectively accomplish
the same result.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">some-function/rec</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="k">...</span><span class="w"> </span><span class="p">(</span><span class="n">some-function/rec</span><span class="w"> </span><span class="n">next-arg</span><span class="p">)</span><span class="w"> </span><span class="k">...</span><span class="p">))</span><span class="w"></span>
<span class="c1">; can be transformed into</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">some-function/norec</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="k">...</span><span class="w"> </span><span class="p">((</span><span class="n">f</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">next-arg</span><span class="p">)</span><span class="w"> </span><span class="k">...</span><span class="p">)))</span><span class="w"></span>
<span class="c1">; .. so that some-function/rec can now be defined in terms of</span><span class="w"></span>
<span class="c1">; some-function/norec as --</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">some-function/rec</span><span class="w"> </span><span class="p">(</span><span class="n">some-function/norec</span><span class="w"> </span><span class="n">some-function/norec</span><span class="p">))</span><span class="w"></span>

<span class="c1">; Note that the number of sites at which the recursive call happens</span><span class="w"></span>
<span class="c1">; does not matter. We replace all of them with (f f).</span><span class="w"></span>
</pre></div>
</div>
<section id="the-journey-isn-t-finished-yet">
<h3>The journey isn’t finished yet<a class="headerlink" href="#the-journey-isn-t-finished-yet" title="Permalink to this heading">¶</a></h3>
<p>We’ve now shown that you can express recursive calls using <code class="code highlight racket docutils literal highlight-racket"><span class="k">lambda</span><span class="w"></span></code> alone.
Mission accomplished! However, don’t forget our larger claim that anything
computable can be expressed using <code class="code highlight racket docutils literal highlight-racket"><span class="k">lambda</span><span class="w"></span></code>. In this case, what we just saw
is how we can start with a recursively defined function (given as a spec
similar to <code class="code highlight racket docutils literal highlight-racket"><span class="n">cheat</span><span class="w"></span></code>) and <strong>mechanically</strong> transform it into the true
recursive function. If we’ve truly “mechanized” it, then we should be able to
express that transformation as a function, right?</p>
<p>Though we called our original funciton “cheat”, we’re being a bit unfair to it,
because it serves as a specification for how the recursion is to proceed. It
captures all the details of the algorithm we intended to write down, except for
exactly which function to use to recurse. Furthermore, our desired
<code class="code highlight racket docutils literal highlight-racket"><span class="n">sqrt/rec</span><span class="w"></span></code> is a fixed point of this function, which is simple enough to
write. So we can now ask – “If I give you such a <code class="code highlight racket docutils literal highlight-racket"><span class="n">cheat</span><span class="w"></span></code> function, can
you <strong>calculate</strong> <code class="code highlight racket docutils literal highlight-racket"><span class="n">sqrt/rec</span><span class="w"></span></code> mechanically?”</p>
<p>We can also see that <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">good</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">f</span><span class="p">))</span><span class="w"></span></code> through simple β-reduction.
In fact, we got <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">good</span><span class="w"> </span><span class="n">good</span><span class="p">)</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="w"> </span><span class="p">(</span><span class="n">good</span><span class="w"> </span><span class="n">good</span><span class="p">))</span><span class="w"></span></code> from that in the
first place.</p>
<p>We can now rewrite that way of stating <code class="code highlight racket docutils literal highlight-racket"><span class="n">good</span><span class="w"></span></code> as –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">good</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">f</span><span class="p">))))</span><span class="w"></span>
</pre></div>
</div>
<p>And we can now express our desired <code class="code highlight racket docutils literal highlight-racket"><span class="n">sqrt/rec</span><span class="w"></span></code> function as just –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">sqrt/rec</span><span class="w"> </span><span class="p">(</span><span class="n">good</span><span class="w"> </span><span class="n">good</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>If we then β-abstract on <code class="code highlight racket docutils literal highlight-racket"><span class="n">good</span><span class="w"></span></code>, we get –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">sqrt/rec</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">f</span><span class="p">))</span><span class="w"> </span><span class="n">good</span><span class="p">))</span><span class="w"></span>
<span class="c1">; =&gt;</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">sqrt/rec</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">f</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">g</span><span class="p">)))))</span><span class="w"></span>
<span class="c1">; =&gt; β-abstract on &quot;cheat&quot; =&gt;</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">sqrt/rec</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">f</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">g</span><span class="p">)))))</span><span class="w"> </span><span class="n">cheat</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>So, we actually now have a function that we can apply to our easy-to-define
“spec” function in order to get our recursive result! This function that we’ve
figured out above is called the “Y combinator”.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">f</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">g</span><span class="p">))))))</span><span class="w"></span>
</pre></div>
</div>
<p>(We’re using <code class="code highlight racket docutils literal highlight-racket"><span class="n">s</span><span class="w"></span></code> as the variable name to suggest “spec function” for
<code class="code highlight racket docutils literal highlight-racket"><span class="n">cheat</span><span class="w"></span></code>.)</p>
<p>A way the Y combinator is usually presented is with one β-reduction applied
which gives us a nice symmetric form –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">g</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">g</span><span class="p">))))))</span><span class="w"></span>
</pre></div>
</div>
<p>And we have <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">Y</span><span class="w"> </span><span class="n">cheat</span><span class="p">)</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="w"> </span><span class="p">(</span><span class="n">Y</span><span class="w"> </span><span class="n">cheat</span><span class="p">))</span><span class="w"></span></code>. This is why the Y combinator
is said to be a “fixed point combinator” because it calculates the fixed point
of the given function. So all you have to do now is to express your recursive
function using an “unknown <code class="code highlight racket docutils literal highlight-racket"><span class="n">f</span><span class="w"></span></code>” and then have the Y-combinator figure out
what <code class="code highlight racket docutils literal highlight-racket"><span class="n">f</span><span class="w"></span></code> to pass to it.</p>
</section>
<section id="can-we-just-solve-for-the-combinator">
<h3>Can we just solve for the combinator?<a class="headerlink" href="#can-we-just-solve-for-the-combinator" title="Permalink to this heading">¶</a></h3>
<p>While we originally tried to solve for <code class="code highlight racket docutils literal highlight-racket"><span class="n">sqrt/rec</span><span class="w"></span></code> given the equation
<code class="code highlight racket docutils literal highlight-racket"><span class="n">sqrt/rec</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="w"> </span><span class="n">sqrt/rec</span><span class="p">)</span><span class="w"></span></code>, we turned the problem into finding a
function of <code class="code highlight racket docutils literal highlight-racket"><span class="n">cheat</span><span class="w"></span></code> that can produce <code class="code highlight racket docutils literal highlight-racket"><span class="n">sqrt/rec</span><span class="w"></span></code>. i.e. we were
actually looking for a function <code class="code highlight racket docutils literal highlight-racket"><span class="n">F</span><span class="w"></span></code> such that -</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">F</span><span class="w"> </span><span class="n">cheat</span><span class="p">)</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="w"> </span><span class="p">(</span><span class="n">F</span><span class="w"> </span><span class="n">cheat</span><span class="p">))</span><span class="w"></span>
<span class="c1">; i.e.</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="w"> </span><span class="p">(</span><span class="n">F</span><span class="w"> </span><span class="n">cheat</span><span class="p">))))</span><span class="w"></span>
</pre></div>
</div>
<p>Now we have a recursive “solution” for <code class="code highlight racket docutils literal highlight-racket"><span class="n">F</span><span class="w"></span></code>. If we now apply the same
technique/trick that we used to turn <code class="code highlight racket docutils literal highlight-racket"><span class="n">cheat</span><span class="w"></span></code> into a non-recursive function
<code class="code highlight racket docutils literal highlight-racket"><span class="n">good</span><span class="w"></span></code>, we have –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">G</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">cheat</span><span class="w"> </span><span class="p">((</span><span class="n">f</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">cheat</span><span class="p">)))))</span><span class="w"></span>
<span class="c1">; and</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="p">(</span><span class="n">G</span><span class="w"> </span><span class="n">G</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>Now, let’s look at the full expression for <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">G</span><span class="w"> </span><span class="n">G</span><span class="p">)</span><span class="w"></span></code> with less judgemental
variable names –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="p">((</span><span class="n">f</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">s</span><span class="p">))))</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="p">((</span><span class="n">f</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">s</span><span class="p">))))))</span><span class="w"></span>
</pre></div>
</div>
<p>(We’re again using the variable named <code class="code highlight racket docutils literal highlight-racket"><span class="n">s</span><span class="w"></span></code> to denote the “spec function”
<code class="code highlight racket docutils literal highlight-racket"><span class="n">cheat</span><span class="w"></span></code>.)</p>
<p>This looks like a different function compared to <code class="code highlight racket docutils literal highlight-racket"><span class="n">Y</span><span class="w"></span></code> we figured out
earlier that also has the property <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">F</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="n">F</span><span class="w"> </span><span class="n">s</span><span class="p">))</span><span class="w"></span></code> just like <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">Y</span><span class="w"></span>
<span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="n">Y</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"></span></code>. The difference between the two is this – since we only used
β-abstraction to come up with <code class="code highlight racket docutils literal highlight-racket"><span class="n">F</span><span class="w"></span></code>, we can see how evaluating <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">F</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"></span></code>
simply β-reduces to <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="n">F</span><span class="w"> </span><span class="n">s</span><span class="p">))</span><span class="w"></span></code>, whereas with the <code class="code highlight racket docutils literal highlight-racket"><span class="n">Y</span><span class="w"></span></code> combinator,
<code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">Y</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"></span></code> and <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="n">Y</span><span class="w"> </span><span class="n">s</span><span class="p">))</span><span class="w"></span></code> give us the same expression. <code class="code highlight racket docutils literal highlight-racket"><span class="n">F</span><span class="w"></span></code> is
therefore a valid combinator in its own right and is called the “Turing
combinator”, usually denoted by <span class="math notranslate nohighlight">\(\Theta\)</span>.</p>
</section>
<section id="can-we-not-be-lazy-please">
<h3>Can we not be lazy please?<a class="headerlink" href="#can-we-not-be-lazy-please" title="Permalink to this heading">¶</a></h3>
<p>We’ve so far been using the <code class="code highlight racket docutils literal highlight-racket"><span class="kn">#lang </span><span class="nn">lazy</span><span class="w"></span></code> for all the above work on
recursion. If you want to, you can try to see if the Y combinator as defined
above will work with eager evaluation by switching the language to <code class="code highlight racket docutils literal highlight-racket"><span class="n">#lang</span><span class="w"></span>
<span class="n">racket</span><span class="w"></span></code>. You’ll find that you’ll get a stack overflow as <code class="code highlight racket docutils literal highlight-racket"><span class="n">Y</span><span class="w"></span></code> tries to
repeatedly expand itself without stopping. The benefit of laziness for the
definition of <code class="code highlight racket docutils literal highlight-racket"><span class="n">Y</span><span class="w"></span></code> is that the expansion only happens when it is needed,
i.e. in the part of the spec function that actually makes a recursive call.
When the termination condition is hit, no further expansion of <code class="code highlight racket docutils literal highlight-racket"><span class="n">Y</span><span class="w"></span></code>
is needed and the recursion stops.</p>
<p>We can achieve the same effect in the eager evaluation mode by wrapping the
expansion in another <code class="code highlight racket docutils literal highlight-racket"><span class="k">λ</span><span class="w"></span></code>. To do this, we need to see that <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"></span>
<span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">f</span><span class="w"></span></code> for a function <code class="code highlight racket docutils literal highlight-racket"><span class="n">f</span><span class="w"></span></code> whose expression does not make use of the
outer variable <code class="code highlight racket docutils literal highlight-racket"><span class="n">x</span><span class="w"></span></code> – i.e. it does not contain <code class="code highlight racket docutils literal highlight-racket"><span class="n">x</span><span class="w"></span></code> as a “free
variable”, with “free” meaning “unbound”.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The transformation <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"></span></code> when <code class="code highlight racket docutils literal highlight-racket"><span class="n">f</span><span class="w"></span></code> does not
contain <code class="code highlight racket docutils literal highlight-racket"><span class="n">x</span><span class="w"></span></code> as a free variable is called η-reduction (“eta-reduction”).
This transformation can be done both ways. I haven’t traced the history of
λ-calculus to figure out why Church chose to call it η-reduction and not
γ-reduction as one might expect to follow β-reduction. I’d like to think he
tried many intermediate rules to complete the λ-calculus until he finally
settled on the one he named η-reduction. At least, that fictitious
explanation would capture the labour necessary for mathematical insight.</p>
</div>
<p>We apply this transformation to the inner <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"></span></code> call, turning it into
<code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="n">g</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="n">v</span><span class="p">))</span><span class="w"></span></code>. We can now rewrite the Y combinator as –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">f</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="n">g</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="n">v</span><span class="p">)))))))</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise:</strong></p>
<p>Check out whether this way of specifying the Y combinator works
in eager mode. Do you understand why?</p>
</div>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Comp308: Principles of Programming Languages</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="racket-intro.html">A quick introduction to Racket and Scheme</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Lambda - the everything</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#so-what-s-lambda">So what’s <code class="code highlight racket docutils literal highlight-racket"><span class="k">lambda</span><span class="w"></span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tall-claims-need-taller-evidence">Tall claims need taller evidence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interlude-on-abstraction">Interlude on β-abstraction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#recursion">Recursion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="piclang.html">A language for pictures</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine.html">A mental model for the machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="growing.html">Growing the language</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="racket-intro.html" title="previous chapter">A quick introduction to Racket and Scheme</a></li>
      <li>Next: <a href="piclang.html" title="next chapter">A language for pictures</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Srikumar K. S..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/lambda.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>