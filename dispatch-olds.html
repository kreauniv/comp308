<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Polymorphism via dispatch &#8212; Comp308: Principles of Programming Languages v1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=3d3fbe02" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=12dfc556" />
    <script src="_static/documentation_options.js?v=5cb08e4e"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="polymorphism-via-dispatch">
<h1>Polymorphism via dispatch<a class="headerlink" href="#polymorphism-via-dispatch" title="Link to this heading">¶</a></h1>
<p>(CURRENTLY INCOMPLETE)</p>
<p>Note: This section is expected to supercede the discussion on <a class="reference internal" href="objects.html"><span class="doc">Objects</span></a>.</p>
<p>When writing our procedures/functions in a programming language, we deal with
different data structures and entities such as files, network sockets and
processes. For any given system, a number of such entities serves as its “API”
or “Application Programming Interface”. If each of these entities were to be
transacted with using its own vocabulary, it will become very hard for
programmers to retain the vocabularies necessary to work with a practical
subset of these entity types in working memory so they act of programming is
both efficient and reliable.</p>
<p>Thankfully, many of these entities can be worked with using a much smaller set
of “verbs” using which programmers typically chunk their thinking about them.
For example, both hash-tables and vectors in Racket offer the notion of
associating a value with a key. Only, in the case of hash-tables, the key can be
anything “hashable” whereas in the case of a vector, the key must be in the
range <span class="math notranslate nohighlight">\([0,N)\)</span>. However, the act of getting a value associated with a
particular key can simply be thought of across all such data structures using
the verb “get” and similarly the setting of a value against a particular key can
be thought of using the verb “set”.</p>
<p>For an analogy, consider the Harry Potter world and Hermione Granger’s timely
use of the spell “Alohamora” to open a lock. Suppose that in the wizarding
world, each kind of lock required a different spell to be learnt to open it –
“Alohamora Big One”, “Alohamora 42”, “Alohamora Locksmith &amp; Sons Tiny 2021
edition” and so on – wizards might give up pretty soon. But we have a hint
here – that the word “Alohamora” suggests that the lock needs to be opened,
and the ones programming these locks can determine what to do when the lock
hears the spell “Alohamora”, instead of making custom spells for it. This would
then obviously be preferrable for wizards (and students!) since they would then
need to remember far fewer spells overall to be effective in their world.</p>
<p>Racket library functions kind of work as though they were in that complicated
world of spells. In Racket, though you’ll find procedures named according to
such common vocabulary, each data structure carries its own set of procedures
to work with it. So vectors come with <code class="docutils literal notranslate"><span class="pre">vector-ref</span></code> and <code class="docutils literal notranslate"><span class="pre">vector-set!</span></code> and
<code class="docutils literal notranslate"><span class="pre">vector-length</span></code>, and similarly hash-tables have <code class="docutils literal notranslate"><span class="pre">hash-ref</span></code>,
<code class="docutils literal notranslate"><span class="pre">hash-set!</span></code> and <code class="docutils literal notranslate"><span class="pre">hash-count</span></code>. If we were to invent another data
structure, say, <code class="docutils literal notranslate"><span class="pre">treemap</span></code>, then we’ll have to expose yet more procedures
named <code class="docutils literal notranslate"><span class="pre">treemap-ref</span></code>, <code class="docutils literal notranslate"><span class="pre">treemap-set!</span></code> and <code class="docutils literal notranslate"><span class="pre">treemap-length</span></code> that will do
analogous things with tree maps. If we choose completely different vocabularies
– say, <code class="docutils literal notranslate"><span class="pre">treemap-search-and-retrieve</span></code>, <code class="docutils literal notranslate"><span class="pre">treemap-find-and-replace</span></code> and
<code class="docutils literal notranslate"><span class="pre">treemap-count-entries</span></code> – we’d place a huge cognitive burden on programmers
who’d want to adopt our new data structure since they cannot reuse their
vocabulary in the new context.</p>
<p>What if we could simply say <code class="docutils literal notranslate"><span class="pre">ref</span></code>, <code class="docutils literal notranslate"><span class="pre">set!</span></code> and <code class="docutils literal notranslate"><span class="pre">length</span></code> and when we
introduce a new data structure, be able to declare how these verbs should work
with it at that point? That way, if we have a vector <code class="docutils literal notranslate"><span class="pre">v</span></code>, we reference its
<code class="docutils literal notranslate"><span class="pre">k</span></code>-th element using <code class="docutils literal notranslate"><span class="pre">(ref</span> <span class="pre">v</span> <span class="pre">k)</span></code> and if we have a hashtable <code class="docutils literal notranslate"><span class="pre">h</span></code> and a key
<code class="docutils literal notranslate"><span class="pre">k</span></code>, we can get its associated value using <code class="docutils literal notranslate"><span class="pre">(ref</span> <span class="pre">h</span> <span class="pre">k)</span></code> as well, instead of
<code class="docutils literal notranslate"><span class="pre">(hash-ref</span> <span class="pre">h</span> <span class="pre">k)</span></code>. It is quite evident that the cognitive burden is lower for
such a unified concept of “<code class="docutils literal notranslate"><span class="pre">ref</span></code>-ing” a value. This “reuse of verbs” with
different objects is the essence of “polymorphism”.</p>
<p>While doing this makes for concise code while writing, we also notice that when
reading code, <code class="docutils literal notranslate"><span class="pre">(ref</span> <span class="pre">h</span> <span class="pre">k)</span></code> tells us very little about <code class="docutils literal notranslate"><span class="pre">h</span></code> than “something we
can call <code class="docutils literal notranslate"><span class="pre">ref</span></code> on”, whereas <code class="docutils literal notranslate"><span class="pre">(hash-ref</span> <span class="pre">h</span> <span class="pre">k)</span></code> is amply clear. This is part
of the reason for that design choice to be explicit in the Scheme/Racket
languages. The goal of a program is only partly to instruct machines (such as
“locks”) but equally to communicate “how to” knowledge to other humans.</p>
<div class="admonition-terminology admonition">
<p class="admonition-title"><strong>Terminology</strong></p>
<p>Such a multi-purpose definition of a verb like <code class="docutils literal notranslate"><span class="pre">ref</span></code> and <code class="docutils literal notranslate"><span class="pre">set!</span></code> is
referred to in programming languages as “polymorphism” and the verb is said
to be “polymorphic” over a collection of types.</p>
</div>
<section id="exploring-through-property-lists">
<h2>Exploring through “property lists”<a class="headerlink" href="#exploring-through-property-lists" title="Link to this heading">¶</a></h2>
<p>We’ll explore the design space of object oriented programming languages
through a basic structure called a “property list”, which we’ll assume
that our interpreter has access to at any point (i.e. globally).</p>
<p>A property list is a simple structure that asserts connections between
“subjects”, “objects” (not to be confused with “object” in the OOP sense, but
linguistic “object”) via “predicates”. For example, the triple &#64;code{(Tri
child23 ‘mother adult42)} establishes that the &#64;code{‘mother} of
&#64;code{child23} is &#64;code{adult42}. This relationship can be thought of as a
labelled arrow from the child to the adult. This way, arbitrary graphs can be
represented using such a triple store.</p>
<figure class="align-center" id="id3">
<img alt="A node-edge graph illustrating connections between a node representing a child and three nodes representing adults related to the child." src="_images/triple-store.png" />
<figcaption>
<p><span class="caption-text">A triple store can be seen as a graph.</span><a class="headerlink" href="#id3" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>We’ll now model several “object orientedness” ideas based on such a triple
store. Note that this is not to say that such a triple store is what is
backing the various object systems. Far from it. We’re using the plist as a
way to explore the design space and options we have when we’re interested in
minimizing the vocabulary we use to program.</p>
<p>In this chapter, we use the <code class="docutils literal notranslate"><span class="pre">plist.rkt</span></code> module which you can include
using <code class="docutils literal notranslate"><span class="pre">(require</span> <span class="pre">&quot;./plist.rkt&quot;)</span></code> from your own code.</p>
<p>We’ll assume that we’re working with a global plist. Furthermore, we’ll
dispense with implementing it in our language’s interpreter and do it in
plain Racket, since the translation process should now be familiar and
simple to perform.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">require</span><span class="w"> </span><span class="s2">&quot;./plist.rkt&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">plist</span><span class="w"> </span><span class="p">(</span><span class="n">make-plist</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">setprop!</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="n">plist</span><span class="w"> </span><span class="p">(</span><span class="n">plist-assert</span><span class="w"> </span><span class="n">plist</span><span class="w"> </span><span class="n">think</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="n">value</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">key</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="nb">values</span><span class="w"> </span><span class="p">(</span><span class="n">plist-find</span><span class="w"> </span><span class="n">plist</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="no">#f</span><span class="w"> </span><span class="n">Tri-obj</span><span class="p">)])</span>
<span class="w">        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">empty?</span><span class="w"> </span><span class="nb">values</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="k">begin</span><span class="w"> </span><span class="c1">; What do we do here?</span>
<span class="w">                </span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="nb">values</span><span class="p">))))</span>
</pre></div>
</div>
<p>In the above implementation, we’re assuming that the plist only holds
a single value for a given <code class="docutils literal notranslate"><span class="pre">thing-key</span></code> combination. We’ll relax
this condition later. For now, note that this is a design space option
available.</p>
<p>We’re now faced with the problem of determining what to do when
an associated value for a given thing and key is sought for in
the plist and one is not present. We’ll choose a general way to
deal with this by passing a handler function.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">error-on-not-found</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">key</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">key</span><span class="w"> </span><span class="s2">&quot;Property ~s of ~s is not found&quot;</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="n">thing</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="p">[</span><span class="n">not-found-handler</span><span class="w"> </span><span class="n">error-on-not-found</span><span class="p">])</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="nb">values</span><span class="w"> </span><span class="p">(</span><span class="n">plist-find</span><span class="w"> </span><span class="n">plist</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="no">#f</span><span class="w"> </span><span class="n">Tri-obj</span><span class="p">)])</span>
<span class="w">        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">empty?</span><span class="w"> </span><span class="nb">values</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="n">not-found-handler</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">key</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="nb">values</span><span class="p">))))</span>
</pre></div>
</div>
<p>We’ll also define a simple structure to make object references.
We’ll give it an <code class="docutils literal notranslate"><span class="pre">id</span></code> field so when printing out an object, we
know its name. There is no other significance to this <code class="docutils literal notranslate"><span class="pre">id</span></code> field.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="n">Obj</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="kd">#:transparent</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="a-prototype-based-object-system">
<h2>A prototype based object system<a class="headerlink" href="#a-prototype-based-object-system" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Self</span></code> language pioneered the idea of a prototype based object system.
Although historically this came after the class based system introduced by
<code class="docutils literal notranslate"><span class="pre">Smalltalk</span></code> as a response to the problem of prematurely having to determine
an application’s architecture based on “classes” that aren’t necessary known
up front and will be discovered along the way. In other words, the prototype
based system was seen as a way to <strong>evolve</strong> software as requirements come in
during its development. The object system in <code class="docutils literal notranslate"><span class="pre">JavaScript</span></code> is based on these
ideas developed in <code class="docutils literal notranslate"><span class="pre">Self</span></code>.</p>
<p>So, what is an “object” in such a system in the first place?
In such a prototype based system, an object is simply a collection
of named properties and “methods”. A “message” to an object involves
a “message name” (a.k.a. “selector”) and some additional arguments.
When a message is “sent” to an object, it looks up a corresponding
method, which is a procedure and calls the procedure with the given
message arguments. Methods also need to get a reference to the object
as well, so they can access other properties and methods they need.</p>
<p>So we’ll make a simple function to which we can give a list
of keys and values (including method procedures) and get an object
reference that is associated with those properties and methods.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">object</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">kvs</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">obj</span><span class="w"> </span><span class="p">(</span><span class="n">Obj</span><span class="w"> </span><span class="n">id</span><span class="p">)])</span>
<span class="w">        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="n">loop</span><span class="w"> </span><span class="p">([</span><span class="n">kvs</span><span class="w"> </span><span class="n">kvs</span><span class="p">])</span>
<span class="w">            </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">empty?</span><span class="w"> </span><span class="n">kvs</span><span class="p">)</span>
<span class="w">                </span><span class="n">obj</span>
<span class="w">                </span><span class="p">(</span><span class="k">begin</span><span class="w"> </span><span class="p">(</span><span class="n">setprop!</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">kvs</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="n">kvs</span><span class="p">))</span>
<span class="w">                       </span><span class="p">(</span><span class="n">loop</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">kvs</span><span class="p">))))))))</span>
</pre></div>
</div>
<p>With that definition in hand, we can do the following -</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">dog1</span>
<span class="w">    </span><span class="p">(</span><span class="n">object</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">puppy</span>
<span class="w">        </span><span class="o">&#39;</span><span class="ss">color</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">brown</span>
<span class="w">        </span><span class="o">&#39;</span><span class="ss">bark</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">displayln</span><span class="w"> </span><span class="s2">&quot;Yelp!&quot;</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">dog2</span>
<span class="w">    </span><span class="p">(</span><span class="n">object</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">adult</span>
<span class="w">        </span><span class="o">&#39;</span><span class="ss">color</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">black</span>
<span class="w">        </span><span class="o">&#39;</span><span class="ss">bark</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">displayln</span><span class="w"> </span><span class="s2">&quot;Woof Woof!&quot;</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">cat1</span>
<span class="w">    </span><span class="p">(</span><span class="n">object</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">siamese</span>
<span class="w">        </span><span class="o">&#39;</span><span class="ss">color</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">grey</span>
<span class="w">        </span><span class="o">&#39;</span><span class="ss">bark</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
<span class="w">                 </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s2">&quot;I don&#39;t bark! Am I a dog?&quot;</span><span class="p">))))</span>

<span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">cat1</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">color</span><span class="p">)</span>
<span class="o">&#39;</span><span class="ss">grey</span>
<span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">dog2</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">color</span><span class="p">)</span>
<span class="o">&#39;</span><span class="ss">black</span>
</pre></div>
</div>
<p>Now, what does it mean to send an object a message? In our case,
we’re modelling “message passing” as “method invocation”. So we
need to take the message name, look it up in the property list
against the object, and call the function associated. For now,
we’ll leave the “no such method” condition as an error.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">get</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">propname</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">propname</span>
<span class="w">        </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">obj</span><span class="w"> </span><span class="n">propname</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s2">&quot;Placeholder. Property name not found.&quot;</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="k">send</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">method</span><span class="w"> </span><span class="p">(</span><span class="n">get</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">message</span><span class="p">)])</span>
<span class="w">        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">procedure?</span><span class="w"> </span><span class="n">method</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">args</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s2">&quot;Method must be a procedure&quot;</span><span class="p">))))</span>
</pre></div>
</div>
<p>Now we can make our animals make noises -</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">send</span><span class="w"> </span><span class="n">dog1</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">bark</span><span class="p">)</span>
<span class="n">Yelp!</span>
<span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">send</span><span class="w"> </span><span class="n">dog2</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">bark</span><span class="p">)</span>
<span class="n">Woof</span><span class="w"> </span><span class="n">Woof!</span>
</pre></div>
</div>
<p>Note that the objects are doing something different though
both have been asked to “bark”. This is pretty much the whole
value behind object oriented programming. Objects are able
to do this because they encapsulate state in the form of
properties.</p>
<p>Now, notice that the <code class="docutils literal notranslate"><span class="pre">cat1</span></code> object errors out when asked
to bark. However, we may think of both cats and dogs as
“four legged animals”. Let’s make an <code class="docutils literal notranslate"><span class="pre">animal</span></code> object that
represents this idea -</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">animal</span><span class="w"> </span><span class="p">(</span><span class="n">object</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">Animal</span>
<span class="w">                    </span><span class="o">&#39;</span><span class="ss">num-legs</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p>Now, we’d like to have our cats and dogs respond to a request
for <code class="docutils literal notranslate"><span class="pre">'num-legs</span></code> with 4. We can of course add these properties
to each of those objects, but that feels redundant.</p>
<p>Here is where the “Placeholder” gains importance. We left open
the question of what to do when a property is not found. We
can now exploit that gap by asking another linked object for
the property. But which other object? For that, we can look
it up in the property list.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">get</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">propname</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">propname</span>
<span class="w">        </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">obj</span><span class="w"> </span><span class="n">propname</span><span class="p">)</span>
<span class="w">            </span><span class="c1">; Note the recursive call to &#39;get&#39;</span>
<span class="w">            </span><span class="p">(</span><span class="n">get</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">super</span>
<span class="w">                    </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">obj</span><span class="w"> </span><span class="n">superkey</span><span class="p">)</span>
<span class="w">                        </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s2">&quot;No such parent&quot;</span><span class="p">)))</span>
<span class="w">                 </span><span class="n">propname</span><span class="p">))))</span>
</pre></div>
</div>
<p>We did something interesting there. We first try to look up a “super” property
of the object, which we expect to be defined to another object. If we find one,
we then ask that object for the property. If such a “super object” doesn’t
exist, the <code class="docutils literal notranslate"><span class="pre">getprop</span></code> will error out. But if it does, it will be as though our
object gained the properties of that “super object”. Now, when getting the
property of the “super”, we do it recursively so that if that “super” also
didn’t have that property or method, we look up its “super” and so on until
either the property/method is found or it errors out.</p>
<p>Note that we’ve again left a placeholder for the condition when the “super” of
an object cannot be found. We’ll return to this choice point later. First let’s
see what this mechanism buys us for our animal farm.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">setprop!</span><span class="w"> </span><span class="n">dog1</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">super</span><span class="w"> </span><span class="n">animal</span><span class="p">)</span>
<span class="p">(</span><span class="n">setprop!</span><span class="w"> </span><span class="n">dog2</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">super</span><span class="w"> </span><span class="n">animal</span><span class="p">)</span>
<span class="p">(</span><span class="n">setprop!</span><span class="w"> </span><span class="n">cat1</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">super</span><span class="w"> </span><span class="n">animal</span><span class="p">)</span>

<span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">get</span><span class="w"> </span><span class="n">dog1</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">num-legs</span><span class="p">)</span>
<span class="mi">4</span>
<span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">get</span><span class="w"> </span><span class="n">cat1</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">num-legs</span><span class="p">)</span>
<span class="mi">4</span>
</pre></div>
</div>
<p>We can now also add a method dynamically to <code class="docutils literal notranslate"><span class="pre">animal</span></code> and all the
animals will automatically get it.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">setprop!</span><span class="w"> </span><span class="n">animal</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">walk</span>
<span class="w">    </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="w"> </span><span class="n">num-steps</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="n">setprop!</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">steps-walked</span>
<span class="w">            </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">steps-walked</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="w">               </span><span class="n">num-steps</span><span class="p">))))</span>

<span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">send</span><span class="w"> </span><span class="n">dog1</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">walk</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">get</span><span class="w"> </span><span class="n">dog1</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">steps-walked</span><span class="p">)</span>
<span class="mi">3</span>
<span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">send</span><span class="w"> </span><span class="n">dog1</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">walk</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span>
<span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">get</span><span class="w"> </span><span class="n">dog1</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">steps-walked</span><span class="p">)</span>
<span class="mi">8</span>
</pre></div>
</div>
</section>
<section id="it-s-tiring">
<h2>It’s tiring<a class="headerlink" href="#it-s-tiring" title="Link to this heading">¶</a></h2>
<p>Now, imagine the process we went through just got bigger with many
tens of methods and properties. Every time we make a new object – an
animal – we have to define these properties on each of them. The
ability to delegate commonly accessed methods to such a “super”
object like we just did is therefore a boon since we can just accumulate
those common methods in that “super” object and make the other objects
just reference it via their <code class="docutils literal notranslate"><span class="pre">'super</span></code> property.</p>
<p>This is the essence of how “classes” are modelled in prototype based object
systems. The “super object” of an object is also known as the object’s “class”.</p>
<p>Such prototype based systems do not really distinguish between the notions of
“object methods” versus “class methods”, since these “classes” are themselves
objects and when you send a message via the object, the method actually affects
the object in question and not its class, unless you make the class the target
of the message send. This is due to the methods taking the object as their
first argument usually named <code class="docutils literal notranslate"><span class="pre">self</span></code>, as with Python or <code class="docutils literal notranslate"><span class="pre">this</span></code> as with
JavaScript.</p>
</section>
<section id="class-methods">
<h2>Class methods<a class="headerlink" href="#class-methods" title="Link to this heading">¶</a></h2>
<p>In order to distinguish between “class methods” (methods that operate on the
class) versus “object methods” (methods that operate on the object that
inherits properties and methods from the class), we therefore need to
make that distinction available in the method procedure itself.</p>
<p>So far, we only added the <code class="docutils literal notranslate"><span class="pre">self</span></code> argument. In the <code class="docutils literal notranslate"><span class="pre">send</span></code> procedure,
we first lookup the message in the object hierarchy and then invoke
the method on the object. If we separate the two, we gain the ability
to use the methods in one object and apply then on another. To keep the
generality, though, we need to augment our method argument list with
the object we use to lookup the method as well so that the method can do
what it pleases with that information. The effect of this is only
relevant when we have deeper and/or broader class hierarchies though.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">send/super</span><span class="w"> </span><span class="k">super</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">method</span><span class="w"> </span><span class="p">(</span><span class="n">get</span><span class="w"> </span><span class="k">super</span><span class="w"> </span><span class="n">message</span><span class="p">)])</span>
<span class="w">        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">procedure?</span><span class="w"> </span><span class="n">method</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="k">super</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">args</span><span class="p">)))</span>
<span class="w">            </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s2">&quot;Method must be a procedure&quot;</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="k">send</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">send/super</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="n">args</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">dog1</span>
<span class="w">    </span><span class="p">(</span><span class="n">object</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">puppy</span>
<span class="w">        </span><span class="o">&#39;</span><span class="ss">color</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">brown</span>
<span class="w">        </span><span class="o">&#39;</span><span class="ss">bark</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="k">super</span><span class="w"> </span><span class="n">self</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">displayln</span><span class="w"> </span><span class="s2">&quot;Yelp!&quot;</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">dog2</span>
<span class="w">    </span><span class="p">(</span><span class="n">object</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">adult</span>
<span class="w">        </span><span class="o">&#39;</span><span class="ss">color</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">black</span>
<span class="w">        </span><span class="o">&#39;</span><span class="ss">bark</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="k">super</span><span class="w"> </span><span class="n">self</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">displayln</span><span class="w"> </span><span class="s2">&quot;Woof Woof!&quot;</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">cat1</span>
<span class="w">    </span><span class="p">(</span><span class="n">object</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">siamese</span>
<span class="w">        </span><span class="o">&#39;</span><span class="ss">color</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">grey</span>
<span class="w">        </span><span class="o">&#39;</span><span class="ss">bark</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="k">super</span><span class="w"> </span><span class="n">self</span><span class="p">)</span>
<span class="w">                 </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s2">&quot;I don&#39;t bark! Am I a dog?&quot;</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">animal</span>
<span class="w">    </span><span class="p">(</span><span class="n">object</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">Animal</span>
<span class="w">        </span><span class="o">&#39;</span><span class="ss">num-legs</span><span class="w"> </span><span class="mi">4</span>
<span class="w">        </span><span class="o">&#39;</span><span class="ss">walk</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="k">super</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="n">num-steps</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="n">setprop!</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">steps-walked</span>
<span class="w">                    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">steps-walked</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="w">                       </span><span class="n">num-steps</span><span class="p">)))))</span>
</pre></div>
</div>
<p>So what new capability does doing this give us? Within a method,
we can now delegate a part of the functionality to the “super”
if we wish. For example, if we want to make a custom “walk” method
for the cat that depends on whether it is tired, we can do this -</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">setprop!</span><span class="w"> </span><span class="n">cat</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">tired</span><span class="w"> </span><span class="no">#t</span><span class="p">)</span>
<span class="p">(</span><span class="n">setprop!</span><span class="w"> </span><span class="n">cat</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">walk</span>
<span class="w">    </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">klass</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="n">num-steps</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">get</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">tired</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s2">&quot;No energy for a walk. Go away. Meeeow!&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="n">send/super</span><span class="w"> </span><span class="p">(</span><span class="n">get</span><span class="w"> </span><span class="n">klass</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">super</span><span class="p">)</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">walk</span><span class="w"> </span><span class="n">num-steps</span><span class="p">))))</span><span class="err">)</span>
</pre></div>
</div>
<p>Notice how the cat delegates to its super the ability to walk when it
is able to, but errors out otherwise. Under normal method invocation,
<code class="docutils literal notranslate"><span class="pre">klass</span></code> will be the same as <code class="docutils literal notranslate"><span class="pre">self</span></code>, but we can choose differently,
just as the method does when turning around and invoking the parent
implementation directly, but without changing the target object.</p>
</section>
<section id="classes-and-types">
<h2>Classes and Types<a class="headerlink" href="#classes-and-types" title="Link to this heading">¶</a></h2>
<p>We saw how the concept of a class arises in a prototype based object
system – mostly to collect a group of related methods that apply
to a set of objects that are said to be “instances” of the same idea.
In our example, the dogs and the cat were instances of “animal”.</p>
<p>Due to this correspondence, such a delegate object (which we called “super”)
can be thought of as the “type” of the object. Languages like C++ and Java
which are class based often take this approach. In these languages,
a class acts like a factory for objects which imbues the objects it
creates with a consistent set of properties and methods.</p>
<p>We can pretty much use the same <code class="docutils literal notranslate"><span class="pre">get</span></code> algorithm with naming the
property lookup <code class="docutils literal notranslate"><span class="pre">class</span></code> instead of <code class="docutils literal notranslate"><span class="pre">super</span></code> and it will start
to look like a class based object system. In such systems though,
the relationship between an object and its class is deemed to be
an “is-a” relationship and it is the class which has a hierarchy
and not the object. When an object is created, it is created with
“slots” for its properties and the methods are all grouped within
the class. The object itself does not maintain a table of methods
but delegates method lookup to its class. We can model this structure
like below –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">get</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">propname</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">propname</span>
<span class="w">        </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">thing</span><span class="w"> </span><span class="n">propname</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="n">get</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">super</span><span class="p">)</span><span class="w"> </span><span class="n">propname</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="k">send</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">klass</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">isa</span><span class="p">)])</span>
<span class="w">        </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">send/super</span>
<span class="w">               </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">klass</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="n">args</span><span class="p">))))))</span>
</pre></div>
</div>
</section>
<section id="uniformity-considerations">
<h2>Uniformity considerations<a class="headerlink" href="#uniformity-considerations" title="Link to this heading">¶</a></h2>
<p>We saw that “pure” OOP systems tend to say “everything is an object”
and that “everything happens via message passing”. This includes languages
like Smalltalk, Self and Ruby. Here is, for example, how such a system
might handle branching on a condition.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">setprop!</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">True</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">if:else:</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">ctxt</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">thenblock</span><span class="w"> </span><span class="n">elseblock</span><span class="p">)</span>
<span class="w">                                </span><span class="p">(</span><span class="n">thenblock</span><span class="p">)))</span>
<span class="p">(</span><span class="n">setprop!</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">False</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">if:else:</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">ctxt</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">thenblock</span><span class="w"> </span><span class="n">elseblock</span><span class="p">)</span>
<span class="w">                                </span><span class="p">(</span><span class="n">elseblock</span><span class="p">)))</span>
</pre></div>
</div>
<p>So the result of a boolean computation is a singleton instance of one of the
“classes” named <code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">False</span></code>, which dispatch on the <code class="docutils literal notranslate"><span class="pre">'if:else:</span></code>
message on one or the other branch depending on which instance received the
message.</p>
<p>Other control constructs are also cleverly constructed based on the fundamental
notion of a “block” - which plays the role of a lambda function in OOP
languages like Ruby and Smalltalk, and are “ordinary” first class functions in
languages like JavaScript and Python. For example, a block object could have
a method named <code class="docutils literal notranslate"><span class="pre">whileTrue:</span></code> which takes another block and runs it repeatedly
until the target block returns with <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>What about ordinary numbers then? Should we declare each number used in the
system to have a property list entry that gives it “class”? That would be terribly
wasteful and impractical to do so. So these systems use a few bits in small
data types like numbers to tell their types, as an implementation hack. In
principle, that is equivalent to having some type checks like below –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">get</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">key</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">isa</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">cond</span>
<span class="w">            </span><span class="p">[(</span><span class="nb">number?</span><span class="w"> </span><span class="n">thing</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">Number</span><span class="p">]</span>
<span class="w">            </span><span class="p">[(</span><span class="nb">string?</span><span class="w"> </span><span class="n">thing</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">String</span><span class="p">]</span>
<span class="w">            </span><span class="p">[(</span><span class="nb">symbol?</span><span class="w"> </span><span class="n">thing</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">Symbol</span><span class="p">]</span>
<span class="w">            </span><span class="p">[(</span><span class="nb">boolean?</span><span class="w"> </span><span class="n">thing</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">True</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">False</span><span class="p">)]</span>
<span class="w">            </span><span class="p">[</span><span class="k">else</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">key</span><span class="p">)])</span><span class="w"> </span><span class="c1">; Errors out if not found.</span>
<span class="w">        </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">key</span>
<span class="w">            </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">thing</span><span class="w"> </span><span class="n">key</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="n">get</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">super</span><span class="p">)</span><span class="w"> </span><span class="n">key</span><span class="p">)))))</span>
</pre></div>
</div>
<p>Now we no longer have to have individual raw data items like numbers
and strings in our property list take just so we can get at their types/classes.</p>
</section>
<section id="flipping-things-around">
<h2>Flipping things around<a class="headerlink" href="#flipping-things-around" title="Link to this heading">¶</a></h2>
<p>We modelled message passing as method invocation using our <code class="docutils literal notranslate"><span class="pre">send</span></code> procedure
which we wrote like this (for prototype based inheritance).</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="k">send</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="p">(</span><span class="n">get</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">args</span><span class="p">)))</span>
</pre></div>
</div>
<p>This puts the object in the centre of the stage and the message plays the role
of something that the object receives and then does something with. We can equivalently
write it as an <code class="docutils literal notranslate"><span class="pre">invoke</span></code> procedure like below, which puts the message
at the centre of the stage.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">invoke</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="p">(</span><span class="n">get</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">method</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="n">args</span><span class="p">)))</span>
</pre></div>
</div>
<p>They both do the same thing. But now we can ask an interesting question we
couldn’t have asked with the earlier approach – can we now determine which
method to call based on the types/classes of more than one object? This
situation arises often in scientific computing where “what to do” is often only
possible to know when the types of multiple entities are known – such as how
to add a complex number to a real number or multiply a real number with a
vector, and so on.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">invoke2</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="n">obj1</span><span class="w"> </span><span class="n">obj2</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">obj1</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">type</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">obj2</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">type</span><span class="p">)))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">obj1</span><span class="w"> </span><span class="n">obj2</span><span class="p">)))</span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">invoke2</span></code> above, we’re treating the method as the thing for which
we’re looking up properties against various nominal types (i.e. types by
names). The key is a compound object in this case, a list of two types
(which could be symbols). We can now define methods for concatenating
strings and integers perhaps using this approach –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">setprop!</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">add</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">Number</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">Number</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">n1</span><span class="w"> </span><span class="n">n2</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="n">n2</span><span class="p">)))</span>

<span class="p">(</span><span class="n">setprop!</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">add</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">String</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">Number</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">str</span><span class="w"> </span><span class="n">num</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="s2">&quot;~s~s&quot;</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="n">num</span><span class="p">)))</span>

<span class="p">(</span><span class="n">setprop!</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">add</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">Number</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">String</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">num</span><span class="w"> </span><span class="n">str</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="n">invoke2</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">add</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="p">(</span><span class="nb">string-&gt;number</span><span class="w"> </span><span class="n">str</span><span class="p">))))</span>
</pre></div>
</div>
<p>Now we can add number and strings freely.</p>
<p>The interesting thing about this approach is that we’re not longer forced to
determine whether the code for adding a string with a number should go within
the class for strings or the class for numbers! However, it looks like we’ve
traded that flexibility for a whole lot of responsibility – that of specifying
what procedure to use for potentially N^2 type combinations where N is the
number of types in the program. While the problem is not as dire as that, it
does get burdensome even dealing with special methods for combining various
types of numbers.</p>
<p>This approach is also the essence of “multiple argument dispatch”. We can
obviously extend this approach beyond just 2 arguments. Julia is a programming
language in which this notion of multiple argument dispatch, combined with type
inference and just-ahead-of-time compilation is used to generate highly
efficient code for scientific computing applications. Julia gets around the
problem of having to specify special method implementations for multiple
combinations by permitting the definition of generic methods on which type
inference at call time can produce concrete types and methods at all the call
points and therefore special methods that’re consistent with the intent of the
verb can be generated on demand.</p>
<p>In the above <code class="docutils literal notranslate"><span class="pre">invoke2</span></code> procedure, we’re doing dynamic dispatch over multiple
arguments. However, that is not necessary and it is possible to do some of this
analysis at compile time and determine which method procedures to call
statically … which is a huge efficiency boost over determining it for every
pair of, say, numbers over and over again. While Julia can do dynamic dispatch
as a fallback, such a static dispatch is what it relies on for its performance.</p>
<p>In this approach, therefore, a “verb” does not correspond to a single procedure,
but to a family of related procedures called “methods” and which procedure to
use for a particular call is determined based on the types of the arguments
being passed to it.</p>
</section>
<section id="generic-procedures">
<h2>Generic procedures<a class="headerlink" href="#generic-procedures" title="Link to this heading">¶</a></h2>
<p>So far we’ve defined procedures in Scheme/Racket using the <code class="docutils literal notranslate"><span class="pre">define</span></code> operator,
like this –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">...</span><span class="p">)</span>
</pre></div>
</div>
<p>Once defined, the procedure <code class="docutils literal notranslate"><span class="pre">f</span></code> will remain bound to that body of code
forever .. until redefined entirely. What if, however, we wish to enable it to
be extensible with different code paths depending on what arguments are passed
to it. For simplicity, we’ll assume that the arity of the function cannot be
changed, initially.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">extend</span><span class="w"> </span><span class="n">proc</span><span class="w"> </span><span class="n">predicate</span><span class="w"> </span><span class="n">extension</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="n">args</span>
<span class="w">        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">predicate</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">extension</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">proc</span><span class="w"> </span><span class="n">args</span><span class="p">)))</span>

<span class="c1">; Example of extending ordinary artihmetic to symbolic arithmetic.</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">sym+</span>
<span class="w">    </span><span class="p">(</span><span class="n">extend</span><span class="w"> </span><span class="nb">+</span>
<span class="w">            </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="p">(</span><span class="nb">symbol?</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">symbol?</span><span class="w"> </span><span class="n">y</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)))))</span>

<span class="c1">; (plus 2 3) =&gt; 5</span>
<span class="c1">; (plus 2 &#39;y) =&gt; &#39;(+ 2 y)</span>
<span class="c1">; (plus &#39;x 3) =&gt; &#39;(+ x 3)</span>
</pre></div>
</div>
<p>However, instead of introducing a new symbol <code class="docutils literal notranslate"><span class="pre">sym+</span></code> for our extended
notion of addition, we can replace the earlier definition of <code class="docutils literal notranslate"><span class="pre">+</span></code> to
mean what the new <code class="docutils literal notranslate"><span class="pre">sym+</span></code> means because <code class="docutils literal notranslate"><span class="pre">sym+</span></code> also deals with the
case of adding up ordinary numbers.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="n">sym+</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>When defining <code class="docutils literal notranslate"><span class="pre">sym+</span></code>, we used the existing definition of <code class="docutils literal notranslate"><span class="pre">+</span></code>. Now
that we’ve changed what <code class="docutils literal notranslate"><span class="pre">+</span></code> means, do we now have a circular program?
Explain whether you think “yes” or “no” is the answer to that question
using your understanding of scoping rules of SMoL.</p>
</div>
<p>The predicate-extension pairs form the various branches of a <code class="docutils literal notranslate"><span class="pre">cond</span></code>
expression that decides which of the extension procedures to call based on
properties met by the arguments –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">cond</span>
<span class="w">    </span><span class="p">[(</span><span class="nb">apply</span><span class="w"> </span><span class="n">predicate1</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">extension1</span><span class="w"> </span><span class="n">args</span><span class="p">)]</span>
<span class="w">    </span><span class="p">[(</span><span class="nb">apply</span><span class="w"> </span><span class="n">predicate2</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">extension2</span><span class="w"> </span><span class="n">args</span><span class="p">)]</span>
<span class="w">    </span><span class="k">...</span><span class="p">)</span>
</pre></div>
</div>
<p>Since the cond expression serves as a “post office” that “dispatches” the
arguments to the appropriate extension procedure, we refer to this approach in
the general sense as “dispatch mechanisms” and will study variants in this
chapter.</p>
<p>There are some incidental aspects of the above implementation of the extension
of a function that we won’t concern ourselves about. For example, When we
extend with a new predicate and extension, the latest extension takes
precedence over the earlier installed ones. This raises a question – “what if
we want it to be the other way around?” – but there is little there of
interest to us at this point.</p>
<div class="admonition-restriction admonition">
<p class="admonition-title"><strong>Restriction</strong></p>
<p>For our purposes, we’ll restrict our cases to where the predicates are all
disjoint on any given list of arguments – i.e. only one of the predicates
evaluates to <code class="docutils literal notranslate"><span class="pre">#t</span></code> on a given list of arguments. This means we don’t have
to bother about the order in which we check the predicates.</p>
</div>
<p>So, the key idea behind organizing code using <strong>dispatch</strong> mechanisms is to
have a set of special case procedures associated with predicates on the generic
procedure’s arguments which determine which special case is to be used.</p>
</section>
<section id="one-argument-dispatch">
<h2>One argument dispatch<a class="headerlink" href="#one-argument-dispatch" title="Link to this heading">¶</a></h2>
<p>Let’s take the simple case where all the predicates make their decisions based
only on the first argument. A classic example is “string representation”. We’d
like to be able to view our values in some way and that calls for a textual
presentation of the value.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">as-string</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">string?</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="w">        </span><span class="n">value</span>
<span class="w">        </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s2">&quot;Don&#39;t know how to treat value as a string&quot;</span><span class="p">)))</span>
</pre></div>
</div>
<p>Now supposing we wish to extend this facility to integers. We will need a
special procedure for that –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">int-as-string</span><span class="w"> </span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">cond</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="s2">&quot;0&quot;</span><span class="p">]</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">string-concat</span><span class="w"> </span><span class="s2">&quot;-&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">int-as-string</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">i</span><span class="p">)))]</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">positive-int-as-string</span><span class="w"> </span><span class="n">i</span><span class="p">)]))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">positive-int-as-string</span><span class="w"> </span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="s2">&quot;&quot;</span>
<span class="w">        </span><span class="p">(</span><span class="n">string-concat</span><span class="w"> </span><span class="p">(</span><span class="n">positive-int-as-string</span><span class="w"> </span><span class="p">(</span><span class="n">div</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="n">digit-as-string</span><span class="w"> </span><span class="p">(</span><span class="nb">remainder</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="mi">10</span><span class="p">)))))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">digit-as-string</span><span class="w"> </span><span class="n">d</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">char-&gt;string</span><span class="w"> </span><span class="p">(</span><span class="n">string-char-at</span><span class="w"> </span><span class="s2">&quot;0123456789&quot;</span><span class="w"> </span><span class="n">d</span><span class="p">)))</span>
</pre></div>
</div>
<p>Now we can augment our “as-string” generic procedure with this special case for
integers.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="n">as-string</span><span class="w"> </span><span class="p">(</span><span class="n">extend</span><span class="w"> </span><span class="n">as-string</span>
<span class="w">                        </span><span class="nb">integer?</span>
<span class="w">                        </span><span class="n">int-as-string</span><span class="p">))</span>
</pre></div>
</div>
<p>Whenever we create a new data type in our program, we can augment our
<code class="docutils literal notranslate"><span class="pre">as-string</span></code> generic procedure with a facility that works for our new type
when passed to it.</p>
<p>Note that we’ve now started associating the predicate for dispatch with a
“type” of value we’re passing. Given data types <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">C</span></code>, etc. in
our program, we’ll then end up with specialization functions named
<code class="docutils literal notranslate"><span class="pre">A-as-string</span></code>, <code class="docutils literal notranslate"><span class="pre">B-as-string</span></code>, <code class="docutils literal notranslate"><span class="pre">C-as-string</span></code> and so on which handle
<code class="docutils literal notranslate"><span class="pre">as-string</span></code> cases for each of our types.</p>
<p>This is a little curious because we now associate the “ability to be expressed
as a string” with each of our data types for which we need that in our program.
So there are perhaps two equivalent ways of organizing our code here –</p>
<ol class="arabic simple">
<li><p>Maintain <code class="docutils literal notranslate"><span class="pre">as-string</span></code> in a module and add a new implementation to that
module for every type we introduce within our program. This means every such
type’s definition will have to be imported into the module that builds up
<code class="docutils literal notranslate"><span class="pre">as-string</span></code>. If we continue along the lines of what we’ve been doing so
far, we’ll end up with this kind of an organization.</p></li>
<li><p>We can declare the ability to be presented as a string as a “property” of
our data type, and declare the specialization wherever we declare our type.
This then keeps all such behaviours together, which makes for ease of
maintenance. However then, we need some background facility that will
collect all such specifications for our various types and build up a single
<code class="docutils literal notranslate"><span class="pre">as-string</span></code> that will dispatch over our data types.</p></li>
</ol>
</section>
<section id="a-value-as-a-thing">
<h2>A value as a “thing”<a class="headerlink" href="#a-value-as-a-thing" title="Link to this heading">¶</a></h2>
<p>If we articulate our extension approach as an <code class="docutils literal notranslate"><span class="pre">as-string</span></code> facility that’s
attached to every value we create that’s specialized to its purpose, we’re
starting to think of our values as “things” … more commonly known as
“objects” in programming.</p>
<p>In this perspective, an “object” has “properties” and “methods”, which could be
seen as properties that are function valued which are then called supplying the
object as part of the list of arguments.</p>
<p>We’ll explore this using the notion of a “property list” in our interpreter.</p>
<p>A “property list” associates a value as the property of a thing. Such a list
can be modeled using two accessor functions <code class="docutils literal notranslate"><span class="pre">getprop</span></code> and <code class="docutils literal notranslate"><span class="pre">setprop!</span></code> defined
as below -</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">make-proplist</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">*proplist*</span><span class="w"> </span><span class="p">(</span><span class="nb">box</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()))</span>

<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">property</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="n">loop</span><span class="w"> </span><span class="p">[(</span><span class="n">tail</span><span class="w"> </span><span class="p">(</span><span class="nb">unbox</span><span class="w"> </span><span class="n">*proplist*</span><span class="p">))]</span>
<span class="w">            </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">tail</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s2">&quot;Thing doesn&#39;t have the specified property&quot;</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[(</span><span class="n">triple</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">tail</span><span class="p">))]</span>
<span class="w">                    </span><span class="c1">; [REF1] Why use `eq?` and `equal?` here?</span>
<span class="w">                    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">eq?</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">triple</span><span class="p">)</span><span class="w"> </span><span class="n">thing</span><span class="p">)</span>
<span class="w">                             </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="n">triple</span><span class="p">)</span><span class="w"> </span><span class="n">property</span><span class="p">))</span>
<span class="w">                        </span><span class="p">(</span><span class="nb">third</span><span class="w"> </span><span class="n">triple</span><span class="p">)</span>
<span class="w">                        </span><span class="p">(</span><span class="n">loop</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">tail</span><span class="p">)))))))</span>

<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">setprop!</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">property</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">set-box!</span><span class="w"> </span><span class="n">*proplist*</span>
<span class="w">                  </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">property</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="w">                        </span><span class="p">(</span><span class="nb">unbox</span><span class="w"> </span><span class="n">*proplist*</span><span class="p">))))</span>

<span class="w">    </span><span class="p">(</span><span class="nb">values</span><span class="w"> </span><span class="n">getprop</span><span class="w"> </span><span class="n">setprop!</span><span class="p">))</span>

<span class="p">(</span><span class="k">define-values</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">setprop!</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">make-proplist</span><span class="p">))</span>
</pre></div>
</div>
<p>As usual, we don’t worry about efficiencies at this point, which shows
in how we simply add the property association as a new entry without
checking whether one already exists.</p>
<div class="admonition-question admonition">
<p class="admonition-title"><strong>Question</strong></p>
<p>[REF1] We used <code class="docutils literal notranslate"><span class="pre">eq?</span></code> to check for the “thing”, and <code class="docutils literal notranslate"><span class="pre">equal?</span></code> for the
“property”. What are the consequences of this choice? What would other
choices give us? (ex: <code class="docutils literal notranslate"><span class="pre">equal?</span></code> for “thing” and <code class="docutils literal notranslate"><span class="pre">eq?</span></code> for property, say)</p>
</div>
<p>With this mechanism at hand, we can now express the idea of dispatching
over the first argument using a common function <code class="docutils literal notranslate"><span class="pre">invoke</span></code>.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">invoke</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">method-name</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[(</span><span class="n">method</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">method-name</span><span class="p">))]</span>
<span class="w">        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">method</span>
<span class="w">            </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">args</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s2">&quot;Unknown method. [What do we do here?]&quot;</span><span class="p">))))</span>
</pre></div>
</div>
<p>Now, it’s not usually the case that we want different methods to be attached to
different “things”, but there is often a notion of “these things are of the
same kind and behave similarly with similar properties and methods”. i.e. a set
of things might have common properties and methods and therefore it would be
redundant to have to specify the same collection of applicable methods for each
of them. Note that though methods (i.e. “behaviour”) might be the same, the things
are usually distinguished by the values of their properties, their properties
are not necessarily the same.</p>
<p>Such a shared “table of methods” that defines the behaviour of a set of things
“of the same kind” is called a “class” in “object-oriented programming” languages.
In this case, our invoke takes a slightly different shape -</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">invoke</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">method-name</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[(</span><span class="n">tclass</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">class</span><span class="p">))]</span>
<span class="w">        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">tclass</span>
<span class="w">            </span><span class="p">(</span><span class="n">invoke-by-class</span><span class="w"> </span><span class="n">tclass</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">method-name</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s2">&quot;All things must be associated with a class in total OOP systems&quot;</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">invoke-by-class</span><span class="w"> </span><span class="n">tclass</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">method-name</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[(</span><span class="n">method</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">tclass</span><span class="w"> </span><span class="n">method-name</span><span class="p">))]</span>
<span class="w">        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">method</span>
<span class="w">            </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">tclass</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">method-name</span><span class="w"> </span><span class="n">args</span><span class="p">))))</span>
<span class="w">            </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s2">&quot;What do we do here when a method is absent in a class?&quot;</span><span class="p">))))</span>
</pre></div>
</div>
<p>One further thing to notice is that so far, our <code class="docutils literal notranslate"><span class="pre">getprop</span></code> will actually error
out if the given property was not found. So we really can’t branch like <code class="docutils literal notranslate"><span class="pre">(if</span>
<span class="pre">tclass</span> <span class="pre">...)</span></code>. To support that in a general way, let’s augment <code class="docutils literal notranslate"><span class="pre">getprop</span></code> with
a delegate procedure that will be called for the “property not found” case.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">make-proplist</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">*proplist*</span><span class="w"> </span><span class="p">(</span><span class="nb">box</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()))</span>

<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">property</span><span class="w"> </span><span class="n">delegate</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="n">loop</span><span class="w"> </span><span class="p">[(</span><span class="n">tail</span><span class="w"> </span><span class="p">(</span><span class="nb">unbox</span><span class="w"> </span><span class="n">*proplist*</span><span class="p">))]</span>
<span class="w">            </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">tail</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="n">delegate</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">property</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[(</span><span class="n">triple</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">tail</span><span class="p">))]</span>
<span class="w">                    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">eq?</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">triple</span><span class="p">)</span><span class="w"> </span><span class="n">thing</span><span class="p">)</span>
<span class="w">                             </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="n">triple</span><span class="p">)</span><span class="w"> </span><span class="n">property</span><span class="p">))</span>
<span class="w">                        </span><span class="p">(</span><span class="nb">third</span><span class="w"> </span><span class="n">triple</span><span class="p">)</span>
<span class="w">                        </span><span class="p">(</span><span class="n">loop</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">tail</span><span class="p">)))))))</span>

<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">setprop!</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">property</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">set-box!</span><span class="w"> </span><span class="n">*proplist*</span>
<span class="w">                  </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">property</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="w">                        </span><span class="p">(</span><span class="nb">unbox</span><span class="w"> </span><span class="n">*proplist*</span><span class="p">))))</span>

<span class="w">    </span><span class="p">(</span><span class="nb">values</span><span class="w"> </span><span class="n">getprop</span><span class="w"> </span><span class="n">setprop!</span><span class="p">))</span>
</pre></div>
</div>
<p>Now we can write our <code class="docutils literal notranslate"><span class="pre">invoke</span></code> procedure like this –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">invoke</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">method-name</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[(</span><span class="n">tclass</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">class</span>
<span class="w">                           </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">thing</span><span class="w"> </span><span class="n">property</span><span class="p">)</span>
<span class="w">                                </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s2">&quot;All things must be associated with a class&quot;</span><span class="p">))))]</span>
<span class="w">        </span><span class="p">(</span><span class="n">invoke-by-class</span><span class="w"> </span><span class="n">tclass</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">method-name</span><span class="w"> </span><span class="n">args</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">invoke-by-class</span><span class="w"> </span><span class="n">tclass</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">method-name</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[(</span><span class="n">method</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">tclass</span><span class="w"> </span><span class="n">method-name</span>
<span class="w">                           </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">thing</span><span class="w"> </span><span class="n">property</span><span class="p">)</span>
<span class="w">                                </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s2">&quot;What to do here when a method is absent in a class?&quot;</span><span class="p">))))]</span>
<span class="w">        </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">tclass</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">method-name</span><span class="w"> </span><span class="n">args</span><span class="p">))))))</span>
</pre></div>
</div>
<p>This way of approaching dispatch via an explicit “dispatch table” necessitates
that whenever an object is created, a call to <code class="docutils literal notranslate"><span class="pre">setprop!</span></code> is made to set its
class. In “pure OOP” systems such as Smalltalk, Self and Ruby, the task of
creating an instance of a class (i.e. an “object”) falls on the class. So a
“class” is thought of as a machine for making objects with specific behaviours.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In OOP languages, a “class” may be thought of as a machine for
making objects with specific behaviours.</p>
</div>
<p>We have a choice for when a method is not present in a class. For one thing, we
can ask another class for the method, this other class being associated with the
original class (<code class="docutils literal notranslate"><span class="pre">tclass</span></code>). If we do this, then this other class is expected to
support a set of methods common to a number of classes of which <code class="docutils literal notranslate"><span class="pre">tclass</span></code> is one,
and so is thought of as a “super class”. Our invoke then becomes –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">invoke-by-class</span><span class="w"> </span><span class="n">tclass</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">method-name</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">[(</span><span class="n">end-of-class-hierarchy-error</span>
<span class="w">               </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">tclass</span><span class="w"> </span><span class="n">super-class</span><span class="p">)</span>
<span class="w">                   </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s2">&quot;End of class hierarchy. Method not found.&quot;</span><span class="p">)))</span>
<span class="w">           </span><span class="p">(</span><span class="n">delegate</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">tclass</span><span class="w"> </span><span class="n">method-name</span><span class="p">)</span>
<span class="w">                         </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[(</span><span class="n">super-class</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">tclass</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">super-class</span>
<span class="w">                                                     </span><span class="n">end-of-class-hierarchy-error</span><span class="p">))]</span>
<span class="w">                                </span><span class="p">(</span><span class="n">invoke-by-class</span><span class="w"> </span><span class="n">super-class</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">method-name</span><span class="w"> </span><span class="n">args</span><span class="p">))))</span>
<span class="w">           </span><span class="p">(</span><span class="n">method</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">tclass</span><span class="w"> </span><span class="n">method-name</span><span class="w"> </span><span class="n">delegate</span><span class="p">))]</span>
<span class="w">        </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">tclass</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">args</span><span class="p">)))))</span>
</pre></div>
</div>
<p>And tada! We now have “inheritance” in our object system.</p>
<p>Notice that when we invoke the method procedure, we pass the <code class="docutils literal notranslate"><span class="pre">tclass</span></code> in
addition to the <code class="docutils literal notranslate"><span class="pre">thing</span></code> argument. This is necessary in this approach because
the method may decide that it needs to delegate it to the method implemented
for the super-class, in which case it needs to know which class it is
associated with so it can ask for its super-class. In OOP languages, this is
typically found as a call to <code class="docutils literal notranslate"><span class="pre">super</span></code>.</p>
<p>To implement “multiple inheritance”, we will need to change the lookup of a
super class into a lookup for “super classes” - i.e. a list of classes.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">invoke-by-class/mi</span><span class="w"> </span><span class="n">tclass</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">method-name</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="n">handle-method-not-found</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[(</span><span class="n">method</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">tclass</span><span class="w"> </span><span class="n">method-name</span>
<span class="w">            </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">tclass</span><span class="w"> </span><span class="n">method-name</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="n">loop</span><span class="w"> </span><span class="p">[(</span><span class="n">supers</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">tclass</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">super-classes</span><span class="p">))]</span>
<span class="w">                    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">supers</span><span class="p">)</span>
<span class="w">                        </span><span class="p">(</span><span class="n">handle-method-not-found</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">method-name</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">                        </span><span class="p">(</span><span class="n">invoke-by-class/mi</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">supers</span><span class="p">)</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">method-name</span>
<span class="w">                            </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">thing</span><span class="w"> </span><span class="n">method-name</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">                                </span><span class="p">(</span><span class="n">loop</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">supers</span><span class="p">)))))))))]</span>
<span class="w">        </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">tclass</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">args</span><span class="p">)))))</span>
</pre></div>
</div>
<p>So when we have such “multiple inheritance”, we need to make an explicit choice
about how to resolve methods using the class hierarchy – i.e. <strong>how</strong> we do
method resolution has a bearing on <strong>what our program means</strong>. This is usually
a sign of a deficient language feature.</p>
<p>Note that in this scenario, it is possible that we may scan a particular class
more than once for a method definition, because that class may be a super for a
few different classes, all of which our <code class="docutils literal notranslate"><span class="pre">thing</span></code>’s class happens to inherit
from. This situation where the intent of the programmer is not entirely clear
without more information, is called the “diamond problem”. Since commercially
important languages like C++ feature multiple inheritance, we discuss that a bit
more below.</p>
</section>
<section id="multiple-inheritance">
<h2>Multiple inheritance<a class="headerlink" href="#multiple-inheritance" title="Link to this heading">¶</a></h2>
<p>When we have an inheritance hierarchy, we use that for “method resolution” –
i.e. to determine which particular implementation to use when the user mentions
a method invocation.</p>
<p>“Multiple inheritance” refers to a value (or a new type) inheriting the
functionality of a number of other types by declaring them as “parents”.
Multiple inheritance can lead to certain kinds of problems. For example, if two
of the “inherited” types prescribe different behaviours for the same
method/message, it is unclear which behaviour the type or value must inherit.</p>
<p>Programming languages try to “solve” this problem through some predictable
mechanism that, despite the ambiguity continuing to exist in principle, makes
it easy to determine which behaviour manifests by inspecting the code. For
example, C++ solves it by mandating that the declaration order of the classes
featuring in the inheritance list determines the priority for selection of a
method implementation – i.e. if A and B are both parent classes declared in
that order and both specify implementations for method M, then if the
declaration order is <code class="docutils literal notranslate"><span class="pre">A,</span> <span class="pre">B</span></code>, then A’s implementation takes precedence over
B’s and if the order is <code class="docutils literal notranslate"><span class="pre">B,</span> <span class="pre">A</span></code>, then B’s implementation takes precedence over
A’s.</p>
<p>While such a resolution mechanism appears to address the issue, it is still not
clear from the program design perspective what actually should happen in some
cases and for that reason it is better to avoid this kind of a situation
altogether, as the confusion far outweighs benefits.. For example, if <code class="docutils literal notranslate"><span class="pre">A</span></code> is
a class that <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">C</span></code> inherit from and both override behaviour of method
<code class="docutils literal notranslate"><span class="pre">M</span></code>, and subsequently <code class="docutils literal notranslate"><span class="pre">D</span></code> inherits from both <code class="docutils literal notranslate"><span class="pre">B,</span> <span class="pre">C</span></code>, both the behaviours
of <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">C</span></code> for method <code class="docutils literal notranslate"><span class="pre">M</span></code> seem appropriate as the implementation for
<code class="docutils literal notranslate"><span class="pre">D</span></code>. So which one to choose? Again, even if this is resolved by the
“declaration sequence = priority” approach, the burden has merely shifted to
the programmer to decide which of the two orders to choose. Due to the nature
of the inheritance pattern, this is referred to as “the diamond problem” in OOP
literature.</p>
<figure class="align-center" id="id4">
<img alt="The &quot;diamond problem&quot; of class inheritance." src="_images/diamond.png" />
<figcaption>
<p><span class="caption-text">When two “base classes” a.k.a. “parent classes” of a class themselves
share the same base class, we have a “diamond problem” at hand.</span><a class="headerlink" href="#id4" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="traits-classes-as-types">
<h2>Traits: classes as types<a class="headerlink" href="#traits-classes-as-types" title="Link to this heading">¶</a></h2>
<p>A thing having its behaviour described by a class has the advantage that we can
query the thing to see whether a particular method can act on it. The class, in
this role, serves the abstract purpose of certifying the thing to be of a
certain “type”, if the class provides no concrete implementation of methods and
only serves to make such a declaration. Such a class is called “an abstract
base class” (C++) or, in some languages, a “trait” (Rust) or a “protocol”
(Objective-C) or “interface” (Java). Any derived classes must then provide
concrete implementation of these methods to conform to the trait.</p>
<div class="admonition-ponder-this admonition">
<p class="admonition-title"><strong>Ponder this</strong></p>
<p>How does this approach solve the diamond problem discussed in the previous
section?</p>
</div>
<p>Designing a program using such “interface” classes with only one level of concrete
classes inheriting from such interface classes seems restrictive on the surface,
but is in practice a very useful and extensible design approach. What we’re
talking about here is a design in which every object is an instance of exactly
one concrete class that may “implement” any number of “interfaces” directly or
indirectly.</p>
<p>There can be many implementations of an interface and to use an object, the
programmer only needs to know the specification of the interface and its
methods and little to nothing about the implementation details. This
interface-implementation is made explicit in the Java language where an
“interface” cannot syntactically declare any concrete method behaviours <a class="footnote-reference brackets" href="#intf" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> whereas
a “class” can “implement” an interface and declare implementations. In
Objective-C/C++ (used in iOS programming) the concept of an interface is
referred to as a “protocol” since the language takes the “method invocation is
a form of message passing” view.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="intf" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Recent Java versions break this in limited ways - where a default
implementation can be provided that defines a behaviour in terms of other
methods only … since no information about properties (a.k.a. “member
variables”) is available at the point an interface is being defined.</p>
</aside>
</aside>
<p>For example, a “Serializable” interface may declare the following methods (shown
in the syntaxes of a few different programming languages) [^ –</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="c1">// Java</span>
<span class="kd">interface</span> <span class="nc">Serializable</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">bytes</span><span class="w"> </span><span class="nf">serialize</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// Here Stream would also be an interface spec.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">serializeToStream</span><span class="p">(</span><span class="n">Stream</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// C++</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Serializable</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">serialize</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Here Stream would also be an interface class.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">serializeToStream</span><span class="p">(</span><span class="n">Stream</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Objective-C/C++ */</span>
<span class="k">@protocol</span> <span class="nc">Serializable</span>
<span class="p">-</span> <span class="p">(</span><span class="bp">NSData</span><span class="o">*</span><span class="p">)</span><span class="nf">serialize</span><span class="p">;</span>
<span class="cm">/* Here Stream is a protocol that the passed object is expected to meet. */</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">serializeToStream:</span><span class="w"> </span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">Stream</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">s</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>
</div>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">trait</span><span class="w"> </span><span class="n">ReadableStream</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">read_byte</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">uint8</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">trait</span><span class="w"> </span><span class="n">WritableStream</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">write_byte</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>::<span class="n">uint8</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">trait</span><span class="w"> </span><span class="n">Serializable</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">type</span> <span class="nc">CT</span><span class="p">;</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">serialize</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">uint8</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">serializeToStream</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">WritableStream</span>:<span class="kp">&amp;</span><span class="nc">Self</span>::<span class="n">CT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In languages like Rust and Julia which are not OOP in the traditional sense but
have a notion of a protocol or interface, this idea of an “abstract base class”
is known as a “type trait” or simply “trait”. A trait, therefore, is a
specification of all the methods that a concrete type that declares itself to
implement the trait must provide implementations for to qualify as an
implementation of the trait.</p>
<p>Such “abstract base classes” or “type traits” may themselves declare as
inheriting from other traits and that “trait inheritance hierarchy” can go
arbitrarily deep. However, since they’re all declarations and there can be only
one concrete implementation for the collection of methods indicated through
such an inheritance mechanism, there is no “diamond problem” any more. But yet
again, if this structure turns up in a model of a domain, the responsibility
for deciding what must happen when a particular method is invoked continues to
fall on the programmer of that final implementation.</p>
</section>
<section id="pure-oop">
<h2>“Pure” OOP<a class="headerlink" href="#pure-oop" title="Link to this heading">¶</a></h2>
<p>Languages such as Smalltalk, Self and Rust call themselves “pure
object-oriented languages”, by which they mean that every value is an object
and anything that happens is dictated by a method invocation. This corresponds
roughly to “everything is a lambda” in its universality, but at some level the
system provides some built-in facilities without which we won’t be able to get
anything valuable done at all. “Pure OOP” languages like Smalltalk and Self
take this idea all the way. For example, <code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">False</span></code> are two
subclasses of <code class="docutils literal notranslate"><span class="pre">Boolean</span></code> both of which have an <code class="docutils literal notranslate"><span class="pre">if:else:</span></code> method. The
implementation of <code class="docutils literal notranslate"><span class="pre">if:else:</span></code> for <code class="docutils literal notranslate"><span class="pre">True</span></code> will pick the <code class="docutils literal notranslate"><span class="pre">if:</span></code> branch and
the implementation of the method for <code class="docutils literal notranslate"><span class="pre">False</span></code> will pick the <code class="docutils literal notranslate"><span class="pre">else:</span></code> branch.
The language uses method dispatch even for its control structures!</p>
<p>The “anything that happens has to be by method invocation” restriction is not
as trivial as it might seem. For example, here are some –</p>
<ol class="arabic simple">
<li><p>How do you do arithmetic? You invoke the “+” method of a “number object”
supplying another number object as an argument.</p></li>
<li><p>How to create an object? You have to invoke a “new” method on its class.</p></li>
<li><p>How do you create a class? You have to invoke the “new” method on the
<cite>Class</cite> object. Typically, doing so also creates its metaclass.</p></li>
<li><p>How do you add a method to a class? You have to invoke the “addMethod:”
method on its metaclass.</p></li>
<li><p>How do you create a metaclass? You have to invoke the “new” method on the
<cite>Metaclass</cite> metaclass.</p></li>
</ol>
<p>… and so on. Somewhere down the line, the snake has to eat its own tail and
things other than method invocation must begin happening in a practical system.
So the “purity” usually refers to everything that’s accessible to the
language’s user. Given that, systems such as Smalltalk provide very deep
customizability where you can, for example, change aspects of the VM within
Smalltalk itself since its VM and compiler are themselves written is Smalltalk
and are entirely accessible within the language.</p>
<p>For the record, C++ and Java are not “Pure OOP” languages since classes
and objects have different existences in these languages.</p>
</section>
<section id="multiple-argument-dispatch">
<h2>Multiple argument dispatch<a class="headerlink" href="#multiple-argument-dispatch" title="Link to this heading">¶</a></h2>
<p>So far, we looked at dispatching over the first argument of a procedure, which led
us to object oriented languages. OOP languages often resolve operator specialization
typically seen in mathematical domains in a somewhat arbitrary manner. For example,
when adding two numbers <span class="math notranslate nohighlight">\(c + r\)</span> where <span class="math notranslate nohighlight">\(c\)</span> is a complex number and <span class="math notranslate nohighlight">\(r\)</span>
is a real number, should the <span class="math notranslate nohighlight">\(+\)</span> procedure be associated with the “complex number”
type or the real number type?</p>
<p>Even in non-mathematical situations this problem can arise. For example, many
languages support an expression of the form <code class="docutils literal notranslate"><span class="pre">s.charAt(i)</span></code> where <code class="docutils literal notranslate"><span class="pre">s</span></code> is a
string and <code class="docutils literal notranslate"><span class="pre">i</span></code> is an integer. This expression is expected to get the character
at the position <code class="docutils literal notranslate"><span class="pre">i</span></code> within the string <code class="docutils literal notranslate"><span class="pre">s</span></code>. What stops us from expressing the
same operation as <code class="docutils literal notranslate"><span class="pre">i.charWithin(s)</span></code>, where we ask the integer <code class="docutils literal notranslate"><span class="pre">i</span></code> to find
the character at that position within the given string <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
<p>While we may be drawn by familiarity to one or the other choice, there is no
conceptual difference between the two ways of expressing the computation. Languages
such as Common Lisp and Julia include the notion of “multimethods” to address
this dichotomy.</p>
<p>Multimethods put the procedure up front instead of the “object” and ask “given
the particular values of the arguments, which implementation of this procedure
should be invoked?”.</p>
<p>While this looks like an extension of our original idea of “extensible procedures”
to include predicates that work over all the given arguments, it is overwhelming
to provide implementations that branch over specific values. A more manageable
situation is to branch over the collective <strong>types</strong> of the arguments.</p>
<p>We will use the same “property list” structure for dispatch of multimethods.
The “thing” will be the name of the multimethod, the “property” will be a list
of types of the arguments and the value will be a procedure to apply over the
arguments. We will call the procedure that does this dispatch as <code class="docutils literal notranslate"><span class="pre">mapply</span></code>
since it looks pretty much like <code class="docutils literal notranslate"><span class="pre">apply</span></code> except that it dispatches over the
types of the arguments, and the <code class="docutils literal notranslate"><span class="pre">m</span></code> stands for “multi-method”.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">mapply</span><span class="w"> </span><span class="n">method-name</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">list-of-args</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">method</span><span class="w"> </span><span class="p">(</span><span class="n">getprop</span><span class="w"> </span><span class="n">method-name</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">get-type</span><span class="w"> </span><span class="n">list-of-args</span><span class="p">)</span>
<span class="w">                            </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">method-name</span><span class="w"> </span><span class="n">list-of-args</span><span class="p">)</span>
<span class="w">                                 </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s2">&quot;What do we do if method is not found?&quot;</span><span class="p">)))])</span>
<span class="w">         </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="n">list-of-args</span><span class="p">)))</span>
</pre></div>
</div>
<p>We used <code class="docutils literal notranslate"><span class="pre">(map</span> <span class="pre">get-type</span> <span class="pre">list-of-args)</span></code> to turn the list of argument values
into a list a types that we can search against. However, thus far our <code class="docutils literal notranslate"><span class="pre">getprop</span></code>
has been matching the <code class="docutils literal notranslate"><span class="pre">thing</span></code> and <code class="docutils literal notranslate"><span class="pre">property</span></code> fields explicitly as values.</p>
<p>Let’s look at <code class="docutils literal notranslate"><span class="pre">get-type</span></code> a little closer. What should, say, <code class="docutils literal notranslate"><span class="pre">(get-type</span>
<span class="pre">2.5)</span></code> result in? Should it be <code class="docutils literal notranslate"><span class="pre">'real</span></code> or <code class="docutils literal notranslate"><span class="pre">'float32</span></code> or <code class="docutils literal notranslate"><span class="pre">'float64</span></code> or
<code class="docutils literal notranslate"><span class="pre">'complexf32</span></code> and so on? Because as given, <code class="docutils literal notranslate"><span class="pre">2.5</span></code> can be all of those. So
<code class="docutils literal notranslate"><span class="pre">get-type</span></code> is not intended to pick out a vague notion of “what kind of value
is this?” but is expected to provide a term that captures “what exact concrete
type is this value?”. In this case, <code class="docutils literal notranslate"><span class="pre">2.5</span></code> would probably have the concrete
type as <code class="docutils literal notranslate"><span class="pre">'float32</span></code> and so <code class="docutils literal notranslate"><span class="pre">(get-type</span> <span class="pre">2.5)</span></code> should provide us with the
concrete type <code class="docutils literal notranslate"><span class="pre">'float32</span></code>.</p>
<p>As far as dispatch goes, once we have the concrete types of the arguments, we can
search our proplist for a defined method and dispatch to it. However what do we have to
do to setup all of those method procedures in the first place? For example,
consider a simple <code class="docutils literal notranslate"><span class="pre">dist</span></code> function that computes the distance of a point from the
origin on a 2D plane.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">dist</span><span class="w"> </span><span class="n">pt</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="n">Point-x</span><span class="w"> </span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">Point-x</span><span class="w"> </span><span class="n">pt</span><span class="p">))</span>
<span class="w">             </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="n">Point-y</span><span class="w"> </span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">Point-y</span><span class="w"> </span><span class="n">pt</span><span class="p">)))))</span>
</pre></div>
</div>
<p>Now, we may have a Point that uses integers for x and y or floats for x and y.
So our specification of <code class="docutils literal notranslate"><span class="pre">dist</span></code> really should use a dispatcher to generalize
over those types.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">mdist</span><span class="w"> </span><span class="n">pt</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">mapply</span>
<span class="w">        </span><span class="o">&#39;</span><span class="ss">sqrt</span>
<span class="w">        </span><span class="p">(</span><span class="n">mapply</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">+</span>
<span class="w">                </span><span class="p">(</span><span class="n">mapply</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">*</span><span class="w"> </span><span class="p">(</span><span class="n">Point-x</span><span class="w"> </span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">Point-x</span><span class="w"> </span><span class="n">pt</span><span class="p">))</span>
<span class="w">                </span><span class="p">(</span><span class="n">mapply</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">*</span><span class="w"> </span><span class="p">(</span><span class="n">Point-y</span><span class="w"> </span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">Point-y</span><span class="w"> </span><span class="n">pt</span><span class="p">)))))</span>
</pre></div>
</div>
<p>As a first step, if we automatically rewrite the previous <code class="docutils literal notranslate"><span class="pre">dist</span></code> procedure
to use multiple argument dispatch, then we can install it as the target method
for all permissible types of <code class="docutils literal notranslate"><span class="pre">Point</span></code> values it can handle. <a class="footnote-reference brackets" href="#mapply" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p>
<p>However, we can do better than that!</p>
<p>Note that there aren’t that many variations of <code class="docutils literal notranslate"><span class="pre">Point</span></code> values. We have, perhaps
<code class="docutils literal notranslate"><span class="pre">Point{Int16}</span></code>, <code class="docutils literal notranslate"><span class="pre">Point{Int32}</span></code>, <code class="docutils literal notranslate"><span class="pre">Point{Float32}</span></code>, <code class="docutils literal notranslate"><span class="pre">Point{Float64}</span></code>
and such. This is not an indefinitely large list. So given that we know what
kind of a point we have at hand for which we wish to dispatch, we can do the
following -</p>
<ol class="arabic">
<li><p>Don’t install the generic method by default because it is doing the same
work over and over every time it is called – worth eliminating.</p></li>
<li><p>When a method lookup fails, then lookup an appropriate method like <code class="docutils literal notranslate"><span class="pre">dist</span></code>
which meets the type of point that we have. This matching algorithm is more
complex than the <code class="docutils literal notranslate"><span class="pre">getprop</span></code> we’ve been doing so far, but let’s assume it
exists for the moment.</p></li>
<li><p>Generate a specialized version of the generic <code class="docutils literal notranslate"><span class="pre">dist</span></code> where all the
would-be <code class="docutils literal notranslate"><span class="pre">mapply</span></code> points are now resolved right away. For example, we might
generate a specialization of <code class="docutils literal notranslate"><span class="pre">dist</span></code> for <code class="docutils literal notranslate"><span class="pre">Point{Float32}</span></code> to be this -</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">dist-Point&lt;f32&gt;</span><span class="w"> </span><span class="n">pt</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">sqrt&lt;f32&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">+&lt;f32&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">\*&lt;f32&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">Point&lt;f32&gt;-x</span><span class="w"> </span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">Point&lt;f32&gt;-x</span><span class="w"> </span><span class="n">pt</span><span class="p">))</span>
<span class="w">                       </span><span class="p">(</span><span class="n">\*&lt;f32&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">Point&lt;f32&gt;-y</span><span class="w"> </span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">Point&lt;f32&gt;-y</span><span class="w"> </span><span class="n">pt</span><span class="p">)))))</span>
</pre></div>
</div>
<p>Note that doing this involves performing type inference of all the intermediate
compute steps to determine the individual specializations required.</p>
</li>
<li><p>Install the specialized version against the specific <code class="docutils literal notranslate"><span class="pre">Point</span></code> type we have
at hand right now.</p></li>
<li><p>Call the specialized version on the <code class="docutils literal notranslate"><span class="pre">Point</span></code> we have.</p></li>
</ol>
<p>Say we got a <code class="docutils literal notranslate"><span class="pre">Point{Float32}</span></code> for which we needed to compute <code class="docutils literal notranslate"><span class="pre">dist</span></code>,
the first time we get it we incur the cost of generating a specialized method
for it. The next time we encounter another <code class="docutils literal notranslate"><span class="pre">Point{Float32}</span></code>, the specialized
method will be located in our <code class="docutils literal notranslate"><span class="pre">getprop</span></code> list and we can simply call it.
Furthermore, this lookup will work transitively when we’re generating the
specialized methods also.</p>
<p>This is roughly how Julia works to resolve its methods. The code we write can
be generic like the <code class="docutils literal notranslate"><span class="pre">dist</span></code> above. Based on the specific types we give as
arguments, the Julia compiler will generate specialized versions that it will
then cache in its (more efficient) variation of property list. Given that
functions are likely to be called with only a handful of different types in a
given application, the closure of all of these specialization steps will result
in a stable body of highly efficient code.</p>
<section id="auto-generating-a-specialization-of-a-method">
<h3>Auto-generating a specialization of a method<a class="headerlink" href="#auto-generating-a-specialization-of-a-method" title="Link to this heading">¶</a></h3>
<p>So we have the code for <code class="docutils literal notranslate"><span class="pre">dist</span></code> as given in the previous section. We also know
that a point being passed to it in an expression is of type <code class="docutils literal notranslate"><span class="pre">Point{Float32}</span></code>.
How do we generate a specialization of the method for this type?</p>
<p>In essence, we’re performing the <code class="docutils literal notranslate"><span class="pre">mapply</span></code> operations at “code generation
time”. Let’s see what we need in order to determine which method to use for
<code class="docutils literal notranslate"><span class="pre">'*</span></code> in <code class="docutils literal notranslate"><span class="pre">(mapply</span> <span class="pre">'*</span> <span class="pre">(Point-x</span> <span class="pre">pt)</span> <span class="pre">(Point-x</span> <span class="pre">pt))</span></code>. Given a declaration of the
type of <code class="docutils literal notranslate"><span class="pre">'*</span></code> as something like (using Haskell notation) <code class="docutils literal notranslate"><span class="pre">(Num</span> <span class="pre">t)</span> <span class="pre">=&gt;</span> <span class="pre">t</span> <span class="pre">-&gt;</span> <span class="pre">t</span>
<span class="pre">-&gt;</span> <span class="pre">t</span></code>, and that <code class="docutils literal notranslate"><span class="pre">pt</span> <span class="pre">::</span> <span class="pre">Point{Float32}</span></code>, we can infer that <code class="docutils literal notranslate"><span class="pre">(Point-x</span> <span class="pre">pt)</span> <span class="pre">::</span>
<span class="pre">Float32</span></code> and therefore we need to resolve this method application to be
specialized to the type list <code class="docutils literal notranslate"><span class="pre">('Float32</span> <span class="pre">'Float32)</span></code>. If we then assume that
various such specializations of <code class="docutils literal notranslate"><span class="pre">'*</span></code> are available as a base in the system,
we can substitute the <code class="docutils literal notranslate"><span class="pre">(mapply</span> <span class="pre">...)</span></code> expression with (in pseudo code)
<code class="docutils literal notranslate"><span class="pre">(*-Float32-&gt;Float32-&gt;Float32</span> <span class="pre">(Point-x</span> <span class="pre">pt)</span> <span class="pre">(Point-x</span> <span class="pre">pt))</span></code>. Here we’re using
the symbol <code class="docutils literal notranslate"><span class="pre">*-Float32-&gt;Float32-&gt;Float32</span></code> to refer to the specific function
variant of <code class="docutils literal notranslate"><span class="pre">*</span></code> that works on this particular type combination.</p>
<p>Notice that in order to do this, we need some type annotations for our functions,
especially the base library of functions, and also a suitable type inference
mechanism using which we can determine the type of a function application only
given the types of the arguments and (optionally) any type annotation(s) available
for the function being applied.</p>
<p>This brings us then to the topic of type systems and type inference
(<a class="reference internal" href="types.html"><span class="doc">Types: Checking some program invariants statically</span></a>). While that section deals with types as a mechanism to constrain
the meaning of programs and to check their correctness, we see here that type
systems can also be useful for determining program operation by helping with
dispatch.</p>
<p class="rubric">footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="mapply" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>We should be doing <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">mapply</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">Point-x</span><span class="w"> </span><span class="n">pt</span><span class="p">)</span></code> and <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">mapply</span>
<span class="o">&#39;</span><span class="ss">Point-y</span><span class="w"> </span><span class="n">pt</span><span class="p">)</span></code> as well, but I skipped that for brevity and the point is
sufficiently made by the other <code class="docutils literal notranslate"><span class="pre">mapply</span></code> mentions.</p>
</aside>
</aside>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Comp308: Principles of Programming Languages</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Welcome note</a></li>
<li class="toctree-l1"><a class="reference internal" href="racket-intro.html">A quick introduction to Racket and Scheme</a></li>
<li class="toctree-l1"><a class="reference internal" href="lambda.html">λ - the everything</a></li>
<li class="toctree-l1"><a class="reference internal" href="church.html">Lambda - via β-abstraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="piclang.html">A language for pictures</a></li>
<li class="toctree-l1"><a class="reference internal" href="arithlang.html">A language for arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine.html">A mental model for the machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="notional-machine.html">Notional machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="growing.html">Growing the language</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun.html">Functions and scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun-arith.html">Functions and scope (arithmetic track)</a></li>
<li class="toctree-l1"><a class="reference internal" href="stacks-and-scope.html">Stacks and scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun-in-piclang.html">Functions in PicLang</a></li>
<li class="toctree-l1"><a class="reference internal" href="mutations.html">Mutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="control.html">Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="generators.html">Generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="errornot.html">On the choice between “error” and “do something reasonable” in design</a></li>
<li class="toctree-l1"><a class="reference internal" href="objects.html">Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="objects-self.html">Objects - the Self way</a></li>
<li class="toctree-l1"><a class="reference internal" href="dispatch.html">Polymorphism via dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="appsem.html">Alternative application semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html">Types: Checking some program invariants statically</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2022, Srikumar K. S..
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="_sources/dispatch-olds.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>