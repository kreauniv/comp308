
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>A quick introduction to Racket and Scheme &#8212; Comp308: Principles of Programming Languages v1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Lambda - the everything" href="lambda.html" />
    <link rel="prev" title="Welcome to Comp308: Principles of Programming Languages’s documentation!" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="a-quick-introduction-to-racket-and-scheme">
<h1>A quick introduction to Racket and Scheme<a class="headerlink" href="#a-quick-introduction-to-racket-and-scheme" title="Permalink to this headline">¶</a></h1>
<p>We’re going to be using the <code class="docutils literal notranslate"><span class="pre">#lang</span> <span class="pre">plai-typed</span></code> in this course and therefore
it is important that you get some decent familiarity with Scheme. Fortunately,
if you’re comfortable with normal algebra – i.e. mostly substituting one thing
for another that’s equal to it – this is rather easy to pick up compared to
almost any other programming language. In fact, for the purpose of this course,
you do not need to be able to write very complicated programs using lots of
complex language features, which in Scheme’s case would’ve been built in Scheme
itself. You’ll need to be able to read and understand expressions and be able
to manipulate them in the Racket IDE. We’ll be shooting for minimalism in
concept, with maximum impact on understanding.</p>
<p>So without further ado, here is a basic “lightning” introduction to Scheme. For
the purpose of this introduction, you’ll be using <code class="docutils literal notranslate"><span class="pre">#lang</span> <span class="pre">racket</span></code>. We’ll be
using other languages during this course, but the basic meaning of expressions
described here is not going to differ between them much.</p>
<div class="section" id="things">
<h2>Things<a class="headerlink" href="#things" title="Permalink to this headline">¶</a></h2>
<p>You write programs that compute some things given other things. We call these
things “values” or, if you want to sound sophisticated, “objects”.</p>
<div class="admonition-preparation admonition">
<p class="admonition-title"><strong>Preparation</strong></p>
<p>Lanch DrRacket, open a new file named “test.rkt” and type <code class="docutils literal notranslate"><span class="pre">#lang</span> <span class="pre">racket</span></code>
on the very first line of the file. Hit the “Run” button at the top right
corner and see that the REPL is now ready for you. If you’d typed any
definitions or expressions into the file, they would’ve been evaluated
and the defined symbols will be available in the REPL for you to play with.
But we’re getting ahead of ourselves now.</p>
</div>
<p>In Scheme, there are some basic “things” we work with, which you can type
into the REPL and it will promptly give it back to you –</p>
<dl>
<dt><strong>Booleans</strong></dt><dd><p>The notation <code class="docutils literal notranslate"><span class="pre">#t</span></code> stands for “true” and <code class="docutils literal notranslate"><span class="pre">#f</span></code> stands for “false”.
Scheme also supports “generalized booleans” - where <code class="docutils literal notranslate"><span class="pre">#f</span></code> is
treated as “false”, but everything else is considered to be “true”.</p>
</dd>
<dt><strong>Numbers</strong></dt><dd><p>Ordinary integers like 12 and -456, fractions like 22/7, floating
point numbers like 31415.926e-4 . The first two types are called
“exact numerals” since comparison of two numbers is defined.
The floating point numbers are called “inexact” because the finite
number of bits used to represent them means there can be round off
errors that prevent equality comparisons without error bounds.</p>
</dd>
<dt><strong>Strings</strong></dt><dd><p>You write strings within double quotes like <code class="docutils literal notranslate"><span class="pre">&quot;this</span> <span class="pre">simple</span> <span class="pre">string&quot;</span></code>.
You can use unicode characters within the quotes too.</p>
</dd>
<dt><strong>Symbols</strong></dt><dd><p>Symbols are written like normal English words. You can also use
multi-part words (like <code class="docutils literal notranslate"><span class="pre">multi-part-word</span></code>). Symbols permit
any character to feature in it including unicode characters,
except brackets and backslash and spaces. If you want to make
symbols with spaces in them, you can place the symbol text within
vertical bars like this – <code class="docutils literal notranslate"><span class="pre">|this</span> <span class="pre">is</span> <span class="pre">also</span> <span class="pre">a</span> <span class="pre">symbol|</span></code>.</p>
<p>If you tried to type a symbol like that into the REPL, you’d have got an
“undefined” error message in red. This is because when the REPL encounters
a symbol, it tries to find out what value it has been <strong>bound</strong> to and
print that instead. When no such definition is found, it prints the error.</p>
<p>To prevent the REPL from doing that lookup, you can “quote” the symbol
with a single quote prefix character – like this <code class="docutils literal notranslate"><span class="pre">'a-quoted-symbol</span></code>.
If you typed that instead, you’ll see that you get it back as is.</p>
</dd>
</dl>
<p>The above “things” are simple data types. Scheme also has compound “things”,
given below –</p>
<dl class="simple">
<dt><strong>Pairs</strong></dt><dd><p>These are written like this – <code class="docutils literal notranslate"><span class="pre">'(&lt;first-thing&gt;</span> <span class="pre">.</span> <span class="pre">&lt;second-thing&gt;)</span></code>. Note
the quote character in front telling the REPL that it is intended to be
treated as a “literal” and not to lookup any symbol’s value or evaluate
anything. The period character in the middle separates the first and the
second parts of the “pair”. This is also called a “cons pair”.</p>
</dd>
<dt><strong>Lists</strong></dt><dd><p>You can store many things in a compound structure by nesting pairs like
this – <code class="docutils literal notranslate"><span class="pre">'(first</span> <span class="pre">.</span> <span class="pre">(second</span> <span class="pre">.</span> <span class="pre">(third</span> <span class="pre">.</span> <span class="pre">(fourth</span> <span class="pre">.</span> <span class="pre">()))))</span></code> – where the last
<code class="docutils literal notranslate"><span class="pre">()</span></code> stands for <code class="docutils literal notranslate"><span class="pre">empty</span></code>. This is essentially a singly linked list which
also has a short hand form in Scheme. You can write the exact same list as
– <code class="docutils literal notranslate"><span class="pre">'(first</span> <span class="pre">second</span> <span class="pre">third</span> <span class="pre">fourth)</span></code>. In fact, if you’d typed the previous
nested pair expression into the REPL, it would’ve shown you the second form
in the output. Scheme does not distinguish between the two structures
internally. Making lists is such a common use of pairs in Scheme that
accessing the two pairs of a pair is done using functions named <code class="docutils literal notranslate"><span class="pre">first</span></code>
and <code class="docutils literal notranslate"><span class="pre">rest</span></code> respectively.</p>
</dd>
</dl>
</div>
<div class="section" id="s-expressions">
<h2>S-expressions<a class="headerlink" href="#s-expressions" title="Permalink to this headline">¶</a></h2>
<p>And then you have the famous “s-expressions” (for “symbolic expressions”),
which also look like lists, except that there is no quote character sticking in
front of it. A typically s-expression is of the form –</p>
<p><code class="docutils literal notranslate"><span class="pre">(&lt;operator&gt;</span> <span class="pre">&lt;operand-1&gt;</span> <span class="pre">&lt;operand-2&gt;</span> <span class="pre">...</span> <span class="pre">&lt;operand-N&gt;)</span></code></p>
<p>The first entry in the list is special and is taken to be an “operator value”
that is then applied to the remainder of the list which would be a list of
operands, and the entire expression will be taken to mean that final result
of application of the operator. For example, type the following into the
REPL to see what you get as a result –</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(+</span> <span class="pre">2</span> <span class="pre">3</span> <span class="pre">4</span> <span class="pre">5)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(cons</span> <span class="pre">10</span> <span class="pre">&quot;hello&quot;)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(list</span> <span class="pre">2</span> <span class="pre">3</span> <span class="pre">4</span> <span class="pre">5)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(+</span> <span class="pre">(*</span> <span class="pre">3</span> <span class="pre">3)</span> <span class="pre">(*</span> <span class="pre">4</span> <span class="pre">4))</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(string-&gt;symbol</span> <span class="pre">&quot;hello&quot;)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(symbol-&gt;string</span> <span class="pre">'hello)</span></code></p></li>
</ul>
<p>As you can see, Scheme provides some operators out of the box. It also lets
you define your own symbols bound to values of interest to you, using the
<code class="docutils literal notranslate"><span class="pre">define</span></code> operator, like this –</p>
<p><code class="docutils literal notranslate"><span class="pre">(define</span> <span class="pre">&lt;operator-symbol&gt;</span> <span class="pre">&lt;value-expression&gt;)</span></code></p>
<p>Go ahead and type the following definitions into your <code class="docutils literal notranslate"><span class="pre">test.rkt</span></code> file
and hit “Run” then look at what the defined symbols evaluate to in the
REPL.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">hello</span> <span class="p">(</span><span class="nb">string-copy</span> <span class="s2">&quot;hello comp308&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="n">pyth-triplet</span> <span class="p">(</span><span class="nb">list</span> <span class="n">hello</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">4</span> <span class="mi">4</span><span class="p">)))))</span>
</pre></div>
</div>
<p>Note how an s-expression is evaluated. First the expressions featuring
in each slot of the list are evaluated. The results are then substituted
into the list. The first slot is taken as the operator and the rest of
the list as its list of operands. Then the operator is “applied” to
the list of operands to get the result. This is recursive. The expression
in the second definition above will be evaluated in the following sequence -</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="nb">list</span>        <span class="c1">; Becomes the predefined list creation procedure</span>
<span class="n">hello</span>       <span class="c1">; Becomes &quot;hello comp308&quot;, a string</span>
<span class="mi">3</span>           <span class="c1">; Becomes 3, i.e. itself</span>
<span class="mi">4</span>           <span class="c1">; Becomes 4</span>
<span class="p">(</span><span class="nb">*</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">)</span>     <span class="c1">; Becomes 9</span>
<span class="p">(</span><span class="nb">*</span> <span class="mi">4</span> <span class="mi">4</span><span class="p">)</span>     <span class="c1">; Becomes 16</span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">9</span> <span class="mi">16</span><span class="p">)</span>    <span class="c1">; Becomes 25</span>
<span class="p">(</span><span class="nb">sqrt</span> <span class="mi">25</span><span class="p">)</span>   <span class="c1">; Becomes 5</span>
<span class="p">(</span><span class="nb">list</span> <span class="s2">&quot;hello comp308&quot;</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">; Becomes &#39;(&quot;hello comp308&quot; 3 4 5)</span>
</pre></div>
</div>
</div>
<div class="section" id="procedures">
<h2>Procedures<a class="headerlink" href="#procedures" title="Permalink to this headline">¶</a></h2>
<p>There is another operator that Scheme provides – <code class="docutils literal notranslate"><span class="pre">lambda</span></code> – that’s
used to create your own procedures. The one below, for example,
creates a “hypotenuse” calculating function.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="n">x</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="n">y</span> <span class="n">y</span><span class="p">))))</span>
</pre></div>
</div>
<p>The parts of a “lambda expression” are –</p>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">lambda</span></code> word</p></li>
<li><p>A list of unquoted symbols standing for names of each argument of the
function.</p></li>
<li><p>A series of expressions that can make use of the symbols in the
argument list.</p></li>
</ol>
<p>If you typed the lambda expression above into the REPL, it would’ve printed out
<code class="docutils literal notranslate"><span class="pre">#&lt;procedure&gt;</span></code>, meaning it made a procedure by evaluating that expression.</p>
<p>For those of you familiar with Haskell, the above lambda-expression is
equivalent to the following Haskell expression –</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">\</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">sqrt</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>A lot of what you see there could be called “surface structure”. When
we’re trying to understand programs, this surface structure is more of
a hindrance than help, so we tend to prefer simpler structures since we
can manipulate them using programs – yes, programs manipulating programs
is easily done in Scheme and the lisp family of languages. In Scheme,
there is only one way to express the above computation within the <code class="docutils literal notranslate"><span class="pre">lambda</span></code>,
which is <code class="docutils literal notranslate"><span class="pre">(sqrt</span> <span class="pre">(+</span> <span class="pre">(*</span> <span class="pre">x</span> <span class="pre">x)</span> <span class="pre">(*</span> <span class="pre">y</span> <span class="pre">y)))</span></code> <a class="footnote-reference brackets" href="#xy" id="id1">1</a>.</p>
<p>Since lambda expressions produce functions which are also values that can be
passed around just like numbers, strings, etc, we can give the hypotenuse
procedure a name using the known <code class="docutils literal notranslate"><span class="pre">define</span></code> as follows –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">hypotenuse</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="n">x</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="n">y</span> <span class="n">y</span><span class="p">)))))</span>
</pre></div>
</div>
<p>If you put that into the file and “Run” it, you can use <code class="docutils literal notranslate"><span class="pre">hypotenuse</span></code>
in the REPL like <code class="docutils literal notranslate"><span class="pre">(hypotenuse</span> <span class="pre">3</span> <span class="pre">4)</span></code>.</p>
<dl class="footnote brackets">
<dt class="label" id="xy"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>… barring the exchange of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> variables. We don’t
consider that because in order to see that it is ok to exchange <code class="docutils literal notranslate"><span class="pre">x</span></code>
and <code class="docutils literal notranslate"><span class="pre">y</span></code> and still get the same answer, you need to know that <code class="docutils literal notranslate"><span class="pre">+</span></code>
is commutative – i.e. its order of operands does not matter. This is
not within the scope of a language that treats all operators in the same
spirit. Of course, you’re welcome to write program transformations that
take into account such special information about specific operators.
When you do that though, you’ll still appreciate that an expression has
unambiguous interpretation just from the syntax alone. The Haskell expression
<code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">y)</span></code>,for example, can be interpreted either as
<code class="docutils literal notranslate"><span class="pre">((x</span> <span class="pre">*</span> <span class="pre">x)</span> <span class="pre">+</span> <span class="pre">(y</span> <span class="pre">*</span> <span class="pre">y))</span></code> or <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">*</span> <span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y)</span> <span class="pre">*</span> <span class="pre">y)</span></code> without additional
information about the order of operations. This ambiguity does not exist
in Scheme.</p>
</dd>
</dl>
</div>
<div class="section" id="evaluation-by-substitution">
<h2>Evaluation by substitution<a class="headerlink" href="#evaluation-by-substitution" title="Permalink to this headline">¶</a></h2>
<p>In the absence of side effects, we can evaluate any s-expression
using a process of substitution. Let’s take the same example
above –</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For brevity, we’ll write <code class="docutils literal notranslate"><span class="pre">#&lt;procedure:list&gt;</span></code> and such as just
<code class="docutils literal notranslate"><span class="pre">#&lt;list&gt;</span></code> and will skip evaluation of simple entities like numbers. Note
that <code class="docutils literal notranslate"><span class="pre">#&lt;procedure:list&gt;</span></code> is not a usable value in Scheme and is just how
compiled procedures with a name get printed out in the REPL. We’re using
<code class="docutils literal notranslate"><span class="pre">#&lt;list&gt;</span></code> and such here only to distinguish between the symbol <code class="docutils literal notranslate"><span class="pre">list</span></code>
and the <em>procedure value</em> that it is bound to.</p>
</div>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">list</span> <span class="n">hello</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">4</span> <span class="mi">4</span><span class="p">))))</span>
<span class="p">(</span><span class="n">#&lt;list&gt;</span> <span class="n">hello</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">4</span> <span class="mi">4</span><span class="p">))))</span>
<span class="p">(</span><span class="n">#&lt;list&gt;</span> <span class="s2">&quot;hello comp308&quot;</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">4</span> <span class="mi">4</span><span class="p">))))</span>
<span class="p">(</span><span class="n">#&lt;list&gt;</span> <span class="s2">&quot;hello comp308&quot;</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">(</span><span class="n">#&lt;sqrt&gt;</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">4</span> <span class="mi">4</span><span class="p">))))</span>
<span class="p">(</span><span class="n">#&lt;list&gt;</span> <span class="s2">&quot;hello comp308&quot;</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">(</span><span class="n">#&lt;sqrt&gt;</span> <span class="p">(</span><span class="n">#&lt;+&gt;</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">4</span> <span class="mi">4</span><span class="p">))))</span>
<span class="p">(</span><span class="n">#&lt;list&gt;</span> <span class="s2">&quot;hello comp308&quot;</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">(</span><span class="n">#&lt;sqrt&gt;</span> <span class="p">(</span><span class="n">#&lt;+&gt;</span> <span class="p">(</span><span class="n">#&lt;*&gt;</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">4</span> <span class="mi">4</span><span class="p">))))</span>
<span class="p">(</span><span class="n">#&lt;list&gt;</span> <span class="s2">&quot;hello comp308&quot;</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">(</span><span class="n">#&lt;sqrt&gt;</span> <span class="p">(</span><span class="n">#&lt;+&gt;</span> <span class="mi">9</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">4</span> <span class="mi">4</span><span class="p">))))</span>
<span class="p">(</span><span class="n">#&lt;list&gt;</span> <span class="s2">&quot;hello comp308&quot;</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">(</span><span class="n">#&lt;sqrt&gt;</span> <span class="p">(</span><span class="n">#&lt;+&gt;</span> <span class="mi">9</span> <span class="p">(</span><span class="n">#&lt;*&gt;</span> <span class="mi">4</span> <span class="mi">4</span><span class="p">))))</span>
<span class="p">(</span><span class="n">#&lt;list&gt;</span> <span class="s2">&quot;hello comp308&quot;</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">(</span><span class="n">#&lt;sqrt&gt;</span> <span class="p">(</span><span class="n">#&lt;+&gt;</span> <span class="mi">9</span> <span class="mi">16</span><span class="p">)))</span>
<span class="p">(</span><span class="n">#&lt;list&gt;</span> <span class="s2">&quot;hello comp308&quot;</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">(</span><span class="n">#&lt;sqrt&gt;</span> <span class="mi">25</span><span class="p">))</span>
<span class="p">(</span><span class="n">#&lt;list&gt;</span> <span class="s2">&quot;hello comp308&quot;</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
<span class="o">&#39;</span><span class="p">(</span><span class="s2">&quot;hello comp308&quot;</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>A simpler presentation of the above evaluation sequence can be made, which
shows more clearly that inner operator expressions get evaluated before the
outer ones. In the simpler presentation below, we’ll also dispense with the
distinction between pre-defined symbols like <code class="docutils literal notranslate"><span class="pre">list</span></code> and their procedure
values <code class="docutils literal notranslate"><span class="pre">#&lt;procedure:list&gt;</span></code>.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">list</span> <span class="n">hello</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">4</span> <span class="mi">4</span><span class="p">))))</span>
<span class="p">(</span><span class="nb">list</span> <span class="s2">&quot;hello comp308&quot;</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">4</span> <span class="mi">4</span><span class="p">))))</span>
<span class="p">(</span><span class="nb">list</span> <span class="s2">&quot;hello comp308&quot;</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">9</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">4</span> <span class="mi">4</span><span class="p">))))</span>
<span class="p">(</span><span class="nb">list</span> <span class="s2">&quot;hello comp308&quot;</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">9</span> <span class="mi">16</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">list</span> <span class="s2">&quot;hello comp308&quot;</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="mi">25</span><span class="p">))</span>
<span class="p">(</span><span class="nb">list</span> <span class="s2">&quot;hello comp308&quot;</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
<span class="o">&#39;</span><span class="p">(</span><span class="s2">&quot;hello comp308&quot;</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>We can similarly think of evaluating the <code class="docutils literal notranslate"><span class="pre">(hypotenuse</span> <span class="pre">3</span> <span class="pre">4)</span></code>
expression using substitution as follows –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="c1">; Replace &quot;hypotenuse&quot; with the defined lambda expression</span>
<span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="n">x</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="n">y</span> <span class="n">y</span><span class="p">))))</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">; Substitute the given values in the body of the lambda expression</span>
<span class="c1">; and get rid of &quot;lambda&quot; and the formal parameters.</span>
<span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">4</span> <span class="mi">4</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">9</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">4</span> <span class="mi">4</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">9</span> <span class="mi">16</span><span class="p">))</span>
<span class="p">(</span><span class="nb">sqrt</span> <span class="mi">25</span><span class="p">)</span>
<span class="mi">5</span>
</pre></div>
</div>
<p>The main thing to understand in the above sequence is the first step
of substituting 3 for x and 4 for y according to the declared
argument sequence.</p>
</div>
<div class="section" id="homoiconicity">
<h2>Homoiconicity<a class="headerlink" href="#homoiconicity" title="Permalink to this headline">¶</a></h2>
<p>You’d have noticed that there are two ways of evaluating expressions depending
on what operator is placed at the head of the list. For example, if you did
<code class="docutils literal notranslate"><span class="pre">(list</span> <span class="pre">(x</span> <span class="pre">y)</span> <span class="pre">(+</span> <span class="pre">x</span> <span class="pre">y))</span></code>, the RPEL would’ve complained about <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>
not being defined. However <code class="docutils literal notranslate"><span class="pre">(lambda</span> <span class="pre">(x</span> <span class="pre">y)</span> <span class="pre">(+</span> <span class="pre">x</span> <span class="pre">y))</span></code> turns out ok.</p>
<p>This is because there indeed are two types of operators in Scheme –
“procedures” and “macros”. When evaluating a procedure, all the operands are
evaluated first before substituting their values for the procedure’s operands.
For a macro, the argument expressions are bound as is without evaluation to the
arguments, and the macro code can decide when to evaluate them and what to do
with them. This is referred to as “macro expansion”. I just mention it here for
now and we’ll deal with it soon enough in the course.</p>
<p>We saw that there is a difference between typing <code class="docutils literal notranslate"><span class="pre">'(+</span> <span class="pre">2</span> <span class="pre">3)</span></code> and <code class="docutils literal notranslate"><span class="pre">(+</span> <span class="pre">2</span> <span class="pre">3)</span></code>
in the REPL. The first case (with the quote prefix) produces a 3-element list
and the second produces the number <code class="docutils literal notranslate"><span class="pre">5</span></code>. The first expression happens to be
a shorthand for <code class="docutils literal notranslate"><span class="pre">(quote</span> <span class="pre">(+</span> <span class="pre">2</span> <span class="pre">3))</span></code> which is again one of those operators
that don’t evaluate their arguments first. To evaluate the expression, you
can use the <code class="docutils literal notranslate"><span class="pre">eval</span></code> operator like this – <code class="docutils literal notranslate"><span class="pre">(eval</span> <span class="pre">(quote</span> <span class="pre">(+</span> <span class="pre">2</span> <span class="pre">3)))</span></code> which
will result in <code class="docutils literal notranslate"><span class="pre">5</span></code>. It’s like <code class="docutils literal notranslate"><span class="pre">(eval</span> <span class="pre">(quote</span> <span class="pre">(+</span> <span class="pre">2</span> <span class="pre">3)))</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">(+</span> <span class="pre">2</span> <span class="pre">3)</span></code> – i.e. <code class="docutils literal notranslate"><span class="pre">eval</span></code> undoes the <code class="docutils literal notranslate"><span class="pre">quote</span></code> in effect.</p>
<p>This “code that produces and consumes code” is possible due to the language’s
structure called “homoiconicity” - usually meaning the programmer writes code
in the same structure used to represent the code internally – in this case,
using nested lists.</p>
</div>
<div class="section" id="what-s-in-the-box">
<h2>What’s in the box?<a class="headerlink" href="#what-s-in-the-box" title="Permalink to this headline">¶</a></h2>
<p>Scheme comes with many standard functions for working with data. You don’t
need to learn all of them. You can just search the <a class="reference external" href="https://docs.racket-lang.org/">Racket documentation</a>
for relevant functions when you need them and then use them. However, a
few common forms such as <code class="docutils literal notranslate"><span class="pre">let</span></code> are useful to know.</p>
<p>Some common and useful functions –</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(first</span> <span class="pre">&lt;list&gt;)</span></code> Gets the first element</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(rest</span> <span class="pre">&lt;list&gt;)</span></code> Skips the first element and returns the rest of the list.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(length</span> <span class="pre">&lt;list&gt;)</span></code> the number of elements in the list.</p></li>
<li><p>The usual math functions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(string?</span> <span class="pre">&lt;thing&gt;)</span></code> returns <code class="docutils literal notranslate"><span class="pre">#t</span></code> if the thing is a string and <code class="docutils literal notranslate"><span class="pre">#f</span></code> otherwise.</p></li>
<li><p>Other type testing functions – <code class="docutils literal notranslate"><span class="pre">list?</span></code>, <code class="docutils literal notranslate"><span class="pre">number?</span></code>, <code class="docutils literal notranslate"><span class="pre">boolean?</span></code>, etc.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(apply</span> <span class="pre">&lt;fn&gt;</span> <span class="pre">&lt;list-of-args&gt;)</span></code>  – This results in the given
function/procedure being applied to the given list of arguments. So <code class="docutils literal notranslate"><span class="pre">(apply</span>
<span class="pre">+</span> <span class="pre">(list</span> <span class="pre">2</span> <span class="pre">3))</span></code> reduces to <code class="docutils literal notranslate"><span class="pre">(+</span> <span class="pre">2</span> <span class="pre">3)</span></code> which evaluates to <code class="docutils literal notranslate"><span class="pre">5</span></code>.</p></li>
</ul>
<p>Some common useful “macro” operators –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="c1">; Sequencing computations</span>
<span class="p">(</span><span class="k">begin</span>
    <span class="n">&lt;expr-1&gt;</span>
    <span class="n">&lt;expr-2&gt;</span>
    <span class="k">...</span>
    <span class="n">&lt;expr-N&gt;</span><span class="p">)</span>  <span class="c1">; The value of the &quot;begin&quot; expression</span>
               <span class="c1">; is the value of the last expression.</span>
               <span class="c1">; The others are evaluated only for their</span>
               <span class="c1">; side effects.</span>

<span class="c1">; Choosing one of two based on a boolean expression.</span>
<span class="p">(</span><span class="k">if</span> <span class="n">&lt;condition-expression&gt;</span>
    <span class="n">&lt;then-expression&gt;</span>
    <span class="n">&lt;else-expression&gt;</span><span class="p">)</span>

<span class="c1">; Choosing one of N based on as many boolean expressions.</span>
<span class="c1">; The &quot;else&quot; clause is optional. When present, you can</span>
<span class="c1">; think of the &quot;else&quot; word being substituted by #t (for &quot;true&quot;)</span>
<span class="c1">; and the effect will be the same.</span>
<span class="p">(</span><span class="k">cond</span> <span class="p">(</span><span class="n">&lt;cond-1&gt;</span> <span class="n">&lt;expr-1&gt;</span><span class="p">)</span>
      <span class="p">(</span><span class="n">&lt;cond-2&gt;</span> <span class="n">&lt;expr-2&gt;</span><span class="p">)</span>
      <span class="k">...</span>
      <span class="p">(</span><span class="k">else</span> <span class="n">&lt;expr-when-no-condition-above-is-met&gt;</span><span class="p">))</span>

<span class="c1">; The &quot;let&quot; form gets you local bindings for symbols</span>
<span class="c1">; only applicable within the body of the let. The body</span>
<span class="c1">; consists of a sequence of expressions which are evaluated</span>
<span class="c1">; similar to &quot;begin&quot; given above.</span>
<span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="n">&lt;symbol-1&gt;</span> <span class="n">&lt;value-1&gt;</span><span class="p">)</span>
      <span class="p">(</span><span class="n">&lt;symbol-2&gt;</span> <span class="n">&lt;value-2&gt;</span><span class="p">)</span>
      <span class="k">...</span><span class="p">)</span>
   <span class="n">&lt;expr-1&gt;</span>
   <span class="n">&lt;expr-2&gt;</span>  <span class="c1">; These can use &lt;symbol-1&gt;, &lt;symbol-2&gt; etc.</span>
   <span class="k">...</span>
   <span class="n">&lt;expr-N&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that white space doesn’t matter for meaning, except that some
space must be there between the terms of an s-expression.</p>
<div class="section" id="read-and-write">
<h3><code class="docutils literal notranslate"><span class="pre">read</span></code> and <code class="docutils literal notranslate"><span class="pre">write</span></code><a class="headerlink" href="#read-and-write" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">write</span></code> procedure can be used to write out a serialized form of the given
value. For example <code class="docutils literal notranslate"><span class="pre">(write</span> <span class="pre">'(+</span> <span class="pre">2</span> <span class="pre">3))</span></code> <a class="footnote-reference brackets" href="#quote" id="id2">2</a> will print out <code class="docutils literal notranslate"><span class="pre">(+</span> <span class="pre">2</span> <span class="pre">3)</span></code>
and <code class="docutils literal notranslate"><span class="pre">(write</span> <span class="pre">(+</span> <span class="pre">2</span> <span class="pre">3))</span></code> will print out <code class="docutils literal notranslate"><span class="pre">5</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">read</span></code> procedure is like a dual of <code class="docutils literal notranslate"><span class="pre">write</span></code>, in that it will read one
expression from the input and return it in parsed form. The agreement between
<code class="docutils literal notranslate"><span class="pre">read</span></code> and <code class="docutils literal notranslate"><span class="pre">write</span></code> is that <strong>what</strong> <code class="docutils literal notranslate"><span class="pre">write</span></code> <strong>writes out,</strong> <code class="docutils literal notranslate"><span class="pre">read</span></code>
<strong>can read back in</strong>. So if you evaluate <code class="docutils literal notranslate"><span class="pre">(read)</span></code> in the REPL, it will
present you with a box in which you can type your input. If you type <code class="docutils literal notranslate"><span class="pre">(+</span> <span class="pre">2</span>
<span class="pre">3)</span></code>, which was the output produced by the above <code class="docutils literal notranslate"><span class="pre">write</span></code>, you’ll see that
<code class="docutils literal notranslate"><span class="pre">(read)</span></code> produced a list of three things - a symbol and two numbers. These
two functions are why the REPL is called the REPL - “read eval print loop”.
The first three parts can literally be written as <code class="docutils literal notranslate"><span class="pre">(print</span> <span class="pre">(eval</span> <span class="pre">(read)))</span></code>
in Scheme and “loop” refers to doing that over and over.</p>
<dl class="footnote brackets">
<dt class="label" id="quote"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Note the quote symbol on the argument to write means the argument
won’t be evaluated. Also note tha the output of <code class="docutils literal notranslate"><span class="pre">write</span></code> didn’t have the
quote symbol.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="the-end-for-now">
<h2>The end (for now)<a class="headerlink" href="#the-end-for-now" title="Permalink to this headline">¶</a></h2>
<p>The above is nearly all the Scheme basics we’ll need. We’ll use a few
constructs built on top of these, but they will have familiar structure and
we’ll go through how they can be reduce to these to understand them. There are
also a few variations used mostly for programming convenience and reducing
verbosity. We’ll see these as we go along and they’ll be obvious to you when we
encounter them. But conceptually, the above is what you need.</p>
<p>Don’t be fooled by the short list above though. <a class="footnote-reference brackets" href="#short" id="id3">3</a> The Racket system comes with
batteries included – a whole host of functionalities provided using modules
and sub-languages (which are also made as modules) using which you can build
sophisticated applications including <a class="reference external" href="https://docs.racket-lang.org/gui/index.html">desktop GUI</a> applications, <a class="reference external" href="https://docs.racket-lang.org/web-server/">web
services</a>.</p>
<p>You may find the absence of “loop” constructs in the above intro strange. We’ll
just use recursion to do loops. They’re efficient in all Scheme implementations
since the Scheme standard mandates what’s called “tail call elimination” which
removes most common recursion overheads and goes a bit beyond as well. TCE
(also sometimes referred to as “tail call optimization” - TCO - or “proper tail
recursion”) is gradually seeping into other languages as well.</p>
<p>Some common niceties –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">hypotenuse</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="n">x</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="n">y</span> <span class="n">y</span><span class="p">))))</span>

<span class="c1">; The above way of defining &quot;hypotenuse&quot; function means</span>
<span class="c1">; exactly the same thing as writing --</span>

<span class="p">(</span><span class="k">define</span> <span class="n">hypotenuse</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="n">x</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="n">y</span> <span class="n">y</span><span class="p">)))))</span>

<span class="c1">; The first is a little easier to read since it shows how hypotenuse will</span>
<span class="c1">; be used in code as well.</span>
</pre></div>
</div>
<p>Racket supports unicode characters in symbol names and the Greek letter <code class="docutils literal notranslate"><span class="pre">λ</span></code>
can be used instead of <code class="docutils literal notranslate"><span class="pre">lambda</span></code> as well (and is commonly used too). To type
such letters and many symbols used in math, the Racket IDE lets you use <a class="reference external" href="https://docs.racket-lang.org/drracket/Keyboard_Shortcuts.html#%28part._.La.Te.X_and_.Te.X_inspired_keybindings%29">LaTeX
symbol names</a>. To get the <code class="docutils literal notranslate"><span class="pre">λ</span></code> symbol, you can type <code class="docutils literal notranslate"><span class="pre">\lambda</span></code> and
with the cursor at the end, press the Ctrl-\ key combination (control +
backslash) to turn the <code class="docutils literal notranslate"><span class="pre">\lambda</span></code> into <code class="docutils literal notranslate"><span class="pre">λ</span></code>.</p>
<dl class="footnote brackets">
<dt class="label" id="short"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>Compared to what we’d have to learn for a language like Python,
or C/C++ or Java. The only other language with similar brief explanation
of how it works is the object oriented language <a class="reference external" href="https://squeak.org/">Smalltalk</a>.</p>
</dd>
</dl>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<p>Evaluate the following by the substitution approach and check your result on
the Racket REPL. All examples below are without side effects, so you don’t need
to worry about duplicated expressions and can use the simple substitution
method. Hint: Do it mechanically at first, paying attention to the parentheses.
You may want to refer to how lambda expressions simplify when applied to values
in the preceding text.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="c1">; 0</span>
<span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">*</span> <span class="mi">14</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">10</span> <span class="mi">5</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">string-append</span> <span class="s2">&quot;hello&quot;</span> <span class="s2">&quot; &quot;</span> <span class="s2">&quot;world&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">remainder</span> <span class="mi">8</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">quotient</span> <span class="mi">8</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">3</span> <span class="mi">8</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1">; 1</span>
<span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">+</span> <span class="n">x</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">1</span> <span class="n">x</span><span class="p">))</span>
      <span class="mi">2</span><span class="p">))</span>
 <span class="mi">4</span><span class="p">)</span>

<span class="c1">; 2</span>
<span class="p">(((</span><span class="k">lambda</span> <span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">1</span> <span class="n">x</span><span class="p">)))))</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="n">x</span> <span class="n">x</span><span class="p">)))</span>
 <span class="mi">4</span><span class="p">)</span>

<span class="c1">; 3</span>
<span class="p">(((</span><span class="k">lambda</span> <span class="p">(</span><span class="n">f</span> <span class="n">g</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="n">x</span> <span class="n">x</span><span class="p">))</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="n">x</span> <span class="mi">1</span><span class="p">)))</span>
 <span class="mi">10</span><span class="p">)</span>

<span class="c1">; 4</span>
<span class="p">(((</span><span class="k">lambda</span> <span class="p">(</span><span class="n">f1</span> <span class="n">f2</span><span class="p">)</span>
    <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">eval</span> <span class="p">(</span><span class="n">f1</span> <span class="n">f2</span> <span class="n">x</span><span class="p">))))</span>
  <span class="nb">cons</span> <span class="nb">+</span><span class="p">)</span>
 <span class="p">(</span><span class="nb">cons</span> <span class="mi">20</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">3</span> <span class="nb">empty</span><span class="p">)))</span>
</pre></div>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Comp308: Principles of Programming Languages</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">A quick introduction to Racket and Scheme</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#things">Things</a></li>
<li class="toctree-l2"><a class="reference internal" href="#s-expressions">S-expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#procedures">Procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="#evaluation-by-substitution">Evaluation by substitution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#homoiconicity">Homoiconicity</a></li>
<li class="toctree-l2"><a class="reference internal" href="#what-s-in-the-box">What’s in the box?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-end-for-now">The end (for now)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lambda.html">Lambda - the everything</a></li>
<li class="toctree-l1"><a class="reference internal" href="piclang.html">A language for pictures</a></li>
<li class="toctree-l1"><a class="reference internal" href="growing.html">Growing the language</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to Comp308: Principles of Programming Languages’s documentation!</a></li>
      <li>Next: <a href="lambda.html" title="next chapter">Lambda - the everything</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Srikumar K. S..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/racket-intro.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>