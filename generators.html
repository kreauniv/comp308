<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Generators &#8212; Comp308: Principles of Programming Languages v1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=3d3fbe02" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=12dfc556" />
    <script src="_static/documentation_options.js?v=5cb08e4e"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Alternative application semantics" href="appsem.html" />
    <link rel="prev" title="Polymorphism via dispatch" href="dispatch.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="generators">
<h1>Generators<a class="headerlink" href="#generators" title="Link to this heading">¶</a></h1>
<p>In <a class="reference internal" href="control.html"><span class="doc">Control</span></a>, we implemented a rudimentary way to define and work with
generators in our small stack-based language. In this section, we’ll see how
Racket provides us with full continuations that can be used for this purpose.</p>
<section id="seeing-continuations-through-abstraction">
<h2>Seeing continuations through β-abstraction<a class="headerlink" href="#seeing-continuations-through-abstraction" title="Link to this heading">¶</a></h2>
<p>In an eager evaluation language, the order in which computations happen
to produce the value of a given expression is known from the structure of
the expression – i.e. “statically”. It is possible to make this order
explicit, as it is done in compilers, by transforming them to a form
known as “static single assignment form” or “SSA form” for short. <a class="footnote-reference brackets" href="#ssa" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="ssa" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>We won’t be dealing with all cases of SSA. Just enough to give
an idea of what “the rest of the computation” means.</p>
</aside>
</aside>
<p>Consider our now familiar expression - the distance calculator between
two points on a plane –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="n">x2</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">y1</span><span class="w"> </span><span class="n">y2</span><span class="p">))))</span>
<span class="c1">; we consider x1, x2, y1 and y2 to be bound variables,</span>
<span class="c1">; perhaps by an enclosing λ</span>
</pre></div>
</div>
<p>We can expression the sequence of calculations that happen here by rewriting
it in such a way that each calculation’s result gets assigned to a variable.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="n">x2</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="n">v1</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">v3</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">y1</span><span class="w"> </span><span class="n">y2</span><span class="p">))</span>
<span class="w">    </span><span class="c1">;------------ the &quot;rest of the computation&quot;</span>
<span class="w">    </span><span class="c1">;------------ after (- y1 y2) is computed</span>
<span class="w">    </span><span class="c1">;------------ follows below.</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">v4</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="n">v3</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">v5</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="n">v4</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">v6</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="n">v5</span><span class="p">))</span>
<span class="w">    </span><span class="n">v6</span><span class="p">)</span>
</pre></div>
</div>
<p>An important aspects of SSA form is that variables introduced are assigned only
once (“single assignment”) based on the “static” analysis of the code.
Compilers do this transformation because it helps optimizers figure out
dependencies easier than if multiple assignments we permitted. For instance,
exchanging the definition order of <code class="docutils literal notranslate"><span class="pre">v2</span></code> and <code class="docutils literal notranslate"><span class="pre">v3</span></code> won’t affect the result.
However, consider the following expression -</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">x</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span>
<span class="w">    </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="c1">; line1</span>
<span class="w">    </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="c1">; line2</span>
<span class="w">    </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w"> </span><span class="c1">; line3</span>
<span class="w">    </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="c1">; line4</span>
<span class="w">    </span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice that exchanging <code class="docutils literal notranslate"><span class="pre">line2</span></code> and <code class="docutils literal notranslate"><span class="pre">line3</span></code>  changes the
meaning of the program. However, when we rewrite it in SSA form as –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">x</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w">   </span><span class="c1">; ssa-line1</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">  </span><span class="c1">; ssa-line2</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">v3</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">  </span><span class="c1">; ssa-line3</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">v4</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">v3</span><span class="w"> </span><span class="n">v2</span><span class="p">))</span><span class="w"> </span><span class="c1">; ssa-line4</span>
<span class="w">    </span><span class="n">v4</span><span class="p">)</span>
</pre></div>
</div>
<p>… <code class="docutils literal notranslate"><span class="pre">ssa-line2</span></code> and <code class="docutils literal notranslate"><span class="pre">ssa-line3</span></code> can be exchanged without changing the
meaning of the program. This analysis is much easier to do in SSA form for
compiler writers.</p>
<p>Since at any point we know the “next expression that can be evaluated”,
we can use that knowledge to transform the original distance calculation
expression through β-abstraction to make clear the execution order like
below –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">x1</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="n">y1</span><span class="p">))))</span>
<span class="c1">; β-abstract over (- x2 x1)</span>
<span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="n">v1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="n">y1</span><span class="p">)))))</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">x1</span><span class="p">))</span>
<span class="c1">; Now β-abstract over the first λ term</span>
<span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f1</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">x1</span><span class="p">)))</span>
<span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="n">v1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="n">y1</span><span class="p">))))))</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">f1</span></code> is a real function that captures “the rest of the computation”
up to the <code class="docutils literal notranslate"><span class="pre">sqrt</span></code> calculation (it is said to be “delimited” at that point)
and the <code class="docutils literal notranslate"><span class="pre">v1</span></code> identifier is analogous to our first SSA form line.</p>
<p>We can continue this process with the insides of the second λ term to
produce the complete form through this sequence of transformations –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f1</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">x1</span><span class="p">)))</span>
<span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="n">v1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="n">y1</span><span class="p">))))))</span>
<span class="c1">; =&gt;</span>
<span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f1</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">x1</span><span class="p">)))</span>
<span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f2</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="n">v1</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="n">y1</span><span class="p">))))))))</span>
<span class="c1">; =&gt;</span>
<span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f1</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">x1</span><span class="p">)))</span>
<span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f2</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="n">v1</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f3</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="n">y1</span><span class="p">)))</span>
<span class="w">                   </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="n">v3</span><span class="p">)))))))))</span>
<span class="c1">; =&gt;</span>
<span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f1</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">x1</span><span class="p">)))</span>
<span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f2</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="n">v1</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f3</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="n">y1</span><span class="p">)))</span>
<span class="w">                   </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v3</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f4</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f4</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="n">v3</span><span class="p">)))</span>
<span class="w">                            </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v4</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="n">v4</span><span class="p">))))))))))</span>
<span class="c1">; =&gt;</span>
<span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f1</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">x1</span><span class="p">)))</span>
<span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f2</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="n">v1</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f3</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="n">y1</span><span class="p">)))</span>
<span class="w">                   </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v3</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f4</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f4</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="n">v3</span><span class="p">)))</span>
<span class="w">                            </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v4</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f5</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="n">v4</span><span class="p">)))</span>
<span class="w">                                     </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="n">v5</span><span class="p">)))))))))))</span>
</pre></div>
</div>
<p>The functions <code class="docutils literal notranslate"><span class="pre">f1</span></code>, <code class="docutils literal notranslate"><span class="pre">f2</span></code>, .. all represent the remaining computations
to be done at each point and <code class="docutils literal notranslate"><span class="pre">v1</span></code>, <code class="docutils literal notranslate"><span class="pre">v2</span></code> all get the results of each
computation step as it happens.</p>
</section>
<section id="delimited-continuations">
<h2>Delimited continuations<a class="headerlink" href="#delimited-continuations" title="Link to this heading">¶</a></h2>
<p>We now make a small step that’s a giant leap of sorts.</p>
<p>Within the λ where we use the <code class="docutils literal notranslate"><span class="pre">f1</span></code>, <code class="docutils literal notranslate"><span class="pre">f2</span></code> etc., we have
expressions of the form <code class="docutils literal notranslate"><span class="pre">(f1</span> <span class="pre">(-</span> <span class="pre">x2</span> <span class="pre">x1))</span></code> and so on. We now
ask “what if we had a magic operator <code class="docutils literal notranslate"><span class="pre">magic</span></code> that made this
<code class="docutils literal notranslate"><span class="pre">f1</span></code> available for us at the point we’re calculating <code class="docutils literal notranslate"><span class="pre">(-</span> <span class="pre">x2</span> <span class="pre">x1)</span></code>?”</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">START</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="p">(</span><span class="n">magic</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="p">(</span><span class="n">f1</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">x1</span><span class="p">))))</span>
<span class="w">                </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="n">y1</span><span class="p">)))))</span>
</pre></div>
</div>
<p>… where we’ve also marked the outer most expression up to which
we consider “the rest of the computation” to happen.</p>
<p>Thing is, this “<code class="docutils literal notranslate"><span class="pre">magic</span></code> operator” exists in racket via the <code class="docutils literal notranslate"><span class="pre">control</span></code>
module. <code class="docutils literal notranslate"><span class="pre">START</span></code> is called <code class="docutils literal notranslate"><span class="pre">reset</span></code> and <code class="docutils literal notranslate"><span class="pre">magic</span></code> is called <code class="docutils literal notranslate"><span class="pre">shift</span></code>.
The function made available by <code class="docutils literal notranslate"><span class="pre">shift</span></code> is called a “delimited continuation”
since its range is delimited by the surrounding <code class="docutils literal notranslate"><span class="pre">reset</span></code>.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">require</span><span class="w"> </span><span class="n">racket/control</span><span class="p">)</span>
<span class="p">(</span><span class="n">reset</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="p">(</span><span class="n">shift</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="p">(</span><span class="n">f1</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">x1</span><span class="p">))))</span>
<span class="w">                </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="n">y1</span><span class="p">)))))</span>
</pre></div>
</div>
<p>Ok so what? Now we ask ourselves “what kind of super powers having
the <code class="docutils literal notranslate"><span class="pre">f1</span></code> at that point gets us?” To see what happens in the
forms below, remember that, for the cases we’re looking at,</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">reset</span><span class="w"> </span><span class="n">...A...</span><span class="w"> </span><span class="p">(</span><span class="n">shift</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="n">...B...</span><span class="p">)</span><span class="w"> </span><span class="n">...C...</span><span class="p">)</span>
<span class="c1">; is equivalent to</span>
<span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f1</span><span class="p">)</span><span class="w"> </span><span class="n">...B...</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="w"> </span><span class="n">...A...</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="n">...C...</span><span class="p">))</span>
</pre></div>
</div>
<p>Consider what would be the result of the following expression –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">reset</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="p">(</span><span class="n">shift</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="w">                </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="n">y1</span><span class="p">)))))</span>
</pre></div>
</div>
<p>Here, we are not using <code class="docutils literal notranslate"><span class="pre">f1</span></code> at all. The equivalent form therefore
looks like –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f1</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="n">v1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="n">y1</span><span class="p">))))))</span>
</pre></div>
</div>
<p>Clearly, the entire computation that the second λ stands for has
been completely discarded. In other words, we’ve gained the power
to choose to abort the computation based on the local decisions
up to a given outer term identified by <code class="docutils literal notranslate"><span class="pre">reset</span></code>. For example,
we could’ve made it conditional like so –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">reset</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="p">(</span><span class="n">shift</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">x1</span><span class="p">)</span>
<span class="w">                                      </span><span class="p">(</span><span class="n">f1</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">x1</span><span class="p">))</span>
<span class="w">                                      </span><span class="mi">0</span><span class="p">)))</span>
<span class="w">                </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="n">y1</span><span class="p">)))))</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">x2</span> <span class="pre">&lt;=</span> <span class="pre">x1</span></code>, the entire expression will evaluate to 0.
We could’ve chosen to produce an error term or anything else
that we please as well.</p>
<p>For another simple example, consider –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">reset</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">(</span><span class="n">shift</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="mi">10</span><span class="p">)))))</span>
</pre></div>
</div>
<p>To find out what this means, we can rewrite it to –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">((</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="mi">10</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">v</span><span class="p">)))</span>
</pre></div>
</div>
<p>Reducing that, we see that the expression computes to <code class="docutils literal notranslate"><span class="pre">20</span></code>
by adding <code class="docutils literal notranslate"><span class="pre">5</span></code> twice.</p>
<p>Within the <code class="docutils literal notranslate"><span class="pre">shift</span></code> block, we can do anything else that Racket
permits us to do with functions since these delimited continuation
functions are effectively ordinary functions – like …</p>
<ol class="arabic simple">
<li><p>Storing it away in a variable or data structure for later use.</p></li>
<li><p>Applying it twice.</p></li>
<li><p>Mapping it over a list of values.</p></li>
<li><p>…. and so on</p></li>
</ol>
</section>
<section id="call-cc-and-let-cc">
<h2><code class="code highlight racket docutils literal highlight-racket"><span class="nb">call/cc</span></code> and <code class="code highlight racket docutils literal highlight-racket"><span class="k">let/cc</span></code><a class="headerlink" href="#call-cc-and-let-cc" title="Link to this heading">¶</a></h2>
<p>Racket also provides un-delimited continuations via the <code class="docutils literal notranslate"><span class="pre">let/cc</span></code> construct
which desugars to <code class="docutils literal notranslate"><span class="pre">call/cc</span></code> as shown below –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let/cc</span><span class="w"> </span><span class="n">&lt;identifier&gt;</span>
<span class="w">    </span><span class="n">&lt;body&gt;...</span><span class="p">)</span>
<span class="c1">; =&gt; desugar =&gt;</span>
<span class="p">(</span><span class="nb">call/cc</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">&lt;identifier&gt;</span><span class="p">)</span>
<span class="w">    </span><span class="n">&lt;body&gt;...</span><span class="p">))</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">&lt;identifier&gt;</span></code> given is bound to the continuation at the point
and thus made available to the <code class="docutils literal notranslate"><span class="pre">..body..</span></code> code. The <code class="docutils literal notranslate"><span class="pre">let/cc</span></code> is
visually easier to relate to and so we’ll use that, but understand
that it desugars to <code class="docutils literal notranslate"><span class="pre">call/cc</span></code> like above and therefore <code class="docutils literal notranslate"><span class="pre">call/cc</span></code>
is the more fundamental operator here.</p>
<div class="admonition-terminology admonition">
<p class="admonition-title"><strong>Terminology</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">call/cc</span></code> stands for the much longer name <code class="docutils literal notranslate"><span class="pre">call-with-current-continuation</span></code>.</p>
</div>
<p>There are some differences from the <code class="docutils literal notranslate"><span class="pre">reset</span></code> / <code class="docutils literal notranslate"><span class="pre">shift</span></code> pair though.</p>
<ol class="arabic simple">
<li><p>The continuation function provided by <code class="docutils literal notranslate"><span class="pre">let/cc</span></code> does not itself return to
the call point. We saw that with the delimited continuation provided by
<code class="docutils literal notranslate"><span class="pre">shift</span></code>, we can call it as many times as we want, even doing compositions
like <code class="docutils literal notranslate"><span class="pre">(f1</span> <span class="pre">(f1</span> <span class="pre">10))</span></code>. Since the continuation provided by <code class="docutils literal notranslate"><span class="pre">let/cc</span></code> does
not itself “return” to its call point, if <code class="docutils literal notranslate"><span class="pre">f1</span></code> were such a <code class="docutils literal notranslate"><span class="pre">let/cc</span></code>
contination, the double call would just be equivalent to <code class="docutils literal notranslate"><span class="pre">(f1</span> <span class="pre">10)</span></code>. In
other words, a call to a <code class="docutils literal notranslate"><span class="pre">let/cc</span></code> provided continuation function is
<strong>always</strong> a tail call whether it occurs in a tail position or not.</p></li>
<li><p>The value of the body of code in <code class="docutils literal notranslate"><span class="pre">let/cc</span></code> becomes the value of the
<code class="docutils literal notranslate"><span class="pre">let/cc</span></code> block, as though there was an implicit call to the continuation
at the end. This is different from the case of <code class="docutils literal notranslate"><span class="pre">shift</span></code> where the body of
<code class="docutils literal notranslate"><span class="pre">shift</span></code> aborts the entire calculation if it does not use the continuation
function. It is easy to see why <code class="docutils literal notranslate"><span class="pre">let/cc</span></code> has this implicit call at the end
because such an abort will essentially be an exit from the program (in
single threaded cases) which is not what we usually want. So the
continuation function provided by <code class="docutils literal notranslate"><span class="pre">let/cc</span></code> can be seen as a “jump out of
the <code class="docutils literal notranslate"><span class="pre">let/cc</span></code> block with this value” procedure.</p></li>
</ol>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">(</span><span class="k">let/cc</span><span class="w"> </span><span class="n">f</span>
<span class="w">        </span><span class="p">(</span><span class="nb">displayln</span><span class="w"> </span><span class="s2">&quot;one&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">displayln</span><span class="w"> </span><span class="s2">&quot;two&quot;</span><span class="p">)))</span>
</pre></div>
</div>
<p>The above will print <code class="docutils literal notranslate"><span class="pre">one</span></code> and then evaluate to the result <code class="docutils literal notranslate"><span class="pre">15</span></code>. The
<code class="docutils literal notranslate"><span class="pre">(displayln</span> <span class="pre">&quot;two&quot;)</span></code> never gets a chance to run because the call to the
continuation <code class="docutils literal notranslate"><span class="pre">f</span></code> aborts everything that follows <code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">10)</span></code>. The <code class="docutils literal notranslate"><span class="pre">10</span></code>
essentially becomes the value of the entire <code class="docutils literal notranslate"><span class="pre">let/cc</span></code> expression, leaving us
with <code class="docutils literal notranslate"><span class="pre">(+</span> <span class="pre">5</span> <span class="pre">10)</span></code> as the result.</p>
<p><code class="docutils literal notranslate"><span class="pre">let/cc</span></code> (i.e. <code class="docutils literal notranslate"><span class="pre">call/cc</span></code>) gives us an operator using which we can implement
any of our familiar imperative control constructs like while/repeat/break/continue,
and also those considered more “modern” such as “async/await” and generators. We’ll
look at generators next. For this reason, <code class="docutils literal notranslate"><span class="pre">call/cc</span></code> is often referred to as
“the ultimate <code class="docutils literal notranslate"><span class="pre">goto</span></code>”.</p>
</section>
<section id="super-power-time-generators">
<h2>Super power time - generators<a class="headerlink" href="#super-power-time-generators" title="Link to this heading">¶</a></h2>
<p>Python generators generalize the notion of <code class="docutils literal notranslate"><span class="pre">return</span></code> from a function to
“temporarily return” using <code class="docutils literal notranslate"><span class="pre">yield</span></code>, by saving away the computational state
so that it can be resumed later. See the sample below –</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">three</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span> <span class="o">+</span> <span class="s2">&quot; 1&quot;</span><span class="p">)</span>
    <span class="k">yield</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span> <span class="o">+</span> <span class="s2">&quot; 2&quot;</span><span class="p">)</span>
    <span class="k">yield</span> <span class="mi">2</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span> <span class="o">+</span> <span class="s2">&quot; 3&quot;</span><span class="p">)</span>
    <span class="k">yield</span> <span class="mi">3</span>
    <span class="k">return</span> <span class="kc">None</span>

<span class="o">&gt;</span> <span class="n">g</span> <span class="o">=</span> <span class="n">three</span><span class="p">(</span><span class="s2">&quot;step&quot;</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="n">step</span> <span class="mi">1</span>
<span class="mi">1</span>
<span class="o">&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="n">step</span> <span class="mi">2</span>
<span class="mi">2</span>
<span class="o">&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="n">step</span> <span class="mi">3</span>
<span class="mi">3</span>
<span class="o">&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
<span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">StopIteration</span>
</pre></div>
</div>
<p>You can see how the function uses “yield” to temporarily pause its computation
which is subsequently resumed by <code class="docutils literal notranslate"><span class="pre">next(g)</span></code>. In the line <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">=</span> <span class="pre">three(&quot;step&quot;)</span></code>,
the function has actually not started any computations at all, as evidenced
by “step 1” not being printed out at that point. Only upon calling <code class="docutils literal notranslate"><span class="pre">next(g)</span></code>
is the computation started.</p>
<p>Generators, due to their ability to suspend and resume computations, find
many uses in python code, including a form of lazy generation of infinite
sequences like this squares generator –</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">squaresFrom</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Try it out on your own to see that it doesn’t complete and yields
one square number at a time.</p>
<p>We can construct this facility given <code class="docutils literal notranslate"><span class="pre">let/cc</span></code>/<code class="docutils literal notranslate"><span class="pre">call/cc</span></code> as shown
below –</p>
<p>What we’re looking for is a procedure <code class="docutils literal notranslate"><span class="pre">generator</span></code> that takes a <code class="docutils literal notranslate"><span class="pre">λ</span></code>
function standing for the body of the generator code and uses <code class="docutils literal notranslate"><span class="pre">yield</span></code>
to pause and resume computation just like the python version.
In our case, we’ll provide this <code class="docutils literal notranslate"><span class="pre">yield</span></code> as an argument to the λ function
given to the <code class="docutils literal notranslate"><span class="pre">generator</span></code> procedure. We want to be able to do the equivalent
of <code class="docutils literal notranslate"><span class="pre">next(g)</span></code> with the result. In our case, we can simplify that by having
<code class="docutils literal notranslate"><span class="pre">generator</span></code> return a function that can be called like <code class="docutils literal notranslate"><span class="pre">(g</span> <span class="pre">val)</span></code> where the
passed value will be returned from the <code class="docutils literal notranslate"><span class="pre">yield</span></code> call to resume the
computation.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="p">(</span><span class="n">generator</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">yield</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">displayln</span><span class="w"> </span><span class="s2">&quot;step 1&quot;</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="n">yield</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">displayln</span><span class="w"> </span><span class="s2">&quot;step 2&quot;</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="n">yield</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">displayln</span><span class="w"> </span><span class="s2">&quot;step 3&quot;</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="n">yield</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="w">              </span><span class="no">#f</span><span class="p">)))</span>
<span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="s2">&quot;one&quot;</span><span class="p">)</span>
<span class="n">step</span><span class="w"> </span><span class="mi">1</span>
<span class="mi">1</span>
<span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="s2">&quot;two&quot;</span><span class="p">)</span>
<span class="n">step</span><span class="w"> </span><span class="mi">2</span>
<span class="mi">2</span>
<span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="s2">&quot;three&quot;</span><span class="p">)</span>
<span class="n">step</span><span class="w"> </span><span class="mi">3</span>
<span class="mi">3</span>
<span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="s2">&quot;four&quot;</span><span class="p">)</span>
<span class="no">#f</span>
</pre></div>
</div>
<p>In python, the <code class="docutils literal notranslate"><span class="pre">StopIteration</span></code> exception is merely a convention used to
temrinate sequences produced by generators. We can choose any such convention
ourselves.</p>
<p>From the above example with <code class="docutils literal notranslate"><span class="pre">generator</span></code>, a few observations can be made –</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">generator</span></code> returns a λ function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(yield</span> <span class="pre">1)</span></code> is “returning” to the exit point of <code class="docutils literal notranslate"><span class="pre">(g</span> <span class="pre">&quot;one&quot;)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(g</span> <span class="pre">&quot;two&quot;)</span></code> is “returning” to the exit point of <code class="docutils literal notranslate"><span class="pre">(yield</span> <span class="pre">1)</span></code> within the
generator λ.</p></li>
</ol>
<p>Based on those, the implementation would look something like this –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">generator</span><span class="w"> </span><span class="n">fn</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">return</span><span class="w"> </span><span class="n">val</span><span class="p">)</span>
<span class="w">        </span><span class="c1">; Handles the final return from the generator</span>
<span class="w">        </span><span class="c1">; procedure</span>
<span class="w">        </span><span class="n">&lt;return-body-code&gt;</span>
<span class="w">        </span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">yield</span><span class="w"> </span><span class="n">val</span><span class="p">)</span>
<span class="w">        </span><span class="c1">; Handles yielding back to the generator&#39;s</span>
<span class="w">        </span><span class="c1">; call point.</span>
<span class="w">        </span><span class="n">&lt;yield-body-code&gt;</span>
<span class="w">        </span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">cont</span><span class="w"> </span><span class="no">#f</span><span class="p">)</span><span class="w"> </span><span class="c1">; Var to remember exit point of yield</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="no">#f</span><span class="p">)</span><span class="w">  </span><span class="c1">; Var to remember exit point of call to g.</span>
<span class="w">    </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="c1">; Because ``g`` takes a single argument</span>
<span class="w">      </span><span class="p">(</span><span class="k">let/cc</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="c1">; Because we need to remember the exit point</span>
<span class="w">                </span><span class="c1">; of each call to ``g``.</span>
<span class="w">        </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w">    </span><span class="c1">; Remember where the next yield should return to.</span>
<span class="w">        </span><span class="n">&lt;resume-code&gt;</span>
<span class="w">            </span><span class="c1">; Either continue by supplying the val to the exit</span>
<span class="w">            </span><span class="c1">; point of the last yield, or call the given function</span>
<span class="w">            </span><span class="c1">; to start the computation.</span>
<span class="w">            </span><span class="p">)</span>
</pre></div>
</div>
<p>We remembered the return point of a generator function (<code class="docutils literal notranslate"><span class="pre">g</span></code>)
in the variable named <code class="docutils literal notranslate"><span class="pre">ret</span></code>. So it is clear that <code class="docutils literal notranslate"><span class="pre">yield</span></code> must return
to that point. Furthermore, yield must remember where the generator
function must continue to when it is called, putting those two together,
we see that the implementation of <code class="docutils literal notranslate"><span class="pre">yield</span></code> must be like this –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">yield</span><span class="w"> </span><span class="n">val</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">let/cc</span><span class="w"> </span><span class="n">c</span>
<span class="w">        </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="n">cont</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="c1">; Remember where to continue.</span>
<span class="w">        </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="n">val</span><span class="p">)))</span>
</pre></div>
</div>
<p>Within the generator function, we need to first find out whether the
<code class="docutils literal notranslate"><span class="pre">fn</span></code> function was called at all (and hit a <code class="docutils literal notranslate"><span class="pre">yield</span></code> point) in order
to decide what to do. If <code class="docutils literal notranslate"><span class="pre">cont</span></code> is <code class="docutils literal notranslate"><span class="pre">#f</span></code>, it means the function
wasn’t called, since it would’ve hit a <code class="docutils literal notranslate"><span class="pre">yield</span></code> call which would’ve
modified <code class="docutils literal notranslate"><span class="pre">cont</span></code> to be a procedure. So we see that the <code class="docutils literal notranslate"><span class="pre">&lt;resume-code&gt;</span></code>
part needs to be –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">cont</span>
<span class="w">    </span><span class="p">(</span><span class="n">cont</span><span class="w"> </span><span class="n">val</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">fn</span><span class="w"> </span><span class="n">yield</span><span class="p">)))</span><span class="w"> </span><span class="c1">; Starts the function going.</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">return</span></code> function is similar to <code class="docutils literal notranslate"><span class="pre">yield</span></code>, but must set things
up so that it would be an error to continue to call the generator function
after its completion.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">return</span><span class="w"> </span><span class="n">val</span><span class="p">)</span>
<span class="w">    </span><span class="c1">; By setting cont to be an error generating procedure,</span>
<span class="w">    </span><span class="c1">; we prevent any further jumps into the function ``fn``.</span>
<span class="w">    </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="n">cont</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="w">                  </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s2">&quot;End of generator function&quot;</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="n">val</span><span class="p">))</span>
</pre></div>
</div>
<p>Putting it all together, we have –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">generator</span><span class="w"> </span><span class="n">fn</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">yield</span><span class="w"> </span><span class="n">val</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">let/cc</span><span class="w"> </span><span class="n">exit-point-of-yield-call</span>
<span class="w">            </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="n">cont</span><span class="w"> </span><span class="n">exit-point-of-yield-call</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="n">val</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">return</span><span class="w"> </span><span class="n">val</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="n">cont</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s2">&quot;End of generator function&quot;</span><span class="p">)))</span>
<span class="w">        </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="n">val</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">cont</span><span class="w"> </span><span class="no">#f</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="no">#f</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">let/cc</span><span class="w"> </span><span class="n">exit-point-of-g-call</span>
<span class="w">            </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="n">exit-point-of-g-call</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">cont</span>
<span class="w">                </span><span class="p">(</span><span class="n">cont</span><span class="w"> </span><span class="n">val</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">fn</span><span class="w"> </span><span class="n">yield</span><span class="p">))))))</span>
</pre></div>
</div>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Test out <code class="docutils literal notranslate"><span class="pre">generator</span></code> using the example above.</p>
</div>
</section>
<section id="differences-from-python-s-generators">
<h2>Differences from Python’s generators<a class="headerlink" href="#differences-from-python-s-generators" title="Link to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">yield</span></code> is a reserved word in Python whereas the <code class="docutils literal notranslate"><span class="pre">yield</span></code> argument
in our generator implementation is an ordinary first class function.
Therefore <code class="docutils literal notranslate"><span class="pre">(map</span> <span class="pre">yield</span> <span class="pre">(list</span> <span class="pre">1</span> <span class="pre">2</span> <span class="pre">3))</span></code> is value whereas that is
not possible with Python’s <code class="docutils literal notranslate"><span class="pre">yield</span></code> keyword.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(yield</span> <span class="pre">x)</span></code> looks and behaves like a normal function call.
Python’s yield is a statement when written like <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">val</span></code>
and an expression that can be resumed with a value when written
as <code class="docutils literal notranslate"><span class="pre">(yield</span> <span class="pre">val)</span></code> (here the parentheses stand for grouping, so
it is the same as <code class="docutils literal notranslate"><span class="pre">((yield</span> <span class="pre">val))</span></code>).</p></li>
<li><p>When the generator function in Python completes with a return, it
can no longer be jumped into and it will indicate that with a <code class="docutils literal notranslate"><span class="pre">StopIteration</span></code>
exception. In our case, we can choose our own protocol on how to
finish it .. either by using a known sentinel value or by raising
an error like Python does.</p></li>
<li><p>Python embeds its generator capabilities into constructs like
list comprehension and for loops. We haven’t done anything like
that with our generators … yet, but we can of course use the
same protocol to implement similar behaviours.</p></li>
</ol>
</section>
<section id="uses-for-generators">
<h2>Uses for generators<a class="headerlink" href="#uses-for-generators" title="Link to this heading">¶</a></h2>
<p>The ability to pause and resume computation that lexically looks like a single
sequence of operations is a valuable design tool in organizing many kinds of
systems.</p>
<section id="async-await">
<h3>Async/Await<a class="headerlink" href="#async-await" title="Link to this heading">¶</a></h3>
<p>In particular, this is useful when considering event loops that service browser
interfaces or server-side programs. Of late, this mechanism is usually
presented in languages using the keywords <code class="docutils literal notranslate"><span class="pre">async</span></code> and <code class="docutils literal notranslate"><span class="pre">await</span></code>, where
<code class="docutils literal notranslate"><span class="pre">async</span></code> marks a function for such asynchronous processing (analogous to
<code class="docutils literal notranslate"><span class="pre">generator</span></code> in our case) and <code class="docutils literal notranslate"><span class="pre">await</span></code> performs the equivalent of <code class="docutils literal notranslate"><span class="pre">yield</span></code>,
but returns control to the event loop instead.</p>
<p>In Javascript, for example, an object called a <code class="docutils literal notranslate"><span class="pre">Promise</span></code> plays the role
of capturing a computation that “promises” to produce a value in the future.
Such a promise is constructed like this –</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="ow">new</span><span class="w"> </span><span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="w"> </span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="w"> </span><span class="nx">reject</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">....</span><span class="w"> </span><span class="nx">code</span><span class="w"> </span><span class="p">...</span>
<span class="w">    </span><span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span><span class="w"> </span><span class="c1">// When the computation completed successfully.</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="nx">reject</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span><span class="w"> </span><span class="c1">// When it completes with an error.</span>
<span class="p">})</span>
</pre></div>
</div>
<div class="admonition-notice admonition">
<p class="admonition-title"><strong>Notice</strong></p>
<p>Do you notice the similarity between the way <code class="docutils literal notranslate"><span class="pre">Promise</span></code> is structured
and our <code class="docutils literal notranslate"><span class="pre">generator</span></code> function? While somewhat similar, they’re also
different in that <code class="docutils literal notranslate"><span class="pre">yield</span></code> can be used multiple times whereas <code class="docutils literal notranslate"><span class="pre">resolve</span></code>
and <code class="docutils literal notranslate"><span class="pre">reject</span></code> can only be called once.</p>
</div>
<p>The form <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">&lt;expr&gt;</span></code> then expects <code class="docutils literal notranslate"><span class="pre">&lt;expr&gt;</span></code> to provide a <code class="docutils literal notranslate"><span class="pre">Promise</span></code>
object and waits for it to complete, returning the value passed to <code class="docutils literal notranslate"><span class="pre">resolve</span></code>,
or raising as error the value passed to <code class="docutils literal notranslate"><span class="pre">reject</span></code>.</p>
<p>Thus, <code class="docutils literal notranslate"><span class="pre">async</span></code>/<code class="docutils literal notranslate"><span class="pre">await</span></code> in javascript desugars to generators that coordinate
using <code class="docutils literal notranslate"><span class="pre">Promise</span></code> objects. The situation is similar in other language which may
use slightly different terminology – for example <code class="docutils literal notranslate"><span class="pre">Future</span></code> may be used
instead of <code class="docutils literal notranslate"><span class="pre">Promise</span></code>.</p>
</section>
<section id="search">
<h3>Search<a class="headerlink" href="#search" title="Link to this heading">¶</a></h3>
<p>Generators are useful to structure computations where values need to be
produced “lazily”, for example, to explore search spaces. A variable
that is permitted to take on a number of values according to some known
constraints can be treated as a generator for those values, permitting
the exploration of a search space across a number of such variables.</p>
<p>One way to see this is to think of generators as sequences in the same footing
as lists. “List of X” can for many such search/explore applications be
re-presented as “Generator of X” without incurring the storage costs of lists.
Common operations on lists such as <code class="docutils literal notranslate"><span class="pre">map</span></code> and <code class="docutils literal notranslate"><span class="pre">filter</span></code> translate well
to generators as well. Much as mapping over a list produces another list,
mapping over a generator produces another generator. And so is the case
with filtering.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">g-map</span><span class="w"> </span><span class="n">fn</span><span class="w"> </span><span class="n">g</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">generator</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">yield</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="n">loop</span><span class="w"> </span><span class="p">([</span><span class="n">v</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="no">#f</span><span class="p">)])</span>
<span class="w">            </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="n">v</span>
<span class="w">                </span><span class="p">(</span><span class="k">begin</span><span class="w"> </span><span class="p">(</span><span class="n">yield</span><span class="w"> </span><span class="p">(</span><span class="n">fn</span><span class="w"> </span><span class="n">v</span><span class="p">))</span>
<span class="w">                       </span><span class="p">(</span><span class="n">loop</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="no">#f</span><span class="p">))))</span>
<span class="w">            </span><span class="no">#f</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">g-filter</span><span class="w"> </span><span class="n">fn</span><span class="w"> </span><span class="n">g</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">generator</span><span class="w"> </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">yield</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="n">loop</span><span class="w"> </span><span class="p">([</span><span class="n">v</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="no">#f</span><span class="p">)])</span>
<span class="w">            </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="n">v</span>
<span class="w">                </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="n">fn</span><span class="w"> </span><span class="n">v</span><span class="p">)</span>
<span class="w">                    </span><span class="p">(</span><span class="n">yield</span><span class="w"> </span><span class="n">v</span><span class="p">))</span>
<span class="w">                </span><span class="p">(</span><span class="n">loop</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="no">#f</span><span class="p">)))</span>
<span class="w">            </span><span class="no">#f</span><span class="p">))))</span>
</pre></div>
</div>
<p>In the above code, we’ve used the simple protocol that when a
generator produces <code class="docutils literal notranslate"><span class="pre">#f</span></code>, it means it’s completed and no further
calls are possible.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Comp308: Principles of Programming Languages</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Welcome note</a></li>
<li class="toctree-l1"><a class="reference internal" href="racket-intro.html">A quick introduction to Racket and Scheme</a></li>
<li class="toctree-l1"><a class="reference internal" href="lambda.html">λ - the everything</a></li>
<li class="toctree-l1"><a class="reference internal" href="church.html">Lambda - via β-abstraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="piclang.html">A language for pictures</a></li>
<li class="toctree-l1"><a class="reference internal" href="arithlang.html">A language for arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine.html">A mental model for the machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="notional-machine.html">Notional machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="growing.html">Growing the language</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun.html">Functions and scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun-arith.html">Functions and scope (arithmetic track)</a></li>
<li class="toctree-l1"><a class="reference internal" href="stacks-and-scope.html">Stacks and scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun-in-piclang.html">Functions in PicLang</a></li>
<li class="toctree-l1"><a class="reference internal" href="mutations.html">Mutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="control.html">Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="errornot.html">On the choice between “error” and “do something reasonable” in design</a></li>
<li class="toctree-l1"><a class="reference internal" href="objects.html">Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="objects-self.html">Objects - the Self way</a></li>
<li class="toctree-l1"><a class="reference internal" href="dispatch.html">Polymorphism via dispatch</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Generators</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#seeing-continuations-through-abstraction">Seeing continuations through β-abstraction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#delimited-continuations">Delimited continuations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#call-cc-and-let-cc"><code class="code highlight racket docutils literal highlight-racket"><span class="nb">call/cc</span></code> and <code class="code highlight racket docutils literal highlight-racket"><span class="k">let/cc</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#super-power-time-generators">Super power time - generators</a></li>
<li class="toctree-l2"><a class="reference internal" href="#differences-from-python-s-generators">Differences from Python’s generators</a></li>
<li class="toctree-l2"><a class="reference internal" href="#uses-for-generators">Uses for generators</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="appsem.html">Alternative application semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html">Types: Checking some program invariants statically</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="dispatch.html" title="previous chapter">Polymorphism via dispatch</a></li>
      <li>Next: <a href="appsem.html" title="next chapter">Alternative application semantics</a></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2022, Srikumar K. S..
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="_sources/generators.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>