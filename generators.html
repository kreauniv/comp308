
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Generators &#8212; Comp308: Principles of Programming Languages v1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Alternative application semantics" href="appsem.html" />
    <link rel="prev" title="Objects" href="objects.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="generators">
<h1>Generators<a class="headerlink" href="#generators" title="Permalink to this headline">¶</a></h1>
<p>In <a class="reference internal" href="control.html"><span class="doc">Control</span></a>, we implemented a rudimentary way to define and work with
generators in our small stack-based language. In this section, we’ll see how
Racket provides us with full continuations that can be used for this purpose.</p>
<div class="section" id="call-cc-and-let-cc">
<h2><code class="code highlight racket docutils literal notranslate"><span class="name builtin"><span class="pre">call/cc</span></span></code> and <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">let/cc</span></span></code><a class="headerlink" href="#call-cc-and-let-cc" title="Permalink to this headline">¶</a></h2>
<p>When working with our now-familiar “distance” function, <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">sqrt</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">+</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">*</span></span> <span class="name"><span class="pre">dx</span></span> <span class="name"><span class="pre">dx</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">*</span></span> <span class="name"><span class="pre">dy</span></span> <span class="name"><span class="pre">dy</span></span><span class="punctuation"><span class="pre">)))</span></span></code>,
we saw how we can get “the rest of the computation that’s supposed to happen after <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">*</span></span> <span class="name"><span class="pre">dx</span></span> <span class="name"><span class="pre">dx</span></span><span class="punctuation"><span class="pre">)</span></span></code>”
by β-abstracting over <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">*</span></span> <span class="name"><span class="pre">dx</span></span> <span class="name"><span class="pre">dx</span></span><span class="punctuation"><span class="pre">)</span></span></code> to get <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="keyword"><span class="pre">λ</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">dx2</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">sqrt</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">+</span></span> <span class="name"><span class="pre">dx2</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">*</span></span> <span class="name"><span class="pre">dy</span></span> <span class="name"><span class="pre">dy</span></span><span class="punctuation"><span class="pre">))))</span></span></code>. Racket/Scheme
provide access to this function for us. We just have to ask!</p>
<div class="admonition-terminology admonition">
<p class="admonition-title"><strong>Terminology</strong></p>
<p>The function that represents “the rest of the computation” at any given evaluation point
(i.e. sub-expression) is called the <strong>current continuation</strong> at that point. This function
will differ depending on which sub-expression is under consideration, since what remains
to be done will differ.</p>
</div>
<p>In the “distance” expression, to get access to the current continuation at the
time we’re evaluating the <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">*</span></span> <span class="name"><span class="pre">dx</span></span> <span class="name"><span class="pre">dx</span></span><span class="punctuation"><span class="pre">)</span></span></code> (note that the language talks about
the <strong>dynamic</strong> state of the program, not its lexical structure) can be obtained
using <code class="code highlight racket docutils literal notranslate"><span class="name builtin"><span class="pre">call/cc</span></span></code> (read as “call with current continuation”) like this –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">call/cc</span> <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">(</span><span class="n">k</span> <span class="p">(</span><span class="nb">*</span> <span class="n">dx</span> <span class="n">dx</span><span class="p">))))</span> <span class="p">(</span><span class="nb">*</span> <span class="n">dy</span> <span class="n">dy</span><span class="p">)))</span>
</pre></div>
</div>
<p>The entire <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">call/cc</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="keyword"><span class="pre">λ</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">k</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">k</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">*</span></span> <span class="name"><span class="pre">dx</span></span> <span class="name"><span class="pre">dx</span></span><span class="punctuation"><span class="pre">))))</span></span></code> is simply equivalent to <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">*</span></span> <span class="name"><span class="pre">dx</span></span> <span class="name"><span class="pre">dx</span></span><span class="punctuation"><span class="pre">)</span></span></code>.</p>
<p>One way to understand this is to think of the <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">k</span></span></code> continuation as labeling
the dynamic return point of the <code class="code highlight racket docutils literal notranslate"><span class="name builtin"><span class="pre">call/cc</span></span></code> invocation that is providing it.
So call <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">k</span></span></code> with some value will result in the entire <code class="code highlight racket docutils literal notranslate"><span class="name builtin"><span class="pre">call/cc</span></span></code>
expression that provided that <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">k</span></span></code> completing its computation with the
value as its result. In the above code, we’re supplying <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">*</span></span> <span class="name"><span class="pre">dx</span></span> <span class="name"><span class="pre">dx</span></span><span class="punctuation"><span class="pre">)</span></span></code> to
<code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">k</span></span></code>, and so the whole <code class="code highlight racket docutils literal notranslate"><span class="name builtin"><span class="pre">call/cc</span></span></code> expression is equivalent to <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">*</span></span>
<span class="name"><span class="pre">dx</span></span> <span class="name"><span class="pre">dx</span></span><span class="punctuation"><span class="pre">)</span></span></code>. So you could think of it as <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">call/cc</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="keyword"><span class="pre">λ</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">return</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">return</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">*</span></span> <span class="name"><span class="pre">dx</span></span>
<span class="name"><span class="pre">dx</span></span><span class="punctuation"><span class="pre">))))</span></span></code> and that would be correct.</p>
<p>It can get quite cumbersome to write lambdas every time we use <code class="code highlight racket docutils literal notranslate"><span class="name builtin"><span class="pre">call/cc</span></span></code>, so
Racket/Scheme provides some syntactic sugar for it – <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">let/cc</span></span></code> that is convenient.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let/cc</span> <span class="n">k</span> <span class="n">...some-expression-using-k...</span><span class="p">)</span>
<span class="c1">; desugars into</span>
<span class="p">(</span><span class="nb">call/cc</span> <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="n">..some-expression-using-k...</span><span class="p">))</span>
</pre></div>
</div>
<p>i.e., <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">let/cc</span></span></code> introduces the local variable <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">k</span></span></code> into the expression
much like <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">let</span></span></code>.</p>
<p>You could ask “so what?”. Having access to the current continuation as a value
gives us many super powers – we can implement many different types of control
flow within our program with this as a primitive. For example, since the
continuation is available as a value, we can store it away to be called later
on. This is what we need to implement generators.</p>
</div>
<div class="section" id="python-generators">
<h2>Python generators<a class="headerlink" href="#python-generators" title="Permalink to this headline">¶</a></h2>
<p>In python, you can return from a function in two ways –</p>
<ol class="arabic simple">
<li><p>Using the <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">&lt;value&gt;</span></code> statement.</p></li>
<li><p>Using the <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">&lt;value&gt;</span></code> statement.</p></li>
</ol>
<p>While <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">return</span></span></code> finishes the calculations that the function was doing, <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">yield</span></span></code>
merely suspends it at that state. It means you can resume from that dynamic point
and continue on to the next <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">yield</span></span></code>. While all code that follows <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">return</span></span></code>
is dead code, you can have multiple <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">yield</span></span></code> statements in the code and the function
will suspend every time it encounters such a <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">yield</span></span></code>.</p>
<p>A function that uses <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">yield</span></span></code> is called a “generator” in python. Similar
constructs in other languages may be called “co-routines” or “asynchronous
functions” when combined with event loops. Though some subtle differences exist
between these various presentations exist, they’re all basically the same idea
underneath – the idea of “reified continuations”. The word “reified” in CS is
used to mean “made real” – i.e. made into a value that can be used like a
value.</p>
<p>Consider the following code sequence.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">silly_gen</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Generating &#39;one&#39;&quot;</span><span class="p">);</span>
    <span class="k">yield</span> <span class="s2">&quot;one&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Generating &#39;two&#39;&quot;</span><span class="p">);</span>
    <span class="k">yield</span> <span class="s2">&quot;two&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Generating 3&quot;</span><span class="p">);</span>
    <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Generating 4&quot;</span><span class="p">);</span>
    <span class="k">yield</span> <span class="mi">4</span><span class="p">;</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">silly_gen</span><span class="p">();</span> <span class="c1"># Prints nothing</span>
<span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="c1">#&gt; Generating &#39;one&#39;</span>
<span class="c1">#&gt; &#39;one&#39;</span>
<span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="c1">#&gt; Generating &#39;two&#39;</span>
<span class="c1">#&gt; &#39;two&#39;</span>
<span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="c1">#&gt; Generating 3</span>
<span class="c1">#&gt; 3</span>
<span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="c1">#&gt; Generating 4</span>
<span class="c1">#&gt; 4</span>
<span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="c1">#&gt; Traceback (most recent call last):</span>
<span class="c1">#&gt; File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="c1">#&gt; StopIteration</span>
<span class="c1">#</span>
<span class="c1"># (This last bit could differ depending on where you run this code)</span>
</pre></div>
</div>
<p>What’s happening there?</p>
<ol class="arabic simple">
<li><p>With the first call to <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">silly_gen</span></span><span class="punctuation"><span class="pre">()</span></span></code>, we create a “generator object” that
can suspend and resume computations. No computation has actually started just yet though,
as noted by “Generating ‘one’” not being printed at that point.</p></li>
<li><p>Every time we cann <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">next</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">g</span></span><span class="punctuation"><span class="pre">)</span></span></code>, we resume the generator and cause it to
run until the next <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">yield</span></span></code>. The return value of the <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">next</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">g</span></span><span class="punctuation"><span class="pre">)</span></span></code> call
is what was given as the value in <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">yield</span></span> <span class="name"><span class="pre">&lt;value&gt;</span></span></code>.</p></li>
<li><p>Once we run out of yields, python arranges to terminate the code by raising
an exception named <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">StopIteration</span></span></code>.</p></li>
</ol>
<p>We’ll now see how to implement that in Racket. The idea is that in any language
that gives us the equivalent of <code class="code highlight racket docutils literal notranslate"><span class="name builtin"><span class="pre">call/cc</span></span></code> (like our stack language to which
we gave that power in <a class="reference internal" href="control.html"><span class="doc">Control</span></a>), we can follow the same thinking. What we
won’t do here is to develop generator <strong>syntax</strong> in Racket. We’ll merely show how
to mechanically produce generator-like behaviour. Once you learn how to define
your own syntax in Racket, it then becomes a simple matter to mechanically translate
generator code to produce the necessary constructs.</p>
</div>
<div class="section" id="generators-in-racket">
<h2>Generators in Racket<a class="headerlink" href="#generators-in-racket" title="Permalink to this headline">¶</a></h2>
<p>We want to be able to write something like this –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">generator</span> <span class="p">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span>
    <span class="p">(</span><span class="n">yield</span> <span class="s2">&quot;one&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="n">yield</span> <span class="s2">&quot;two&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="n">yield</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">(</span><span class="n">yield</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p>… as a parallel to the python code.</p>
<p>Let’s start with treating the generator as an ordinary lambda –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">gen</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let/cc</span> <span class="n">return</span>
       <span class="c1">;...</span>
       <span class="p">))</span>
</pre></div>
</div>
<p>The <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">return</span></span></code> captures the dynamic continuation point at the point of call
of <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">gen</span></span><span class="punctuation"><span class="pre">)</span></span></code>. We will need to return something to that point to help
control the progress of the generator. What could the “yield” point look like?</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">gen</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let/cc</span> <span class="n">return</span>
        <span class="c1">;...</span>
        <span class="p">(</span><span class="k">let/cc</span> <span class="n">resume</span> <span class="p">(</span><span class="n">yield</span> <span class="p">(</span><span class="nb">list</span> <span class="s2">&quot;one&quot;</span> <span class="n">resume</span><span class="p">)))</span>
        <span class="p">))</span>
</pre></div>
</div>
<p>The “list of two values” is a placeholder mechanism to pass on the resume point to the
point at which <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">next</span></span></code> call is happening. We’re yet to determine the <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">yield</span></span></code> though.
What should <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">yield</span></span></code> be? If we treat it as a function that doesn’t return to the point
(unless resumed), we can see that it is essentially a continuation. What continuation is it
though?</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Think about it for a bit and see if you can answer it.</p>
</div>
<p>The yield continuation is expected to come from the caller’s dynamic call
point. So we need a mechanism for the caller to pass their continuation into
the generator so it can yield contro back to that call point when it wants to
pause.</p>
<p>We therefore see that there are two bits of shared state information we need to
have for each generator instance – one channel passes a resume continuation
from the generator to the caller and another channel passes a yield
continuation from the caller into the generator. Let’s use a box for each of these.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">gen</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let/cc</span> <span class="n">return</span>
        <span class="p">(</span><span class="k">define</span> <span class="n">yield-box</span> <span class="p">(</span><span class="nb">box</span> <span class="no">#f</span><span class="p">))</span>
        <span class="p">(</span><span class="k">define</span> <span class="n">resume-box</span> <span class="p">(</span><span class="nb">box</span> <span class="no">#f</span><span class="p">))</span>
        <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">yield</span> <span class="n">val</span><span class="p">)</span> <span class="p">((</span><span class="nb">unbox</span> <span class="n">yield-box</span><span class="p">)</span> <span class="n">val</span><span class="p">))</span>
        <span class="c1">;...</span>
        <span class="p">))</span>
</pre></div>
</div>
<p>… but we want “yield” to also enable resumption. For that we can roll the
<code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">let/cc</span></span> <span class="name"><span class="pre">resume</span></span></code> into the yield and put that continuation into the
<code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">resume-box</span></span></code>.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">gen</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let/cc</span> <span class="n">return</span>
        <span class="p">(</span><span class="k">define</span> <span class="n">yield-box</span> <span class="p">(</span><span class="nb">box</span> <span class="n">return</span><span class="p">))</span>
        <span class="p">(</span><span class="k">define</span> <span class="n">resume-box</span> <span class="p">(</span><span class="nb">box</span> <span class="no">#f</span><span class="p">))</span>
        <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">yield</span> <span class="n">val</span><span class="p">)</span>
            <span class="c1">; Mark the point where we want the code that calls &quot;next&quot;</span>
            <span class="c1">; to resume from.</span>
            <span class="p">(</span><span class="k">let/cc</span> <span class="n">resume</span>
                <span class="c1">; Store this resume point in the resume-box accessible to</span>
                <span class="c1">; the generator user.</span>
                <span class="p">(</span><span class="nb">set-box!</span> <span class="n">resume-box</span> <span class="n">resume</span><span class="p">)</span>
                <span class="c1">; Return to the caller at the marked yield point provided by</span>
                <span class="c1">; the caller. In the very first instance, this will return to</span>
                <span class="c1">; the point where the generator is being created by calling</span>
                <span class="c1">; (gen). In that case alone, we pass the caller both the</span>
                <span class="c1">; yield-box and resume-box.</span>
                <span class="p">((</span><span class="nb">unbox</span> <span class="n">yield-box</span><span class="p">)</span> <span class="n">val</span><span class="p">)))</span>
        <span class="p">(</span><span class="n">yield</span> <span class="p">(</span><span class="nb">list</span> <span class="n">yield-box</span> <span class="n">resume-box</span><span class="p">))</span> <span class="c1">; Pass the channels to the caller at</span>
                                             <span class="c1">; the generator creation point.</span>

        <span class="c1">; Ordinary generator code using yield like a function.</span>
        <span class="c1">; ...</span>
        <span class="p">(</span><span class="n">yield</span> <span class="s2">&quot;one&quot;</span><span class="p">)</span>
        <span class="c1">; ...</span>
        <span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="n">g</span> <span class="p">(</span><span class="n">gen</span><span class="p">))</span>
<span class="c1">; g is now a list of yield-box and resume-box</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">next</span> <span class="n">g</span> <span class="n">val</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let/cc</span> <span class="n">yield</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">yield-box</span> <span class="p">(</span><span class="nb">first</span> <span class="n">g</span><span class="p">)]</span>
              <span class="p">[</span><span class="n">resume-box</span> <span class="p">(</span><span class="nb">second</span> <span class="n">g</span><span class="p">)])</span>
            <span class="p">(</span><span class="nb">set-box!</span> <span class="n">yield-box</span> <span class="n">yield</span><span class="p">)</span>
            <span class="p">((</span><span class="nb">unbox</span> <span class="n">resume-box</span><span class="p">)</span> <span class="n">val</span><span class="p">))))</span>


<span class="p">(</span><span class="n">next</span> <span class="n">g</span> <span class="no">#f</span><span class="p">)</span> <span class="c1">; The value is currently unused, but could be used if needed.</span>
            <span class="c1">; As much as the generator is capable of passing a value back</span>
            <span class="c1">; to the caller, the caller can also pass values back into the</span>
            <span class="c1">; generator which will become the result of the (yield ..)</span>
            <span class="c1">; expression.</span>
</pre></div>
</div>
<p>Notice how the beginning part of the generator is completely independent of what the
generator actually does – i.e. it is “boiler plate code” that can be auto generated.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Try out the above version of the generator on your own. Explore what’s
possible with this. In particular explore the idea of the yield function
itself being a first class value in our scheme of things. This is <strong>more</strong>
powerful than Python generators where <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">yield</span></span></code> is a keyword and not
a value that can be passed out. In our case, for example, you can pass this
yield funciton down as arguments to other functions as well.</p>
</div>
<p>Let’s see if we can absorb the boiler plate code into a reusable function.
Given we’re representing the generator state as a pair of boxes that contain
continuations, we can start there and model our generator as a lambda that
takes an extra parameter as its first argument, called <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">yield</span></span></code>.</p>
<p>i.e. we want to write our generator as –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">yield</span> <span class="n">arg1</span> <span class="n">arg2</span> <span class="k">...</span><span class="p">)</span>
    <span class="c1">;...</span>
    <span class="p">(</span><span class="n">yield</span> <span class="n">val</span><span class="p">)</span>
    <span class="c1">;...</span>
    <span class="p">(</span><span class="n">yield</span> <span class="n">val</span><span class="p">)</span>
    <span class="c1">;...</span>
    <span class="p">)</span>
</pre></div>
</div>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">generator</span> <span class="n">genfn</span> <span class="o">.</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let/cc</span> <span class="n">return</span>
        <span class="p">(</span><span class="k">define</span> <span class="n">yield-box</span> <span class="p">(</span><span class="nb">box</span> <span class="n">return</span><span class="p">))</span>
        <span class="p">(</span><span class="k">define</span> <span class="n">resume-box</span> <span class="p">(</span><span class="nb">box</span> <span class="no">#f</span><span class="p">))</span>
        <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">yield</span> <span class="n">val</span><span class="p">)</span>
            <span class="p">(</span><span class="k">let/cc</span> <span class="n">resume</span>
                <span class="p">(</span><span class="nb">set-box!</span> <span class="n">resume-box</span> <span class="n">resume</span><span class="p">)</span>
                <span class="p">((</span><span class="nb">unbox</span> <span class="n">yield-box</span><span class="p">)</span> <span class="n">val</span><span class="p">)))</span>
        <span class="c1">; Pass the generator state to the caller for use by &quot;next&quot;.</span>
        <span class="p">(</span><span class="n">yield</span> <span class="p">(</span><span class="nb">list</span> <span class="n">yield-box</span> <span class="n">resume-box</span><span class="p">))</span>
        <span class="c1">; Call the generator function with our newly minted &quot;yield&quot; function</span>
        <span class="c1">; as the first argument.</span>
        <span class="p">(</span><span class="nb">apply</span> <span class="n">genfn</span> <span class="p">(</span><span class="nb">cons</span> <span class="n">yield</span> <span class="n">args</span><span class="p">))))</span>
</pre></div>
</div>
<p>Now, we can easily write the above python code like this –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">g</span> <span class="p">(</span><span class="n">generator</span> <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="n">yield</span><span class="p">)</span> <span class="p">(</span><span class="nb">map</span> <span class="n">yield</span> <span class="o">&#39;</span><span class="p">(</span><span class="s2">&quot;one&quot;</span> <span class="s2">&quot;two&quot;</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)))))</span>
<span class="c1">; Note that we can&#39;t map the yield function like this in Python</span>
<span class="c1">; because in Python yield is not a function or a value that works</span>
<span class="c1">; as one.</span>
<span class="p">(</span><span class="n">next</span> <span class="n">g</span> <span class="no">#f</span><span class="p">)</span>
<span class="p">(</span><span class="n">next</span> <span class="n">g</span> <span class="no">#f</span><span class="p">)</span>
<span class="p">(</span><span class="n">next</span> <span class="n">g</span> <span class="no">#f</span><span class="p">)</span>
<span class="p">(</span><span class="n">next</span> <span class="n">g</span> <span class="no">#f</span><span class="p">)</span>
</pre></div>
</div>
<p>You can also make <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">generator</span></span></code> a bit more convenient to use by
uncurrying the <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">args</span></span></code>.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">generator</span> <span class="n">genfn</span><span class="p">)</span>
    <span class="p">(</span><span class="k">lambda</span> <span class="n">args</span>
        <span class="p">(</span><span class="k">let/cc</span> <span class="n">return</span>
            <span class="p">(</span><span class="k">define</span> <span class="n">yield-box</span> <span class="p">(</span><span class="nb">box</span> <span class="n">return</span><span class="p">))</span>
            <span class="p">(</span><span class="k">define</span> <span class="n">resume-box</span> <span class="p">(</span><span class="nb">box</span> <span class="no">#f</span><span class="p">))</span>
            <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">yield</span> <span class="n">val</span><span class="p">)</span>
                <span class="p">(</span><span class="k">let/cc</span> <span class="n">resume</span>
                    <span class="p">(</span><span class="nb">set-box!</span> <span class="n">resume-box</span> <span class="n">resume</span><span class="p">)</span>
                    <span class="p">((</span><span class="nb">unbox</span> <span class="n">yield-box</span><span class="p">)</span> <span class="n">val</span><span class="p">)))</span>
            <span class="c1">; Pass the generator state to the caller for use by &quot;next&quot;.</span>
            <span class="p">(</span><span class="n">yield</span> <span class="p">(</span><span class="nb">list</span> <span class="n">yield-box</span> <span class="n">resume-box</span><span class="p">))</span>
            <span class="c1">; Call the generator function with our newly minted &quot;yield&quot; function</span>
            <span class="c1">; as the first argument.</span>
            <span class="p">(</span><span class="nb">apply</span> <span class="n">genfn</span> <span class="p">(</span><span class="nb">cons</span> <span class="n">yield</span> <span class="n">args</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define</span> <span class="n">gen</span> <span class="p">(</span><span class="n">generator</span> <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="n">yield</span> <span class="o">.</span> <span class="n">args</span><span class="p">)</span> <span class="p">(</span><span class="nb">for-each</span> <span class="n">yield</span> <span class="o">&#39;</span><span class="p">(</span><span class="s2">&quot;one&quot;</span> <span class="s2">&quot;two&quot;</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)))))</span>
<span class="c1">; With this form, the function `generator` works like a word that</span>
<span class="c1">; declares the given lambda function to be a generator. You can then call</span>
<span class="c1">; the produced functions to make make independently evolving generator instances.</span>

<span class="p">(</span><span class="k">define</span> <span class="n">g</span> <span class="p">(</span><span class="n">gen</span><span class="p">))</span>
<span class="p">(</span><span class="n">next</span> <span class="n">g</span> <span class="no">#f</span><span class="p">)</span>
<span class="c1">;...</span>
</pre></div>
</div>
<p>Enjoy … and the journey always continues on!</p>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Notice that if you call <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">next</span></span></code> one too many a time, you get an error.
How can you arrange for the generator to finish its calculations
gracefully?</p>
<p><strong>Hint</strong>: Attend to where the result expression of the genfn is returning
its value to. Where should it return to? .. and what can it possibly return
to signal the end?</p>
</div>
</div>
<div class="section" id="search-as-a-language-feature">
<h2>Search as a language feature<a class="headerlink" href="#search-as-a-language-feature" title="Permalink to this headline">¶</a></h2>
<p>Many popular languages today have a language feature usually going by the name
“set comprehension”, “list comprehension”, “array comprehension” or “dictionary
comprehension”. The essence of these constructs is nested for-loop iteration
where values are produced based on the for loop iterations which meet some
criteria expressed as a boolean constraint on the values being enumerated.</p>
<p>Generators are closely linked with comprehensions and languages like Julia even
make generators use the same syntax as comprehensions. So it is not unreasonable
to expect that the ideas we developed above can serve to explore a space of
variable values that need to meet some constraints. For example, let’s consider
a toy problem of finding pythagorean triplets.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pytriplets</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">==</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p>How can we model this kind of searching using our scheme of things. First off,
we need to realize that the inner-most for loop gets to run fully for each of
the outer for loops – i.e. the search is <strong>depth first</strong>. This kind of a
search can be modeled using a stack, where the top state of the stack captures
the state of the inner loop. Similar to what we did above, we will need
<code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">yield</span></span></code> to be modeled as “try to find one more case”.  One other point to
note here is that there is a role played by the “else” part of the if – it
tries the next possible set of values for x,y,z. We’ll model that instead of
yield directly, because with search, we’re interested in finding one solution
(at least for starters).</p>
<p>And what we’ll use here is a stack of continuations!</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">stack</span> <span class="p">(</span><span class="nb">box</span> <span class="nb">empty</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">push</span> <span class="n">val</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">set-box!</span> <span class="n">stack</span> <span class="p">(</span><span class="nb">cons</span> <span class="n">val</span> <span class="p">(</span><span class="nb">unbox</span> <span class="n">stack</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">pop</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">top</span> <span class="p">(</span><span class="nb">first</span> <span class="p">(</span><span class="nb">unbox</span> <span class="n">stack</span><span class="p">))])</span>
        <span class="p">(</span><span class="nb">set-box!</span> <span class="n">stack</span> <span class="p">(</span><span class="nb">rest</span> <span class="p">(</span><span class="nb">unbox</span> <span class="n">stack</span><span class="p">)))</span>
        <span class="n">top</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">try-again</span><span class="p">)</span>
    <span class="p">((</span><span class="n">pop</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">ensure</span> <span class="n">bool</span><span class="p">)</span>
    <span class="p">(</span><span class="k">when</span> <span class="p">(</span><span class="nb">not</span> <span class="n">bool</span><span class="p">)</span>
        <span class="p">(</span><span class="n">try-again</span><span class="p">)))</span>

<span class="c1">; range produces one value at a time. If you don&#39;t</span>
<span class="c1">; like it, you can call (try-again) to get another.</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">range</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let/cc</span> <span class="n">return</span>
        <span class="p">(</span><span class="k">let/cc</span> <span class="n">trynext</span>
            <span class="p">(</span><span class="n">push</span> <span class="n">trynext</span><span class="p">)</span>
            <span class="p">(</span><span class="n">return</span> <span class="n">m</span><span class="p">))</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">range</span> <span class="p">(</span><span class="nb">+</span> <span class="n">m</span> <span class="mi">1</span><span class="p">)</span> <span class="n">n</span><span class="p">)</span>
            <span class="p">(</span><span class="n">try-again</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">pytriplets</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">x</span> <span class="p">(</span><span class="nb">range</span> <span class="n">m</span> <span class="n">n</span><span class="p">)]</span>
          <span class="p">[</span><span class="n">y</span> <span class="p">(</span><span class="nb">range</span> <span class="n">m</span> <span class="n">n</span><span class="p">)]</span>
          <span class="p">[</span><span class="n">z</span> <span class="p">(</span><span class="nb">range</span> <span class="n">m</span> <span class="n">n</span><span class="p">)])</span>
        <span class="p">(</span><span class="n">ensure</span> <span class="p">(</span><span class="nb">equal?</span> <span class="p">(</span><span class="nb">*</span> <span class="n">z</span> <span class="n">z</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="n">x</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="n">y</span> <span class="n">y</span><span class="p">))))</span>
        <span class="p">(</span><span class="nb">list</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="p">)))</span>
</pre></div>
</div>
<p>Now, if you call, say, <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">pytriplets</span></span> <span class="literal number integer"><span class="pre">10</span></span> <span class="literal number integer"><span class="pre">50</span></span><span class="punctuation"><span class="pre">)</span></span></code>, it will return a list
of three numbers that form a triplet. If you’re not happy and want another,
you can invoke <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">try-again</span></span><span class="punctuation"><span class="pre">)</span></span></code> to get the next one.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="p">(</span><span class="n">pytriplets</span> <span class="mi">10</span> <span class="mi">50</span><span class="p">)</span>
<span class="s1">&#39;(10 24 26)</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="k">try</span><span class="o">-</span><span class="n">again</span><span class="p">)</span>
<span class="s1">&#39;(12 16 20)</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="k">try</span><span class="o">-</span><span class="n">again</span><span class="p">)</span>
<span class="s1">&#39;(12 35 37)</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="k">try</span><span class="o">-</span><span class="n">again</span><span class="p">)</span>
<span class="s1">&#39;(14 48 50)</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="k">try</span><span class="o">-</span><span class="n">again</span><span class="p">)</span>
<span class="s1">&#39;(15 20 25)</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="k">try</span><span class="o">-</span><span class="n">again</span><span class="p">)</span>
<span class="s1">&#39;(15 36 39)</span>
<span class="o">&gt;</span>
</pre></div>
</div>
<p>That was fun, wasn’t it?</p>
<div class="admonition-question admonition">
<p class="admonition-title"><strong>Question</strong></p>
<p>Notice that the next result isn’t being returned from the <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">try-again</span></span><span class="punctuation"><span class="pre">)</span></span></code>.
Why is that? Do you want to change that behaviour? If so, how would you?
Also, why is the result being printed out even though we aren’t writing it
out explicitly and are simply returning a list from <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">pytriplets</span></span></code>?</p>
</div>
<div class="admonition-terminology admonition">
<p class="admonition-title"><strong>Terminology</strong></p>
<p>This kind of behaviour is referred to as “non-determinism” in a language.
We know that the program is quite deterministic alright, but the reason the
term is used is that at the point where the <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">range</span></span> <span class="name"><span class="pre">m</span></span> <span class="name"><span class="pre">n</span></span><span class="punctuation"><span class="pre">)</span></span></code> function
call returns, the result could be any value in the range that meets
criteria that’s going to be specified <strong>later</strong> in the program. So at that
point, we don’t truly know what value it is going to produce.</p>
</div>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Write an <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">options</span></span></code> function similar to <code class="code highlight racket docutils literal notranslate"><span class="name builtin"><span class="pre">range</span></span></code> that behaves like
this – It takes any number of arguments and, just as range runs over integers
from the first arg to the second arg, steps through the arguments one by one.
In other words, <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">options</span></span></code> can return any one of its arguments, and the
value it returns can be decided by any constraints on the value that may appear
in the code after the <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">options</span></span></code> call.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">pytriplets</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">x</span> <span class="p">(</span><span class="n">options</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)]</span>
          <span class="p">[</span><span class="n">y</span> <span class="p">(</span><span class="n">options</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)]</span>
          <span class="p">[</span><span class="n">z</span> <span class="p">(</span><span class="n">options</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)])</span>
        <span class="p">(</span><span class="n">ensure</span> <span class="p">(</span><span class="nb">equal?</span> <span class="p">(</span><span class="nb">*</span> <span class="n">z</span> <span class="n">z</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="n">x</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="n">y</span> <span class="n">y</span><span class="p">))))</span>
        <span class="p">(</span><span class="nb">list</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="p">)))</span>
</pre></div>
</div>
<p>The above code should behave the same way as though <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">range</span></span> <span class="literal number integer"><span class="pre">2</span></span> <span class="literal number integer"><span class="pre">9</span></span><span class="punctuation"><span class="pre">)</span></span></code> was
used instead of <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">options</span></span> <span class="literal number integer"><span class="pre">2</span></span> <span class="literal number integer"><span class="pre">3</span></span> <span class="literal number integer"><span class="pre">4</span></span> <span class="literal number integer"><span class="pre">5</span></span> <span class="literal number integer"><span class="pre">6</span></span> <span class="literal number integer"><span class="pre">7</span></span> <span class="literal number integer"><span class="pre">8</span></span> <span class="literal number integer"><span class="pre">9</span></span><span class="punctuation"><span class="pre">)</span></span></code>. Except that in the case
of <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">options</span></span></code>, the values can be of any type.</p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Comp308: Principles of Programming Languages</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="racket-intro.html">A quick introduction to Racket and Scheme</a></li>
<li class="toctree-l1"><a class="reference internal" href="lambda.html">Lambda - the everything</a></li>
<li class="toctree-l1"><a class="reference internal" href="piclang.html">A language for pictures</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine.html">A mental model for the machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="growing.html">Growing the language</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun.html">Functions and scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="stacks-and-scope.html">Stacks and scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun-in-piclang.html">Functions in PicLang</a></li>
<li class="toctree-l1"><a class="reference internal" href="mutations.html">Mutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="control.html">Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="objects.html">Objects</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Generators</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#call-cc-and-let-cc"><code class="code highlight racket docutils literal notranslate"><span class="name builtin"><span class="pre">call/cc</span></span></code> and <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">let/cc</span></span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#python-generators">Python generators</a></li>
<li class="toctree-l2"><a class="reference internal" href="#generators-in-racket">Generators in Racket</a></li>
<li class="toctree-l2"><a class="reference internal" href="#search-as-a-language-feature">Search as a language feature</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="appsem.html">Alternative application semantics</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="objects.html" title="previous chapter">Objects</a></li>
      <li>Next: <a href="appsem.html" title="next chapter">Alternative application semantics</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Srikumar K. S..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/generators.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>