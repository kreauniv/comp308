<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Mutations &#8212; Comp308: Principles of Programming Languages v1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=3d3fbe02" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=12dfc556" />
    <script src="_static/documentation_options.js?v=5cb08e4e"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Control" href="control.html" />
    <link rel="prev" title="Functions in PicLang" href="fun-in-piclang.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="mutations">
<h1>Mutations<a class="headerlink" href="#mutations" title="Link to this heading">¶</a></h1>
<p>Much in the history of programming languages has been concerned with what we’d
call “imperative” style of programming. This involves thinking of a program as
“performing a sequence of steps” and less as “computing a particular value from
some set of input values”.</p>
<p>While the notion of “sequencing” appears to dominate that description, we need to
look deeper to see why such a sequencing even deserves a mention there.</p>
<p>Let’s look at a typical computer architecture –</p>
<figure class="align-center" id="id1">
<img alt="A diagram of components of a modern computer. Features a CPU, data storage, program memory, I/O devices and the network." src="_images/computer.png" />
<figcaption>
<p><span class="caption-number">Fig. 4 </span><span class="caption-text">Core components of a modern “computer”.</span><a class="headerlink" href="#id1" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Such a computer features a CPU at the heart, which pull a sequence of instructions
from the “program memory” and “executes” them one by one. Some of these instructions
may ask the CPU to fetch some data from the data storage, or to write data into
some locations in the data storage, or to read/write data to the network or chosen
I/O devices.</p>
<p>So the journey of a program is close enough to how we’ve been expressing the
<code class="code highlight racket docutils literal highlight-racket"><span class="n">stack-machine</span></code> in earlier sections, except we didn’t have explicit notions
of I/O devices or network. The <code class="code highlight racket docutils literal highlight-racket"><span class="n">stack-machine</span></code> function serves as our “CPU”
model, the list of instructions or “program” serves as our model of the “program
memory” and the stack and bindings are part of the data storage.</p>
<p>In the “expression evaluator” formulation though, we formulated our language
there as though evaluating an expression has no other consequences than
computing the result value. The “bindings” argument (i.e. the “environment”)
was incidental to this calculation. This corresponds to the stack picture as
well, if we throw away the bindings as a “result” and only consider what’s on
the stack as the intended result.</p>
<p>If you think of data memory as addressed using whole numbers, then both our
languages don’t quite have the equivalent of “read an integer from memory
location 132357” and “write the integer value 42 to memory location 238576”.
With these kinds of operations, it is clear that the order of the operations
critically affects the computation performed. If you write to a memory location
and read it back, you’ll get the value you wrote, but if you read it and then
write a different value back, the value you read in could be something else.</p>
<p>Therefore, the need for sequencing arises (at least in this case) as a side
effect of a model of computation where we’re reading from and writing to
addressable memory locations that’re <strong>mutable</strong>.</p>
<section id="the-racket-box">
<h2>The Racket “box”<a class="headerlink" href="#the-racket-box" title="Link to this heading">¶</a></h2>
<p>Racket provides an entity called a “box” that is akin to a one-element mutable
vector. A box is either empty or has something in it and you can change the
contents of the box.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="nb">box</span><span class="w"> </span><span class="mi">24</span><span class="p">))</span>
<span class="p">(</span><span class="nb">display</span><span class="w"> </span><span class="p">(</span><span class="nb">unbox</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">  </span><span class="c1">; Prints 24</span>
<span class="p">(</span><span class="nb">set-box!</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span>
<span class="p">(</span><span class="nb">display</span><span class="w"> </span><span class="p">(</span><span class="nb">unbox</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">  </span><span class="c1">; Prints 42</span>
</pre></div>
</div>
<p>We can treat such a mutable box as a reference to a storage location in data
memory of our computer. The symbol <code class="code highlight racket docutils literal highlight-racket"><span class="n">b</span></code> in the above example is bound to
this “memory location”. So the <code class="code highlight racket docutils literal highlight-racket"><span class="nb">unbox</span></code> procedure can fetch the contents of
this memory location and the <code class="code highlight racket docutils literal highlight-racket"><span class="nb">set-box!</span></code> procedure can modify its contents.
As seen in the example above, between the first <code class="code highlight racket docutils literal highlight-racket"><span class="nb">display</span></code> call and the
next, something has happened to the box. It is this “something” that we intend
to model in our interpreter. We’ll consider both models – the expression
evaluator we’ve called <code class="code highlight racket docutils literal highlight-racket"><span class="n">interp</span></code> as well as the <code class="code highlight racket docutils literal highlight-racket"><span class="n">stack-machine</span></code>.</p>
<p>Working with “boxes” is done via three functions -</p>
<ol class="arabic simple">
<li><p><code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="nb">box</span><span class="w"> </span><span class="n">&lt;val&gt;</span><span class="p">)</span></code> which creates a mutable box and returns a reference to
the box.</p></li>
<li><p><code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="nb">unbox</span><span class="w"> </span><span class="n">b</span><span class="p">)</span></code> which looks into the given box and produces the value it
contains.</p></li>
<li><p><code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="nb">set-box!</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">&lt;newval&gt;</span><span class="p">)</span></code> which replaces the contents of the given box
with the new value. The result value of <code class="code highlight racket docutils literal highlight-racket"><span class="nb">set-box!</span></code> is of no consequence
and can be anything we deem convenient to us. We might consider it
convenient for it to produce the box itself, for example. Racket makes this
irrelevance explicit by declaring <code class="code highlight racket docutils literal highlight-racket"><span class="nb">set-box!</span></code> expressions to result in
<code class="code highlight racket docutils literal highlight-racket"><span class="nb">void</span></code>.</p></li>
</ol>
</section>
<section id="sequencing">
<h2>Sequencing<a class="headerlink" href="#sequencing" title="Link to this heading">¶</a></h2>
<p>The main aspect of using boxes that we need to pay attention to is that
with operations like <code class="code highlight racket docutils literal highlight-racket"><span class="nb">set-box!</span></code>, we now have to pay attention to the order
in which expressions are evaluated, even at the same “level” in our expression
language. Racket has a construct that makes this sequencing explicit –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">begin</span>
<span class="w">    </span><span class="n">&lt;expr1&gt;</span>
<span class="w">    </span><span class="n">&lt;expr2&gt;</span>
<span class="w">    </span><span class="k">...</span>
<span class="w">    </span><span class="n">&lt;exprN&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>The result of such a <code class="code highlight racket docutils literal highlight-racket"><span class="k">begin</span></code> expression is that of the last <code class="code highlight racket docutils literal highlight-racket"><span class="n">&lt;exprN&gt;</span></code>
in the sequence. <code class="code highlight racket docutils literal highlight-racket"><span class="k">begin</span></code> guarantees that the expressions will be evaluated
in the given order, so we can make assumptions about any mutating operations
we’ve used there.</p>
<p>So if we’re to add mutating operations to our <code class="code highlight racket docutils literal highlight-racket"><span class="n">PicLang</span></code>, we will need
to add a notion of “boxes” as well as implement a notion of sequencing.</p>
</section>
<section id="sequencing-in-the-stack-machine">
<h2>Sequencing in the stack machine<a class="headerlink" href="#sequencing-in-the-stack-machine" title="Link to this heading">¶</a></h2>
<p>We’ve already seen sequencing of operations happening in our
<code class="code highlight racket docutils literal highlight-racket"><span class="n">stack-machine</span></code> – whose “program” consists of a sequence of instructions,
each of which take in a “state” and produce a new state. In our case, “state”
includes a “stack” as well as a “list of bindings” structure.</p>
<p>The mechanism of passing this state from one instruction to another is
worth revisiting since that is the same mechanism we’ll need to bring about
mutations in our <code class="code highlight racket docutils literal highlight-racket"><span class="n">PicLang</span></code>.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">stack-machine</span><span class="w"> </span><span class="n">program</span><span class="w"> </span><span class="n">state</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">empty?</span><span class="w"> </span><span class="n">program</span><span class="p">)</span>
<span class="w">        </span><span class="n">state</span>
<span class="w">        </span><span class="c1">;      v--- the next state                         v------- the current state</span>
<span class="w">        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">state2</span><span class="w"> </span><span class="p">(</span><span class="n">process-instruction</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">program</span><span class="p">)</span><span class="w"> </span><span class="n">state</span><span class="p">)])</span>
<span class="w">           </span><span class="c1">;                                  | Use the next state for the rest</span>
<span class="w">           </span><span class="c1">;                             v----/ of the program.</span>
<span class="w">           </span><span class="p">(</span><span class="n">stack-machine</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">program</span><span class="p">)</span><span class="w"> </span><span class="n">state2</span><span class="p">))))</span>
</pre></div>
</div>
<p>We see how what we’re calling “state” undergoes changes as each instruction is
performed, resulting in the final state. The sequence of instruction evaluation
very much matters with our stack machine, unlike the expression evaluation
based interpreter we wrote, which relies on Racket’s own stack mechanism.</p>
<p>So let’s now look at how to implement such sequencing in our PicLang.</p>
</section>
<section id="terms-for-boxes">
<h2>Terms for boxes<a class="headerlink" href="#terms-for-boxes" title="Link to this heading">¶</a></h2>
<p>Corresponding to the functions that Racket provides for boxes, we’ll need a
few new terms –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="n">BoxC</span><span class="w"> </span><span class="p">(</span><span class="n">expr</span><span class="p">))</span><span class="w">    </span><span class="c1">; Makes a new box whose value is the result</span>
<span class="w">                        </span><span class="c1">; of evluating the given expression.</span>

<span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="n">UnboxC</span><span class="w"> </span><span class="p">(</span><span class="n">var</span><span class="p">))</span><span class="w">   </span><span class="c1">; var is expected to be an identifier bound to</span>
<span class="w">                        </span><span class="c1">; box value in the current environment.</span>

<span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="n">SetBoxC</span><span class="w"> </span><span class="p">(</span><span class="n">var</span><span class="w"> </span><span class="n">valexpr</span><span class="p">))</span><span class="w"> </span><span class="c1">; For modifying the contents of the box</span>
<span class="w">                                  </span><span class="c1">; to hold a new value. The first field</span>
<span class="w">                                  </span><span class="c1">; is expected to be a identifier bound</span>
<span class="w">                                  </span><span class="c1">; to a box value in the current environment.</span>
</pre></div>
</div>
<p>We also saw that to implement mutating operations, we will need a notion of
“sequencing” in our language. We’ll add a term for that too, which corresponds
to the Racket <code class="code highlight racket docutils literal highlight-racket"><span class="k">begin</span></code> expression.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="n">SeqC</span><span class="w"> </span><span class="p">(</span><span class="n">expr1</span><span class="w"> </span><span class="n">expr2</span><span class="p">))</span><span class="w">   </span><span class="c1">; We&#39;ll limit ourselves to two expressions</span>
<span class="w">                              </span><span class="c1">; as we can compose more using a form like</span>
<span class="w">                              </span><span class="c1">; (SeqC expr1 (SeqC expr2 (SeqC expr3 expr4)))</span>
</pre></div>
</div>
<p>Now let’s look at how our interpreter will handle these terms. The result of
our interpreter will now need to be a pair of values - the actual value
and the new state of the “storage” that is woven through the sequencing
operations.</p>
<p>We’ll also need a new possible value for our interpreter .. one we expect
to get when we evaluate a <code class="code highlight racket docutils literal highlight-racket"><span class="n">BoxC</span></code> term. We’ll call this <code class="code highlight racket docutils literal highlight-racket"><span class="n">BoxV</span></code>
and have the structure store a “reference” that points into the storage.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="n">Result</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="w"> </span><span class="n">storage</span><span class="p">))</span>
<span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="n">BoxV</span><span class="w"> </span><span class="p">(</span><span class="n">ref</span><span class="p">))</span>
<span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="n">NewRef</span><span class="w"> </span><span class="p">(</span><span class="n">ref</span><span class="w"> </span><span class="n">storage</span><span class="p">))</span><span class="w"> </span><span class="c1">; Returned by make-reference</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">interp</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="n">bindings</span><span class="w"> </span><span class="n">storage</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="n">expr</span>
<span class="w">        </span><span class="c1">; ...</span>
<span class="w">        </span><span class="c1">; ... TASK: rewrite the ordinary expressions to return a Result structure.</span>
<span class="w">        </span><span class="c1">; ...</span>
<span class="w">        </span><span class="p">[(</span><span class="n">BoxC</span><span class="w"> </span><span class="n">valexpr</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">r</span><span class="w"> </span><span class="p">(</span><span class="n">interp</span><span class="w"> </span><span class="n">valexpr</span><span class="w"> </span><span class="n">bindings</span><span class="w"> </span><span class="n">storage</span><span class="p">)])</span>
<span class="w">             </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="n">make-reference</span><span class="w"> </span><span class="p">(</span><span class="n">Result-storage</span><span class="w"> </span><span class="n">r</span><span class="p">))])</span>
<span class="w">                </span><span class="p">(</span><span class="n">Result</span><span class="w"> </span><span class="p">(</span><span class="n">BoxV</span><span class="w"> </span><span class="p">(</span><span class="n">NewRef-ref</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="n">NewRef-storage</span><span class="w"> </span><span class="n">b</span><span class="p">))))]</span>
<span class="w">        </span><span class="p">[(</span><span class="n">UnboxC</span><span class="w"> </span><span class="n">var</span><span class="p">)</span>
<span class="w">         </span><span class="c1">; Notice that unboxing is not expected to modify the storage.</span>
<span class="w">         </span><span class="p">(</span><span class="n">Result</span><span class="w"> </span><span class="p">(</span><span class="n">read-reference</span><span class="w"> </span><span class="p">(</span><span class="n">lookup-binding</span><span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="n">bindings</span><span class="p">)</span><span class="w"> </span><span class="n">storage</span><span class="p">)</span><span class="w"> </span><span class="n">storage</span><span class="p">)]</span>
<span class="w">        </span><span class="p">[(</span><span class="n">SetBoxC</span><span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="n">valexpr</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="n">interp</span><span class="w"> </span><span class="n">valexpr</span><span class="w"> </span><span class="n">bindings</span><span class="w"> </span><span class="n">storage</span><span class="p">)</span>
<span class="w">            </span><span class="p">[(</span><span class="n">Result</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="n">storage2</span><span class="p">)</span>
<span class="w">             </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">storage3</span><span class="w"> </span><span class="p">(</span><span class="n">write-reference</span><span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="n">storage2</span><span class="p">)])</span>
<span class="w">                </span><span class="p">(</span><span class="n">Result</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="n">storage3</span><span class="p">))])]</span>
<span class="w">        </span><span class="p">[(</span><span class="n">SeqC</span><span class="w"> </span><span class="n">expr1</span><span class="w"> </span><span class="n">expr2</span><span class="p">)</span>
<span class="w">         </span><span class="c1">;                                v--- Initial storage state</span>
<span class="w">         </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">r1</span><span class="w"> </span><span class="p">(</span><span class="n">interp</span><span class="w"> </span><span class="n">expr1</span><span class="w"> </span><span class="n">bindings</span><span class="w"> </span><span class="n">storage</span><span class="p">)])</span>
<span class="w">             </span><span class="c1">;                      v--- Storage state *after* expr1.</span>
<span class="w">             </span><span class="p">(</span><span class="n">interp</span><span class="w"> </span><span class="n">expr2</span><span class="w"> </span><span class="n">bindings</span><span class="w"> </span><span class="p">(</span><span class="n">Result-storage</span><span class="w"> </span><span class="n">r1</span><span class="p">)))]</span>
<span class="w">        </span><span class="c1">; ...</span>
<span class="w">        </span><span class="c1">; ... TASK: ApplyC implementation also needs to change. Rewrite it.</span>
<span class="w">        </span><span class="c1">; ...</span>
<span class="w">        </span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="variations">
<h2>Variations<a class="headerlink" href="#variations" title="Link to this heading">¶</a></h2>
<p>We have some choices in how we define the <code class="code highlight racket docutils literal highlight-racket"><span class="n">UnboxC</span></code> and <code class="code highlight racket docutils literal highlight-racket"><span class="n">SetBoxC</span></code>
terms. In the preceding formulation, we specified <code class="code highlight racket docutils literal highlight-racket"><span class="n">UnboxC</span></code> to hold an
<em>identifier</em> to be looked up in the current environment for a box value. We
could’ve instead defined it to take a box-expression – i.e. an expression that
will evaluate to a box value – so we could in principle write <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">UnboxC</span>
<span class="p">(</span><span class="n">BoxC</span><span class="w"> </span><span class="mi">42</span><span class="p">))</span></code> if we wanted to, though there is not much of a point to boxing a
value only to immediately unbox it. Typically we’d want <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">UnboxC</span><span class="w"> </span><span class="p">(</span><span class="n">IdC</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">name</span><span class="p">))</span></code>
and the above formulation meets that simple need.</p>
<p>The same goes with <code class="code highlight racket docutils literal highlight-racket"><span class="n">SetBoxC</span></code> terms too. We could’ve defined it to be
<code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">SetBoxC</span><span class="w"> </span><span class="n">boxexpr</span><span class="w"> </span><span class="n">valexpr</span><span class="p">)</span></code>, but then we’d have had to sequence the
evaluation of <code class="code highlight racket docutils literal highlight-racket"><span class="n">boxexpr</span></code> and <code class="code highlight racket docutils literal highlight-racket"><span class="n">valexpr</span></code> .. which means we’ll be
duplicating the functionality of <code class="code highlight racket docutils literal highlight-racket"><span class="n">SeqC</span></code>. Furthermore, we could treat this
extended form as syntactic sugar too. For example, we could desugar
<code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">SetBoxS</span><span class="w"> </span><span class="n">boxexpr</span><span class="w"> </span><span class="n">valexpr</span><span class="p">)</span></code> to <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">ApplyC</span><span class="w"> </span><span class="p">(</span><span class="n">FunC</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">b</span><span class="w"> </span><span class="p">(</span><span class="n">SetBoxC</span><span class="w"> </span><span class="p">(</span><span class="n">IdC</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">b</span><span class="p">)</span>
<span class="n">valexpr</span><span class="p">))</span><span class="w"> </span><span class="n">boxexpr</span><span class="p">)</span></code>, where we handle <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">SetBoxC</span><span class="w"> </span><span class="p">(</span><span class="n">IdC</span><span class="w"> </span><span class="n">sym</span><span class="p">)</span><span class="w"> </span><span class="n">valexpr</span><span class="p">)</span></code> in the
interpreter as though we expect only <code class="code highlight racket docutils literal highlight-racket"><span class="n">IdC</span></code> terms in the first slot.</p>
</section>
<section id="super-powers">
<h2>Super powers<a class="headerlink" href="#super-powers" title="Link to this heading">¶</a></h2>
<p>With any such feature addition to a language, it is always necessary to ask
what kinds of, what we’ve been calling, “super powers” does it give us. So
what new super power did we gain by having mutable storage in our language?</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Think about this for a bit and see if you can come up with your
own answers before reading on.</p>
</div>
<p>When introducing this feature, we also had to ensure that our other existing
language terms work sensibly with this new one. For example, in implementing
<code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">ApplyC</span><span class="w"> </span><span class="n">funexpr</span><span class="w"> </span><span class="n">valexpr</span><span class="p">)</span></code>, we needed to sequence the evaluation of
the <code class="code highlight racket docutils literal highlight-racket"><span class="n">funexpr</span></code> term and the <code class="code highlight racket docutils literal highlight-racket"><span class="n">valexpr</span></code> term, because either term could
contain subexpressions that change the state of the storage. It is as though
<code class="code highlight racket docutils literal highlight-racket"><span class="n">ApplyC</span></code> is to behave like <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">ApplyC</span><span class="w"> </span><span class="n">funexpr</span><span class="w"> </span><span class="p">(</span><span class="n">SeqC</span><span class="w"> </span><span class="n">funexpr</span><span class="w"> </span><span class="n">valexpr</span><span class="p">))</span></code>
in our older implementation of <code class="code highlight racket docutils literal highlight-racket"><span class="n">ApplyC</span></code> which did not propagate the storage
changes to the evaluation of the <code class="code highlight racket docutils literal highlight-racket"><span class="n">valexpr</span></code> part.</p>
<p>Super powers we gain from a new language feature are usually from the
consequences of ensuring sensible interoperability of the new feature with the
existing features.</p>
<p>In this case, we’ve gained the ability to have our functions produce different
values each time they’re applied. Here’s how you’d express this possibility
in Racket code –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">count-up</span><span class="w"> </span><span class="n">start</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="nb">box</span><span class="w"> </span><span class="n">start</span><span class="p">)])</span>
<span class="w">        </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">()</span>
<span class="w">            </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">v</span><span class="w"> </span><span class="p">(</span><span class="nb">unbox</span><span class="w"> </span><span class="n">b</span><span class="p">)])</span>
<span class="w">                </span><span class="p">(</span><span class="nb">set-box!</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>
<span class="w">                </span><span class="n">v</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">nats</span><span class="w"> </span><span class="p">(</span><span class="n">count-up</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">writeln</span><span class="w"> </span><span class="p">(</span><span class="n">nats</span><span class="p">))</span><span class="w"> </span><span class="c1">; prints 0</span>
<span class="p">(</span><span class="nb">writeln</span><span class="w"> </span><span class="p">(</span><span class="n">nats</span><span class="p">))</span><span class="w"> </span><span class="c1">; prints 1</span>
<span class="p">(</span><span class="nb">writeln</span><span class="w"> </span><span class="p">(</span><span class="n">nats</span><span class="p">))</span><span class="w"> </span><span class="c1">; prints 2</span>
<span class="p">(</span><span class="nb">writeln</span><span class="w"> </span><span class="p">(</span><span class="n">nats</span><span class="p">))</span><span class="w"> </span><span class="c1">; prints 3</span>
</pre></div>
</div>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Think of a case in PicLang where this could be useful. Code it up,
make some interesting pictures and share on the discussion board.</p>
</div>
<p>When we dealt with recursion using lambda calculus, we worked through
the Y and <span class="math notranslate nohighlight">\(\Theta\)</span> combinators that can generate the recursion
without having support for recursive mention of functions at definition
time. If we have mutation at hand, we can do the following “trick”,
even without a recursion-capable <code class="code highlight racket docutils literal highlight-racket"><span class="k">define</span></code>.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">factorial</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">fn</span><span class="w"> </span><span class="p">(</span><span class="nb">box</span><span class="w"> </span><span class="no">#f</span><span class="p">)])</span>
<span class="w">        </span><span class="p">(</span><span class="nb">set-box!</span><span class="w"> </span><span class="n">fn</span>
<span class="w">                  </span><span class="p">(</span><span class="k">λ</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="w">                     </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                         </span><span class="mi">1</span>
<span class="w">                         </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">((</span><span class="nb">unbox</span><span class="w"> </span><span class="n">fn</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">))))))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">unbox</span><span class="w"> </span><span class="n">fn</span><span class="p">)))</span>
</pre></div>
</div>
<p>No combinators! The λ expression closes over the box value bound to <code class="code highlight racket docutils literal highlight-racket"><span class="n">fn</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="code highlight racket docutils literal highlight-racket"><span class="k">letrec</span></code> form in Racket/Scheme does this kind of a trick,
but (roughly speaking) by using Scheme identifiers as variables.</p>
</div>
</section>
<section id="state-machines">
<h2>State machines<a class="headerlink" href="#state-machines" title="Link to this heading">¶</a></h2>
<p id="index-0">“Function returning different values each time it is called” is a kind of silly
way of stating the “super power” we’ve got. This is much bigger than what it
looks like – which perhaps deserves a response like “ok, so what?”.</p>
<p>To see why this is much bigger, think of what we can do with something even as
simple as an counter like above. Imagine a general function of this form –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">machine</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span>
<span class="w">                    </span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="n">n</span>
<span class="w">                        </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">expr0</span><span class="w"> </span><span class="n">&lt;next-n&gt;</span><span class="p">)]</span>
<span class="w">                        </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">expr1</span><span class="w"> </span><span class="n">&lt;next-n&gt;</span><span class="p">)]</span>
<span class="w">                        </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">expr2</span><span class="w"> </span><span class="n">&lt;next-n&gt;</span><span class="p">)]</span>
<span class="w">                        </span><span class="c1">;...</span>
<span class="w">                        </span><span class="p">)))</span>
</pre></div>
</div>
<p>The way we can use this function is to start with passing <code class="code highlight racket docutils literal highlight-racket"><span class="n">n=0</span></code>
and get the result, then take the <code class="code highlight racket docutils literal highlight-racket"><span class="n">next-n</span></code> part and call the function
again with that <code class="code highlight racket docutils literal highlight-racket"><span class="n">next-n</span></code> value and repeat this process.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You’ve done this before earlier in this section. Twice! Can you
recognize this pattern?</p>
</div>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Can you write such a “machine” function that produces the cumulative
sum of the sequence of numbers passed in as <code class="code highlight racket docutils literal highlight-racket"><span class="n">arg</span></code>? That is,
if you repeatedly call the machine function (passing the <code class="code highlight racket docutils literal highlight-racket"><span class="n">&lt;next-n&gt;</span></code>
correctly, and pass in <code class="code highlight racket docutils literal highlight-racket"><span class="n">arg</span></code> values of <code class="code highlight racket docutils literal highlight-racket"><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">8</span></code> one by one,
the result part of the returned values will be <code class="code highlight racket docutils literal highlight-racket"><span class="mi">1</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">17</span></code>.</p>
</div>
<p>However, it is kind of cumbersome to pass the <code class="code highlight racket docutils literal highlight-racket"><span class="n">next-n</span></code> values like
that. Because we now have sequencing ability in our language, we can
express it as a function that will keep changing what it calculates
every time it is called without us doing any of that “threading” of
<code class="code highlight racket docutils literal highlight-racket"><span class="n">next-n</span></code> values.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">machine</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="nb">box</span><span class="w"> </span><span class="mi">0</span><span class="p">)])</span>
<span class="w">                    </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
<span class="w">                        </span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="nb">unbox</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">                            </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">v0</span><span class="w"> </span><span class="n">expr0</span><span class="p">])</span><span class="w"> </span><span class="p">(</span><span class="nb">set-box!</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">&lt;next-n&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">v0</span><span class="p">)]</span>
<span class="w">                            </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">v1</span><span class="w"> </span><span class="n">expr1</span><span class="p">])</span><span class="w"> </span><span class="p">(</span><span class="nb">set-box!</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">&lt;next-n&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">v1</span><span class="p">)]</span>
<span class="w">                            </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">v2</span><span class="w"> </span><span class="n">expr2</span><span class="p">])</span><span class="w"> </span><span class="p">(</span><span class="nb">set-box!</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">&lt;next-n&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">v2</span><span class="p">)]</span>
<span class="w">                            </span><span class="c1">; ...</span>
<span class="w">                            </span><span class="p">))))</span>
</pre></div>
</div>
<p>Now, the machine will keep jumping between these numbered “states” every time
we call it with some argument. We call such functions “state machines” …
which is closely related to the architecture of the <code class="code highlight racket docutils literal highlight-racket"><span class="n">stack-machine</span></code> we’ve
worked with so far. Explicit state machines are a great way to organize certain
kinds of computations. At some level, every program is trivially a state machine
too.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Do you see why that is the case?</p>
</div>
<p>We won’t get into the details of state machines right now as we’ll have plenty
of opportunity soon enough. However, here is an example that might be relatable –
when you’re “parsing” a stream of symbols (i.e. text), a parser typically tracks
what it sees by maintaining a history of states and deciding, upon encountering
each symbol, what the next state should be. For example, consider a parser for
decimal numbers of the form “123.4”, “0.4446” etc. We could describe a parser
for such numbers in terms of 6 states as follows –</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">[START-DECIMAL-NUMBER]</span></code></dt><dd><p>If the next character is not a decimal digit, we jump to state
<code class="docutils literal notranslate"><span class="pre">[NOT-A-DECIMAL-NUMBER]</span></code>. If the next character is a decimal digit, we
add two numbers <span class="math notranslate nohighlight">\(N\)</span> and <span class="math notranslate nohighlight">\(D\)</span> to our state and initialize them
both to <span class="math notranslate nohighlight">\(0\)</span>, then move to state <code class="docutils literal notranslate"><span class="pre">[DIGIT-BEFORE-DECIMAL-PT]</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[DIGIT-BEFORE-DECIMAL-PT]</span></code></dt><dd><p>If the next character is a decimal digit
<span class="math notranslate nohighlight">\(d\)</span>, we update <span class="math notranslate nohighlight">\(N \leftarrow 10N+\text{value}(d)\)</span> and move to
<code class="docutils literal notranslate"><span class="pre">[DIGIT-BEFORE-DECIMAL-PT]</span></code>. If the next character is a period instead,
we jump to <code class="docutils literal notranslate"><span class="pre">[DECIMAL-PT]</span></code>. On encountering any other character, we jump
to <code class="docutils literal notranslate"><span class="pre">[DECIMAL-NUMBER-COMPLETE]</span></code> after returning the character to the stream.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[DECIMAL-PT]</span></code></dt><dd><p>We set <span class="math notranslate nohighlight">\(D \leftarrow 0\)</span> and move to <code class="docutils literal notranslate"><span class="pre">[DIGIT-AFTER-DECIMAL-PT]</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[DIGIT-AFTER-DECIMAL-PT]</span></code></dt><dd><p>If the next character is a decimal digit
<span class="math notranslate nohighlight">\(d\)</span>, we update <span class="math notranslate nohighlight">\(D \leftarrow D+1\)</span> and update
<span class="math notranslate nohighlight">\(N \leftarrow N+\text{value}(d)\times 10^{-D}\)</span>, and move to state
<code class="docutils literal notranslate"><span class="pre">[DIGIT-AFTER-DECIMAL-PT]</span></code>. If the next character is anything other than a
decimal digit, we return the character to the stream and move to the
<code class="docutils literal notranslate"><span class="pre">[DECIMAL-NUMBER-COMPLETE]</span></code> state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[DECIMAL-NUMBER-COMPLETE]</span></code></dt><dd><p>We declare the result of the parse to be the
number <span class="math notranslate nohighlight">\(N\)</span>. If our task is done, we can keep returning to this same
state. Otherwise we can move to another state as required.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[NOT-A-DECIMAL-NUMBER]</span></code></dt><dd><p>This is a terminal state since we can’t do anything else at this point.</p>
</dd>
</dl>
<p>So we could write a state machine with these states numbered 0,1,2,3,4,5 which
can handle parsing of such decimal numbers given one character at a time.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Comp308: Principles of Programming Languages</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Welcome note</a></li>
<li class="toctree-l1"><a class="reference internal" href="racket-intro.html">A quick introduction to Racket and Scheme</a></li>
<li class="toctree-l1"><a class="reference internal" href="lambda.html">λ - the everything</a></li>
<li class="toctree-l1"><a class="reference internal" href="church.html">Lambda - via β-abstraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="piclang.html">A language for pictures</a></li>
<li class="toctree-l1"><a class="reference internal" href="arithlang.html">A language for arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine.html">A mental model for the machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="notional-machine.html">Notional machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="growing.html">Growing the language</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun.html">Functions and scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun-arith.html">Functions and scope (arithmetic track)</a></li>
<li class="toctree-l1"><a class="reference internal" href="stacks-and-scope.html">Stacks and scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun-in-piclang.html">Functions in PicLang</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Mutations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-racket-box">The Racket “box”</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sequencing">Sequencing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sequencing-in-the-stack-machine">Sequencing in the stack machine</a></li>
<li class="toctree-l2"><a class="reference internal" href="#terms-for-boxes">Terms for boxes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#variations">Variations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#super-powers">Super powers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#state-machines">State machines</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="control.html">Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="errornot.html">On the choice between “error” and “do something reasonable” in design</a></li>
<li class="toctree-l1"><a class="reference internal" href="objects.html">Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="objects-self.html">Objects - the Self way</a></li>
<li class="toctree-l1"><a class="reference internal" href="dispatch.html">Polymorphism via dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="generators.html">Generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="appsem.html">Alternative application semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html">Types: Checking some program invariants statically</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="fun-in-piclang.html" title="previous chapter">Functions in PicLang</a></li>
      <li>Next: <a href="control.html" title="next chapter">Control</a></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2022, Srikumar K. S..
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="_sources/mutations.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>