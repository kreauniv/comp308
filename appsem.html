
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Alternative application semantics &#8212; Comp308: Principles of Programming Languages v1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Types: Checking some program invariants statically" href="types.html" />
    <link rel="prev" title="Generators" href="generators.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="alternative-application-semantics">
<h1>Alternative application semantics<a class="headerlink" href="#alternative-application-semantics" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section takes a different approach compared to the original
<a class="reference external" href="https://cs.brown.edu/courses/cs173/2012/book/Alternate_Application_Semantics.html">PLAI second edition</a>. Reasons – <a class="reference external" href="https://cs.brown.edu/courses/cs173/2012/book/Alternate_Application_Semantics.html#%28part._.Lazy_.Application%29">Lazy application</a> is
dealt with well in PLAI already, so please refer to that. I don’t think
students gain much by working through the “reactive” application semantics
from a PL perspective. Visual tools such as Excel, Max/MSP or PureData are
better models of this mode than any textual programming language or sub
language. If students are to learn it, it would probably be to learn that it
isn’t a great idea to pursue in a textual PL, despite possible conceptual
elegance of the original Fran. I’m choosing to do searching a little
differently due to doing type systems afterwards. I had not intended to do
type systems due to time constraints but am trying to see if this change of
approach can help with the constraint of a trimester system.</p>
</div>
<div class="section" id="solving-for-goals">
<h2>Solving for goals<a class="headerlink" href="#solving-for-goals" title="Permalink to this headline">¶</a></h2>
<p>One paradigm for program execution (function application) is to consider
“variables” to be first class entities you can pass to your functions.
Variables start off with low information content and as your function
progresses, more information is added to them. By “information” here, we’re not
talking about adding bits of data, but in the sense that a variable may
initially be defined to take one of several values in a given set and as the
program progresses, the size of this set is progressively reduced, thereby
making the variable more precise about its values.</p>
<p>The simplest version of that process of adding information is to have variables
be initially in an “Unknown” state and later on as the program progresses, they
may transition to a “Known” state getting bound to some value, after which the
value cannot be changed.</p>
<p>The purpose of a program in this paradigm is to start off with a set of
variables (at least some of them) in an “unknown state” and when the program
finishes, at least some of them become known – or “bound” to values.
Furthermore, we consider the program to produce one or more such possible set
of bindings of the program’s variables. We’ll look at how we can compute this.</p>
<p>Let’s define a value type that represents this idea of a “variable”. We’ll further
give our variables some string name that we can recognize them by.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">struct</span> <span class="n">Var</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="kd">#:transparent</span><span class="p">)</span>
<span class="c1">; That gives us Var, Var? and Var-name</span>
</pre></div>
</div>
<p>We’ll represent the idea of a set of bindings for our variables using our usual
“association list”, with variables as keys and values which can be either variables
themselves or ordinary values.</p>
<div class="admonition-question admonition">
<p class="admonition-title"><strong>Question</strong></p>
<p>Our “bindings as an association list” representation permits the occurrence
of mutiple bindings for a single variable. Reflect on whether that is
desirable. What do you think?</p>
</div>
<p>We’ll constrain our bindings list such that a particular variable can only
occur in the key position in one of the entries. i.e. We’re not permitted to
indicate different bindings for a variable in the same bindings set. Given that
we’re making variables using <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">Var</span></span></code>, we can lookup our variables in the
bindings list using <code class="code highlight racket docutils literal notranslate"><span class="name builtin"><span class="pre">assv</span></span></code>.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">v1</span> <span class="p">(</span><span class="n">Var</span> <span class="s2">&quot;one&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="n">v2</span> <span class="p">(</span><span class="n">Var</span> <span class="s2">&quot;one&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="nb">display</span> <span class="p">(</span><span class="nb">eqv?</span> <span class="n">v1</span> <span class="n">v2</span><span class="p">))</span> <span class="c1">; Shows #f, which is what we want. We want each of our</span>
                       <span class="c1">; Var values to be distinguishable irrespective of their</span>
                       <span class="c1">; names.</span>
</pre></div>
</div>
<p>Given that a set of bindings may indicate that a variable <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> (we’ll use
the convention of referring to variables using capitalized names) is is bound
to another variable <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code>, we need a procedure to determine the value at the
end of such a chain of “bindings”. We’ll call this procedure <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">walk</span></span></code>.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">walk</span> <span class="n">var</span> <span class="n">bindings</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">m</span> <span class="p">(</span><span class="nb">assv</span> <span class="n">var</span> <span class="n">bindings</span><span class="p">)])</span>
        <span class="p">(</span><span class="k">if</span> <span class="n">m</span>
            <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">Var?</span> <span class="p">(</span><span class="nb">second</span> <span class="n">m</span><span class="p">))</span>
                <span class="p">(</span><span class="n">walk</span> <span class="p">(</span><span class="nb">second</span> <span class="n">m</span><span class="p">)</span> <span class="n">bindings</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">second</span> <span class="n">m</span><span class="p">))</span>
            <span class="c1">; We let a var be itself if it isn&#39;t found in bindings.</span>
            <span class="c1">; This also lets us deal with the case where A is bound</span>
            <span class="c1">; to B but B does not appear as a key in the bindings.</span>
            <span class="n">var</span><span class="p">)))</span>
</pre></div>
</div>
<p>Now let’s consider what kinds of assertions we can make about two “things” in
our system. A “thing” being a variable or a value. If we assert that
<code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">&lt;thing1&gt;</span></span> <span class="name builtin"><span class="pre">=</span></span> <span class="name"><span class="pre">&lt;thing2&gt;</span></span></code>, what effect would we expect such an assertion to
have on our current set of bindings?</p>
<ol class="arabic simple">
<li><p><code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="name builtin"><span class="pre">=</span></span> <span class="name"><span class="pre">A</span></span></code> – i.e two variables are declared to be equal and they are the same.
This also has no impact on our bindings set and we stay happy.</p></li>
<li><p><code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="name builtin"><span class="pre">=</span></span> <span class="literal number integer"><span class="pre">32</span></span></code> – i.e. first thing is a variable and the second thing is a value.
In this case, we’d like to make note of this additional information in our
bindings set. We’ll therefore add an entry for it there.</p></li>
<li><p><code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="name builtin"><span class="pre">=</span></span> <span class="name"><span class="pre">B</span></span></code> – i.e. two <em>different</em> variables are declared to be equal to
each other. We can add a binding to this effect to our set. <strong>Question</strong>: Should
we add <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> bound to <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> or <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> bound to <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code>?</p></li>
<li><p><code class="code highlight racket docutils literal notranslate"><span class="literal number integer"><span class="pre">32</span></span> <span class="name builtin"><span class="pre">=</span></span> <span class="name"><span class="pre">A</span></span></code> – same as the previous case, we add a bindings for <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> to
our bindings set.</p></li>
<li><p><code class="code highlight racket docutils literal notranslate"><span class="literal number integer"><span class="pre">32</span></span> <span class="name builtin"><span class="pre">=</span></span> <span class="literal number integer"><span class="pre">32</span></span></code> – i.e. both things are values that are equal to each other.
In this case, we’re happy. No contradictions. And our bindings doesn’t
change one bit.</p></li>
</ol>
<p>In any other case (such as <code class="code highlight racket docutils literal notranslate"><span class="literal number integer"><span class="pre">2</span></span> <span class="name builtin"><span class="pre">=</span></span> <span class="literal number integer"><span class="pre">3</span></span></code>), the assertion will fail. Let’s capture all
of these in a function – <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">unify</span></span></code>. This process we described above, that
takes an assertion and augments a set of bindings with new information that reflects
the facts being asserted is called “unification” in the case where the assertion is
made via equality.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="c1">; unify tries to assert A = B in the context of the given</span>
<span class="c1">; bindings. It produces an augmented set of bindings if the</span>
<span class="c1">; assertion provided new information about variables involved.</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">unify</span> <span class="n">A</span> <span class="n">B</span> <span class="n">bset</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">av</span> <span class="p">(</span><span class="n">walk</span> <span class="n">A</span> <span class="n">bset</span><span class="p">)]</span>
          <span class="p">[</span><span class="n">bv</span> <span class="p">(</span><span class="n">walk</span> <span class="n">B</span> <span class="n">bset</span><span class="p">)])</span>
          <span class="c1">; By taking the walked end values for both LHS and RHS</span>
          <span class="c1">; of the unification, we&#39;re guaranteed that both never</span>
          <span class="c1">; appear as the key in our bindings set.</span>
        <span class="p">(</span><span class="k">cond</span>
            <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="n">Var?</span> <span class="n">av</span><span class="p">)</span> <span class="p">(</span><span class="n">Var?</span> <span class="n">bv</span><span class="p">)</span> <span class="p">(</span><span class="nb">equal?</span> <span class="n">av</span> <span class="n">bv</span><span class="p">))</span>
             <span class="n">bset</span><span class="p">]</span>         <span class="c1">; Handles 1</span>
            <span class="p">[(</span><span class="n">Var?</span> <span class="n">av</span><span class="p">)</span>   <span class="c1">; Handles 2 &amp; 3</span>
             <span class="p">(</span><span class="n">extend</span> <span class="n">av</span> <span class="n">bv</span> <span class="n">bset</span><span class="p">)]</span>
            <span class="p">[(</span><span class="n">Var?</span> <span class="n">bv</span><span class="p">)</span>   <span class="c1">; Handles 4</span>
             <span class="p">(</span><span class="n">extend</span> <span class="n">bv</span> <span class="n">av</span> <span class="n">bset</span><span class="p">)]</span>
            <span class="p">[(</span><span class="nb">eq?</span> <span class="n">av</span> <span class="n">bv</span><span class="p">)</span> <span class="c1">; Handles 5</span>
             <span class="n">bset</span><span class="p">]</span>
            <span class="c1">; Produce #f in all other cases.</span>
            <span class="p">[</span><span class="k">else</span> <span class="no">#f</span><span class="p">])))</span>


<span class="p">(</span><span class="k">define</span> <span class="n">empty-bset</span> <span class="nb">empty</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">extend</span> <span class="n">key</span> <span class="n">val</span> <span class="n">bset</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">list</span> <span class="n">key</span> <span class="n">val</span><span class="p">)</span> <span class="n">bset</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="goals">
<h2>Goals<a class="headerlink" href="#goals" title="Permalink to this headline">¶</a></h2>
<p>We earlier stated that our “program” in this model has the task of figuring out
which possible assignments to variables makes sense – i.e. is consistent with
a set of declarations about their properties. Since we’re talking about
“possible assignments to variables”, we’ll model the result of our program
as a list of bindings. i.e. if we call our set of bindings a <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">BSet</span></span></code>,
our program is expected to produce a <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">listof</span></span> <span class="name"><span class="pre">BSet</span></span><span class="punctuation"><span class="pre">)</span></span></code>.</p>
<p>This is giving our program a uniform interface of <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">BSet</span></span> <span class="keyword"><span class="pre">-&gt;</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">listof</span></span> <span class="name"><span class="pre">BSet</span></span><span class="punctuation"><span class="pre">)</span></span></code>.
We’ll call such a program a “goal”, since it is faced with the goal of finding
one or more possible sets of assignments to variables that is consistent with
some logic. In this case, if our goal cannot be met, the result is expected to
be an empty list indicating that there is no possible set of bindings that is
consistent with the goal.</p>
<p>Let’s now consider the simplest of such programs – a declaration of equality
between two things … which is <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">unify</span></span></code> in a different clothing.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">eq</span> <span class="n">A</span> <span class="n">B</span><span class="p">)</span>
    <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="n">bset</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">b</span> <span class="p">(</span><span class="n">unify</span> <span class="n">A</span> <span class="n">B</span> <span class="n">bset</span><span class="p">)])</span>
            <span class="p">(</span><span class="k">if</span> <span class="n">b</span>
                <span class="p">(</span><span class="nb">list</span> <span class="n">b</span><span class="p">)</span> <span class="c1">; Singleton list of bindings.</span>
                <span class="nb">empty</span><span class="p">))))</span>
</pre></div>
</div>
<p>It is useful to look at possible ways to combine <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">listof</span></span> <span class="name"><span class="pre">BSet</span></span><span class="punctuation"><span class="pre">)</span></span></code> values.</p>
<p>If we concatenate two such lists, we’re saying that the <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">BSet</span></span></code> values
belonging to either of the two lists are permitted as outcomes. This is like an
“or” (a.k.a. “disjunction”) and we can exploit that.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">disj</span> <span class="n">goalA</span> <span class="n">goalB</span><span class="p">)</span>
    <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="n">bset</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">append</span> <span class="p">(</span><span class="n">goalA</span> <span class="n">bset</span><span class="p">)</span> <span class="p">(</span><span class="n">goalB</span> <span class="n">bset</span><span class="p">))))</span>
</pre></div>
</div>
<p>So we have “or”. How do we get an “and” (a.k.a. “conjunction”) of two goals?
Calling the first goal on bindings can produce a list of possible bindings, but
we then need to use the second goal to examine whether it is consistent with
any of them at all. To do that, we can call the second goal on each of the
result bindings, each of which will produce a list of bindings that are
consistent with goalB and the result bindings we applied it to. Then we
concatenate all those lists to get the result. That way, if the second goal
fails on all of them, it will indicate that by returning an empty list in each
case and when we concatenate them all, we’ll get an empty list as the result.
If even one of them succeeded, the we’ll get a non-empty list and can go home
happy.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">conj</span> <span class="n">goalA</span> <span class="n">goalB</span><span class="p">)</span>
    <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="n">bset</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">apply</span> <span class="nb">append</span> <span class="p">(</span><span class="nb">map</span> <span class="n">goalB</span> <span class="p">(</span><span class="n">goalA</span> <span class="n">bset</span><span class="p">)))))</span>
</pre></div>
</div>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Go off now and study how the above definition of <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">conj</span></span></code> satisfies our
descripion of “and” in the preceding paragraph. What properties do we
expect such a <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">conj</span></span></code> to satisfy, logically? Does it satisfy them? In
particular, why should we expect <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">conj</span></span> <span class="name"><span class="pre">goalA</span></span> <span class="name"><span class="pre">goalB</span></span><span class="punctuation"><span class="pre">)</span></span></code> to produce the
same set of possibilities produced by <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">conj</span></span> <span class="name"><span class="pre">goalB</span></span> <span class="name"><span class="pre">goalA</span></span><span class="punctuation"><span class="pre">)</span></span></code>?</p>
</div>
<p>Note that <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">eq</span></span></code> produces a goal based on a statement about variables and
values, and <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">disj</span></span></code> and <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">conj</span></span></code> take goals as arguments and produce
a goal as their result. So we can call them “combinators”.</p>
<p>We can now describe some simple interesting searches.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">a</span> <span class="p">(</span><span class="n">Var</span> <span class="s2">&quot;a&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="n">b</span> <span class="p">(</span><span class="n">Var</span> <span class="s2">&quot;b&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="n">goal</span> <span class="p">(</span><span class="n">conj</span> <span class="p">(</span><span class="n">eq</span> <span class="n">a</span> <span class="mi">1</span><span class="p">)</span>
                   <span class="p">(</span><span class="n">disj</span> <span class="p">(</span><span class="n">eq</span> <span class="n">b</span> <span class="mi">2</span><span class="p">)</span>
                         <span class="p">(</span><span class="n">eq</span> <span class="n">b</span> <span class="mi">3</span><span class="p">))))</span>
<span class="p">(</span><span class="nb">writeln</span> <span class="p">(</span><span class="n">goal</span> <span class="n">empty-bindings</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Go off and run the above code to see what you get as the result.</p>
</div>
<p>This task of introducing new variables can perhaps be automated a bit.
We define a new primitive called <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">fresh</span></span></code> which creates new variables
and makes a goal of them.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">fresh</span> <span class="n">varnames</span> <span class="n">goal-proc</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">equal?</span> <span class="p">(</span><span class="nb">procedure-arity</span> <span class="n">goal-proc</span><span class="p">)</span> <span class="p">(</span><span class="nb">length</span> <span class="n">varnames</span><span class="p">))</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">vars</span> <span class="p">(</span><span class="nb">map</span> <span class="n">Var</span> <span class="n">varnames</span><span class="p">)])</span>
            <span class="p">(</span><span class="nb">apply</span> <span class="n">goal-proc</span> <span class="n">vars</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">raise-argument-error</span> <span class="o">&#39;</span><span class="ss">fresh</span>
                              <span class="s2">&quot;varnames should provide a name for each argument of the goal procedure&quot;</span>
                              <span class="p">(</span><span class="nb">list</span> <span class="n">varnames</span> <span class="n">goal-proc</span><span class="p">))))</span>
</pre></div>
</div>
<p>Now, we can code our simple example as –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">goal</span> <span class="p">(</span><span class="n">fresh</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span> <span class="ss">b</span><span class="p">)</span>
                    <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="n">a</span> <span class="n">b</span><span class="p">)</span>
                        <span class="p">(</span><span class="n">conj</span> <span class="p">(</span><span class="n">eq</span> <span class="n">a</span> <span class="mi">1</span><span class="p">)</span>
                              <span class="p">(</span><span class="n">disj</span> <span class="p">(</span><span class="n">eq</span> <span class="n">b</span> <span class="mi">2</span><span class="p">)</span>
                                    <span class="p">(</span><span class="n">eq</span> <span class="n">b</span> <span class="mi">3</span><span class="p">))))))</span>
<span class="p">(</span><span class="nb">writeln</span> <span class="p">(</span><span class="n">goal</span> <span class="n">empty-bindings</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="structural-unification">
<h2>Structural unification<a class="headerlink" href="#structural-unification" title="Permalink to this headline">¶</a></h2>
<p>So far, our “unification” procedure only dealt with simple values and variables.
We can extend this mechanism to also consider matching, say two cons pairs.
In that case though, we’d expect the corresponding parts of the cons pairs
to unify and hence unify becomes a recursive procedure.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>What are possible problems when we try to do this? Think through
possible cases one might encounter when calling <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">unify</span></span></code> with such
cons pairs to be unified and what we’re supposed to do to them. Below
are spoilers, so do that now!</p>
</div>
<p>What is supposed to happen when we ask for a variable to be unified with a cons
pair which itself contains this variable? If we wish to be strict about it, we
can declare failure when we encounter such a case. If we decide on this, we
need to add an “occurs check” to our unify cases. Otherwise we need to consider
the possibility that the unification request is intended to produce an infinite
circular data structure as the variable’s resultant binding and tip toe around
that possibility without catching ourselves doing an infinte loop.</p>
<p>We’ll chicken out and do the simple “don’t let that happen” approach. You can
try the other option as an exercise (heheh!).</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">occurs?</span> <span class="n">var</span> <span class="n">expr</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">pair?</span> <span class="n">expr</span><span class="p">)</span>
        <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="n">occurs?</span> <span class="n">var</span> <span class="p">(</span><span class="nb">car</span> <span class="n">expr</span><span class="p">))</span>
            <span class="p">(</span><span class="n">occurs?</span> <span class="n">var</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">expr</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">eq?</span> <span class="n">var</span> <span class="n">expr</span><span class="p">)))</span>
</pre></div>
</div>
<p>We now use this to modify our unification procedure to support pairs.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">unify</span> <span class="n">A</span> <span class="n">B</span> <span class="n">bset</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">av</span> <span class="p">(</span><span class="n">walk</span> <span class="n">A</span> <span class="n">bset</span><span class="p">)]</span>
          <span class="p">[</span><span class="n">bv</span> <span class="p">(</span><span class="n">walk</span> <span class="n">B</span> <span class="n">bset</span><span class="p">)])</span>
          <span class="c1">; By taking the walked end values for both LHS and RHS</span>
          <span class="c1">; of the unification, we&#39;re guaranteed that both never</span>
          <span class="c1">; appear as the key in our bindings set.</span>
        <span class="p">(</span><span class="k">cond</span>
            <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="n">Var?</span> <span class="n">av</span><span class="p">)</span> <span class="p">(</span><span class="n">Var?</span> <span class="n">bv</span><span class="p">)</span> <span class="p">(</span><span class="nb">equal?</span> <span class="n">av</span> <span class="n">bv</span><span class="p">))</span>
             <span class="n">bset</span><span class="p">]</span>         <span class="c1">; Handles 1</span>
            <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="n">Var?</span> <span class="n">av</span><span class="p">)</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="n">occurs?</span> <span class="n">av</span> <span class="n">bv</span><span class="p">)))</span>   <span class="c1">; Handles 2 &amp; 3</span>
             <span class="p">(</span><span class="n">extend</span> <span class="n">av</span> <span class="n">bv</span> <span class="n">bset</span><span class="p">)]</span>
            <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="n">Var?</span> <span class="n">bv</span><span class="p">)</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="n">occurs?</span> <span class="n">bv</span> <span class="n">av</span><span class="p">)))</span>   <span class="c1">; Handles 4</span>
             <span class="p">(</span><span class="n">extend</span> <span class="n">bv</span> <span class="n">av</span> <span class="n">bset</span><span class="p">)]</span>
            <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nb">pair?</span> <span class="n">av</span><span class="p">)</span> <span class="p">(</span><span class="nb">pair?</span> <span class="n">bv</span><span class="p">)</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">empty?</span> <span class="n">av</span><span class="p">))</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">empty?</span> <span class="n">bv</span><span class="p">)))</span>
             <span class="c1">; We have to use car and cdr here instead of first</span>
             <span class="c1">; and rest because the latter two require the</span>
             <span class="c1">; pair to be a non-empty list ... which is not a</span>
             <span class="c1">; constraint we require to be met by the two pairs.</span>
             <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">b2</span> <span class="p">(</span><span class="n">unify</span> <span class="p">(</span><span class="nb">car</span> <span class="n">av</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="n">bv</span><span class="p">)</span> <span class="n">bset</span><span class="p">)])</span>
                 <span class="p">(</span><span class="n">unify</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">av</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">bv</span><span class="p">)</span> <span class="n">b2</span><span class="p">))]</span>
            <span class="p">[(</span><span class="nb">eq?</span> <span class="n">av</span> <span class="n">bv</span><span class="p">)</span> <span class="c1">; Handles 5</span>
             <span class="n">bset</span><span class="p">]</span>
            <span class="c1">; Produce #f in all other cases.</span>
            <span class="p">[</span><span class="k">else</span> <span class="no">#f</span><span class="p">])))</span>
</pre></div>
</div>
<p>Such a structural unification is way more powerful than the ordinary atomic
value unification we did earlier. Check out the simple example below and make
more of your own –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">goal</span>
    <span class="p">(</span><span class="n">fresh</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span> <span class="ss">b</span><span class="p">)</span>
           <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="n">a</span> <span class="n">b</span><span class="p">)</span>
               <span class="p">(</span><span class="n">eq</span> <span class="p">(</span><span class="nb">cons</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">writeln</span> <span class="p">(</span><span class="n">goal</span> <span class="n">empty-bindings</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Thoroughly thrash out various possible usages of such structural unification.
What sets of arguments will you try it with and what would you expect? How might
you extend it even further?</p>
</div>
<div class="admonition-question admonition">
<p class="admonition-title"><strong>Question</strong></p>
<p>Why didn’t we consider implementing a <code class="code highlight racket docutils literal notranslate"><span class="name builtin"><span class="pre">not</span></span></code> since we implemented “and”
and “or” as <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">conj</span></span></code> and <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">disj</span></span></code> respectively?</p>
</div>
<p><strong>Reference</strong>: The approach above specifies a small goal language called <a class="reference external" href="https://github.com/jasonhemann/microKanren/blob/master/microKanren.scm">microKanren</a>.
You may also want to go through <a class="reference external" href="https://erik-j.de/microkanren/">A Gentle Introduction to microKanren</a>.</p>
</div>
<div class="section" id="generalizing-pair-s">
<h2>Generalizing “pair”s<a class="headerlink" href="#generalizing-pair-s" title="Permalink to this headline">¶</a></h2>
<p>In the latest version of <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">unify</span></span></code> above, we supported unification of two
“pair” structures. What if we want to generalize that and support arbitrary
<code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">struct</span></span></code>-like … structures?</p>
<p>To do that, see what is special about a <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">struct</span></span></code> that we define ourselves.
The main component of the definition that identifies a structure is its name,
and the fields are a list of values. We could model the structure’s name as a
constant symbol and the fields as … a list of values! While Racket’s
structures have fixed arity, there is no real need to restrict ourselves to
fixed arity structures for the purpose of unification because we’ve already
implemented unification between lists!</p>
<p>So, let’s model such an arbitrary structure as a Racket <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">struct</span></span></code>. We
borrow a term used in Prolog – “functor” – for this purpose. In Prolog, in an
expression of the form <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">word</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">arg1</span></span><span class="operator"><span class="pre">,</span></span><span class="name"><span class="pre">arg2</span></span><span class="operator"><span class="pre">,</span></span><span class="keyword"><span class="pre">…</span></span><span class="punctuation"><span class="pre">)</span></span></code> the <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">word</span></span></code> is referred
to as a “functor”.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">struct</span> <span class="n">FExpr</span> <span class="p">(</span><span class="n">functor</span> <span class="n">args</span><span class="p">))</span>
<span class="c1">; functor is a symbol</span>
<span class="c1">; args is a list of values.</span>
</pre></div>
</div>
<p>When our new <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">unify</span></span></code> tries to match two functors, we’re going to demand
that their <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">name</span></span></code> parts match exactly and both be symbols (and,
in particular, not variables). For the fields themselves, we can bank on our
support for matching two lists.</p>
<div class="admonition-design-question admonition">
<p class="admonition-title"><strong>Design question</strong></p>
<p>Should we permit matching a variable against an entire sublist of fields of
a particular functor? i.e. Should our unify support unification between
<code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">FExpr</span></span> <span class="operator"><span class="pre">‘</span></span><span class="literal string symbol"><span class="pre">f</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">cons</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">Var</span></span> <span class="literal string double"><span class="pre">“one”</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">Var</span></span> <span class="literal string double"><span class="pre">“two”</span></span><span class="punctuation"><span class="pre">)))</span></span></code> and <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">FExpr</span></span> <span class="operator"><span class="pre">‘</span></span><span class="literal string symbol"><span class="pre">f</span></span>
<span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">list</span></span> <span class="literal number integer"><span class="pre">1</span></span> <span class="literal number integer"><span class="pre">2</span></span> <span class="literal number integer"><span class="pre">3</span></span> <span class="literal number integer"><span class="pre">4</span></span><span class="punctuation"><span class="pre">))</span></span></code>? What are the consequences of permitting versus not permitting
such a unification?</p>
</div>
<p>We’re going to assume that we cannot do “partial list of fields” matching between
two functors. We want the fields to match in count. i.e. We’re going to demand that
<code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">fields</span></span></code> actually be a <strong>list</strong> and not merely be a sequence of nested conses.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">valid-fexpr?</span> <span class="n">f</span><span class="p">)</span>
    <span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="n">FExpr?</span> <span class="n">f</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">symbol?</span> <span class="p">(</span><span class="n">FExpr-functor</span> <span class="n">f</span><span class="p">))</span>
         <span class="p">(</span><span class="nb">list?</span> <span class="p">(</span><span class="n">FExpr-args</span> <span class="n">f</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">occurs?</span> <span class="n">var</span> <span class="n">expr</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span>
        <span class="p">[(</span><span class="nb">pair?</span> <span class="n">expr</span><span class="p">)</span>
         <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="n">occurs?</span> <span class="n">var</span> <span class="p">(</span><span class="nb">car</span> <span class="n">expr</span><span class="p">))</span>
             <span class="p">(</span><span class="n">occurs?</span> <span class="n">var</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">expr</span><span class="p">)))]</span>
        <span class="p">[(</span><span class="n">valid-fexpr?</span> <span class="n">expr</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">ormap</span> <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">(</span><span class="n">occurs?</span> <span class="n">var</span> <span class="n">e</span><span class="p">))</span> <span class="p">(</span><span class="n">FExpr-args</span> <span class="n">expr</span><span class="p">))]</span>
        <span class="p">[</span><span class="k">else</span> <span class="p">(</span><span class="nb">eq?</span> <span class="n">var</span> <span class="n">expr</span><span class="p">)]))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">unify</span> <span class="n">A</span> <span class="n">B</span> <span class="n">bset</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">av</span> <span class="p">(</span><span class="n">walk</span> <span class="n">A</span> <span class="n">bset</span><span class="p">)]</span>
          <span class="p">[</span><span class="n">bv</span> <span class="p">(</span><span class="n">walk</span> <span class="n">B</span> <span class="n">bset</span><span class="p">)])</span>
          <span class="c1">; By taking the walked end values for both LHS and RHS</span>
          <span class="c1">; of the unification, we&#39;re guaranteed that both never</span>
          <span class="c1">; appear as the key in our bindings set.</span>
        <span class="p">(</span><span class="k">cond</span>
            <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="n">Var?</span> <span class="n">av</span><span class="p">)</span> <span class="p">(</span><span class="n">Var?</span> <span class="n">bv</span><span class="p">)</span> <span class="p">(</span><span class="nb">equal?</span> <span class="n">av</span> <span class="n">bv</span><span class="p">))</span>
             <span class="n">bset</span><span class="p">]</span>
            <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="n">Var?</span> <span class="n">av</span><span class="p">)</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="n">occurs?</span> <span class="n">av</span> <span class="n">bv</span><span class="p">)))</span>
             <span class="p">(</span><span class="n">extend</span> <span class="n">av</span> <span class="n">bv</span> <span class="n">bset</span><span class="p">)]</span>
            <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="n">Var?</span> <span class="n">bv</span><span class="p">)</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="n">occurs?</span> <span class="n">bv</span> <span class="n">av</span><span class="p">)))</span>
             <span class="p">(</span><span class="n">extend</span> <span class="n">bv</span> <span class="n">av</span> <span class="n">bset</span><span class="p">)]</span>
            <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nb">pair?</span> <span class="n">av</span><span class="p">)</span> <span class="p">(</span><span class="nb">pair?</span> <span class="n">bv</span><span class="p">)</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">empty?</span> <span class="n">av</span><span class="p">))</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">empty?</span> <span class="n">bv</span><span class="p">)))</span>
             <span class="c1">; We have to use car and cdr here instead of first</span>
             <span class="c1">; and rest because the latter two require the</span>
             <span class="c1">; pair to be a non-empty list ... which is not a</span>
             <span class="c1">; constraint we require to be met by the two pairs.</span>
             <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">b2</span> <span class="p">(</span><span class="n">unify</span> <span class="p">(</span><span class="nb">car</span> <span class="n">av</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="n">bv</span><span class="p">)</span> <span class="n">bset</span><span class="p">)])</span>
                 <span class="p">(</span><span class="n">unify</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">av</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">bv</span><span class="p">)</span> <span class="n">b2</span><span class="p">))]</span>
            <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="n">valid-fexpr?</span> <span class="n">av</span><span class="p">)</span>
                  <span class="p">(</span><span class="n">valid-fexpr?</span> <span class="n">bv</span><span class="p">)</span>
                  <span class="p">(</span><span class="nb">equal?</span> <span class="p">(</span><span class="n">FExpr-functor</span> <span class="n">av</span><span class="p">)</span> <span class="p">(</span><span class="n">FExpr-functor</span> <span class="n">bv</span><span class="p">))</span>
                  <span class="p">(</span><span class="nb">equal?</span> <span class="p">(</span><span class="nb">length</span> <span class="p">(</span><span class="n">FExpr-args</span> <span class="n">av</span><span class="p">))</span> <span class="p">(</span><span class="nb">length</span> <span class="p">(</span><span class="n">FExpr-args</span> <span class="n">bv</span><span class="p">))))</span>
             <span class="c1">; We already know how to unify lists!</span>
             <span class="c1">; Here we&#39;re relying on the previous cond case, which</span>
             <span class="c1">; works with general nested pairs and hence also works with lists</span>
             <span class="c1">; ... which is what we&#39;re limiting ourselves to in this case.</span>
             <span class="p">(</span><span class="n">unify</span> <span class="p">(</span><span class="n">FExpr-args</span> <span class="n">av</span><span class="p">)</span> <span class="p">(</span><span class="n">FExpr-args</span> <span class="n">bv</span><span class="p">)</span> <span class="n">bset</span><span class="p">)]</span>
            <span class="p">[(</span><span class="nb">eq?</span> <span class="n">av</span> <span class="n">bv</span><span class="p">)</span>
             <span class="n">bset</span><span class="p">]</span>
            <span class="c1">; Produce #f in all other cases.</span>
            <span class="p">[</span><span class="k">else</span> <span class="no">#f</span><span class="p">])))</span>
</pre></div>
</div>
<div class="admonition-questions admonition">
<p class="admonition-title"><strong>Questions</strong></p>
<p>What can you imagine using the above extension for? After all, programming
languages are there to wish our imaginations into existence. So what wizard
powers did the above extensions to unify (relative to the first cut) give
you? What kinds of goals would you try it on?</p>
<p><strong>Hint</strong>: For one thing, you can model <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">pair</span></span></code> itself using
<code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">FExpr</span></span> <span class="operator"><span class="pre">‘</span></span><span class="literal string symbol"><span class="pre">cons</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">list</span></span> <span class="name"><span class="pre">&lt;head&gt;</span></span> <span class="name"><span class="pre">&lt;tail&gt;</span></span><span class="punctuation"><span class="pre">))</span></span></code>.</p>
</div>
</div>
<div class="section" id="prolog">
<h2>Prolog<a class="headerlink" href="#prolog" title="Permalink to this headline">¶</a></h2>
<p>Prolog is a language in which key ideas we discussed above – <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">unify</span></span></code>, the
notion of “goals”, and <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">disj</span></span></code> / <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">conj</span></span></code> as “goal combinators” – are
available as language level primitives.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a bit of a lie. While logically Prolog tries to do what we
presented in this section, it doesn’t do it using the same mechanism. The
mechanism employed is “backtracking depth-first search”, similar to what we
did in the last section on generators. The choice of mechanism has some
interesting conseqences for the language design, with Prolog getting some
not-quite-logical behaviours as a consequence of turning this into a
practical language (which it certainly is) and our implementation being that
much purer, but far less efficient than Prolog for large problems … can
you see why it can be inefficient?</p>
</div>
<ol class="arabic simple">
<li><p><code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">unify</span></span></code> is simply <code class="code highlight racket docutils literal notranslate"><span class="name builtin"><span class="pre">=</span></span></code> in Prolog</p></li>
<li><p><code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">disj</span></span></code> between goals is represented as an infix operator <code class="code highlight racket docutils literal notranslate"><span class="comment single"><span class="pre">;</span></span></code></p></li>
<li><p><code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">conj</span></span></code> between goals is represented as an infix operator <code class="code highlight racket docutils literal notranslate"><span class="operator"><span class="pre">,</span></span></code></p></li>
<li><p><code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">FExpr</span></span> <span class="operator"><span class="pre">‘</span></span><span class="literal string symbol"><span class="pre">functor</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">list</span></span> <span class="name"><span class="pre">Arg1</span></span> <span class="name"><span class="pre">Arg2</span></span> <span class="keyword"><span class="pre">…</span></span><span class="punctuation"><span class="pre">))</span></span></code> is represented as
<code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">functor</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">Arg1</span></span><span class="operator"><span class="pre">,</span></span><span class="name"><span class="pre">Arg2</span></span><span class="operator"><span class="pre">,</span></span><span class="keyword"><span class="pre">…</span></span><span class="punctuation"><span class="pre">)</span></span></code> in Prolog.</p></li>
<li><p>Prolog has “predicates” which express a goal in terms of subgoals using
combinators like <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">disj</span></span></code> and <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">conj</span></span></code> – i.e. <code class="code highlight racket docutils literal notranslate"><span class="operator"><span class="pre">,</span></span></code> and <code class="code highlight racket docutils literal notranslate"><span class="comment single"><span class="pre">;</span></span></code>
operators. These predicates are declared in a function-like manner where
formal parameters first get unified with actual parameters before the
subgoals are solved. (We’ll see examples below) Predicates have only
two results – either they succeed and produce a set of bindings required
for them to succeed, or they fail.</p></li>
</ol>
<p>As a notational convenience, identifiers that start with a capitalized letter
– like <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">Result</span></span></code>, <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">Any</span></span></code> – are variables and identifiers that start
with a lower case letter – like <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">some</span></span></code>, <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">disj</span></span></code> – are ordinary
symbols, much like Scheme symbols.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference external" href="https://www.swi-prolog.org/">SWI Prolog</a> is a free and rich+powerful Prolog engine you can play
with. You can write web services with it too if you want to, write solvers
for some kinds of optimization problems, use it as a sophisticated search
engine on a database of facts and so on.</p>
</div>
<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<p>Consider the following block of code. Place it in a file named <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">presence.pl</span></span></code>.
Then run <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">swipl</span></span></code> and on the REPL type <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">[</span></span><span class="name"><span class="pre">presence</span></span><span class="punctuation"><span class="pre">]</span></span><span class="operator"><span class="pre">.</span></span></code> (including the period
at the end), followed by return key. Now the module is loaded for you to play with.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="p">:-</span> <span class="nf">module</span><span class="p">(</span><span class="s s-Atom">presence</span><span class="p">,</span> <span class="p">[</span><span class="s s-Atom">is_in</span><span class="o">/</span><span class="mi">2</span><span class="p">]).</span> <span class="c1">% A standard module declaration. Ignore this for now.</span>

<span class="c1">% Declare some facts. Facts are simply predicates that are declared to be true.</span>
<span class="nf">is_in</span><span class="p">(</span><span class="s s-Atom">srikumar</span><span class="p">,</span> <span class="s s-Atom">chennai</span><span class="p">).</span>
<span class="nf">is_in</span><span class="p">(</span><span class="s s-Atom">chennai</span><span class="p">,</span> <span class="s s-Atom">tamilnadu</span><span class="p">).</span>
<span class="nf">is_in</span><span class="p">(</span><span class="s s-Atom">tamilnadu</span><span class="p">,</span> <span class="s s-Atom">india</span><span class="p">).</span>

<span class="c1">% This predicate depends on other subgoals being met.</span>
<span class="c1">% Here we&#39;re saying that is A is in C and C is in B, then A is in B.</span>
<span class="nf">is_in</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span> <span class="nv">B</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">is_in</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span> <span class="nv">C</span><span class="p">),</span> <span class="c1">% NOTE: comma here means &quot;conjunction&quot; -- i.e. &quot;and&quot;.</span>
    <span class="nf">is_in</span><span class="p">(</span><span class="nv">C</span><span class="p">,</span> <span class="nv">B</span><span class="p">).</span>
</pre></div>
</div>
<p>After loading the module, try the following in the REPL -</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- is_in(tamilnadu, chennai).
false

?- is_in(chennai, X).
X = tamilnadu &lt;hit ; for other possible answers&gt;
X = india &lt;hit ; now&gt;

?- is_in(X, tamilnadu).
X = chennai;
X = srikumar
</pre></div>
</div>
<p>So you can see it can provide all permissible answers to the questions you ask,
and much of this is based on <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">unify</span></span></code>, <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">disj</span></span></code> and <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">conj</span></span></code> as
language primitives!</p>
<p>You can play with Prolog’s unification right on the REPL -</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- A = 5.
?- 5 = A.
?- some(X) = some(other).
?- [1,2,B] = [A,2,C]. % We have Prolog lists on both sides here.
?- A + B = 2 + 3.  % Surprise! Why? Find out through experiments.
?- A + B = 5 - 3.  % Surprise! Why? Find out through experiments.
?- plus(num(5), minus(num(10),num(1))) = plus(A, minus(num(10),B))
</pre></div>
</div>
</div>
</div>
<div class="section" id="our-interpreter-expressed-in-prolog">
<h2>Our interpreter expressed in Prolog<a class="headerlink" href="#our-interpreter-expressed-in-prolog" title="Permalink to this headline">¶</a></h2>
<p>We can actually build our calculator language in Prolog like below –</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="p">:-</span> <span class="nf">module</span><span class="p">(</span><span class="s s-Atom">interp</span><span class="p">,</span> <span class="p">[</span><span class="s s-Atom">interp</span><span class="o">/</span><span class="mi">2</span><span class="p">]).</span>

<span class="nf">interp</span><span class="p">(</span><span class="nf">num</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nv">Result</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nv">Result</span> <span class="o">=</span> <span class="nv">X</span><span class="p">.</span>

<span class="nf">interp</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span> <span class="nv">B</span><span class="p">),</span> <span class="nv">Result</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">interp</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span> <span class="nv">RA</span><span class="p">),</span>
    <span class="nf">interp</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span> <span class="nv">RB</span><span class="p">),</span>
    <span class="nv">Result</span> <span class="o">is</span> <span class="nv">RA</span> <span class="o">+</span> <span class="nv">RB</span><span class="p">.</span> <span class="c1">% Note &quot;is&quot; instead of &quot;=&quot; actually does calculation.</span>

<span class="nf">interp</span><span class="p">(</span><span class="nf">sub</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span> <span class="nv">B</span><span class="p">),</span> <span class="nv">Result</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">interp</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span> <span class="nv">RA</span><span class="p">),</span>
    <span class="nf">interp</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span> <span class="nv">RB</span><span class="p">),</span>
    <span class="nv">Result</span> <span class="o">is</span> <span class="nv">RA</span> <span class="o">-</span> <span class="nv">RB</span><span class="p">.</span>

<span class="nf">interp</span><span class="p">(</span><span class="nf">mul</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span> <span class="nv">B</span><span class="p">),</span> <span class="nv">Result</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">interp</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span> <span class="nv">RA</span><span class="p">),</span>
    <span class="nf">interp</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span> <span class="nv">RB</span><span class="p">),</span>
    <span class="nv">Result</span> <span class="o">is</span> <span class="nv">RA</span> <span class="o">*</span> <span class="nv">RB</span><span class="p">.</span>
</pre></div>
</div>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Study the above Prolog module source and compare it with our Scheme based interpreter
for the arithmetic language. How is the recursive evaluation handled in both places?
See how we use unification here where we used <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code> in Racket?</p>
</div>
<p>Now try the following after loading the above module.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- interp(add(num(10), mul(num(3), num(4))), Result).
</pre></div>
</div>
</div>
<div class="section" id="adding-functions-to-our-interpreter">
<h2>Adding functions to our interpreter<a class="headerlink" href="#adding-functions-to-our-interpreter" title="Permalink to this headline">¶</a></h2>
<p>To add functions to our language, we’ve seen that we need three things -</p>
<ol class="arabic simple">
<li><p>A term to represent an “identifier”</p></li>
<li><p>A term to represent “function application”</p></li>
<li><p>A term to represent a “function expression”</p></li>
</ol>
<p>We also need to introduce the idea of a “evaluation environment” that keeps
track of bindings between identifiers and values that we should substitute
for them in calculation. We also have to extend our interpreter to support
more than just “number” as a value type.</p>
<p>So we need to add the following -</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="p">:-</span> <span class="nf">module</span><span class="p">(</span><span class="s s-Atom">interp</span><span class="p">,</span> <span class="p">[</span><span class="s s-Atom">interp</span><span class="o">/</span><span class="mi">3</span><span class="p">]).</span>

<span class="nf">interp</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="nf">num</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nf">num</span><span class="p">(</span><span class="nv">Result</span><span class="p">))</span> <span class="p">:-</span>
    <span class="nv">Result</span> <span class="o">=</span> <span class="nv">X</span><span class="p">.</span>

<span class="nf">interp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span> <span class="nv">B</span><span class="p">),</span> <span class="nf">num</span><span class="p">(</span><span class="nv">Result</span><span class="p">))</span> <span class="p">:-</span>
    <span class="nf">interp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span> <span class="nv">A</span><span class="p">,</span> <span class="nf">num</span><span class="p">(</span><span class="nv">RA</span><span class="p">)),</span>
    <span class="nf">interp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span> <span class="nv">B</span><span class="p">,</span> <span class="nf">num</span><span class="p">(</span><span class="nv">RB</span><span class="p">)),</span>
    <span class="nv">Result</span> <span class="o">is</span> <span class="nv">RA</span> <span class="o">+</span> <span class="nv">RB</span><span class="p">.</span> <span class="c1">% Note &quot;is&quot; instead of &quot;=&quot; actually does calculation.</span>

<span class="nf">interp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span> <span class="nf">sub</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span> <span class="nv">B</span><span class="p">),</span> <span class="nf">num</span><span class="p">(</span><span class="nv">Result</span><span class="p">))</span> <span class="p">:-</span>
    <span class="nf">interp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span> <span class="nv">A</span><span class="p">,</span> <span class="nf">num</span><span class="p">(</span><span class="nv">RA</span><span class="p">)),</span>
    <span class="nf">interp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span> <span class="nv">B</span><span class="p">,</span> <span class="nf">num</span><span class="p">(</span><span class="nv">RB</span><span class="p">)),</span>
    <span class="nv">Result</span> <span class="o">is</span> <span class="nv">RA</span> <span class="o">-</span> <span class="nv">RB</span><span class="p">.</span>

<span class="nf">interp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span> <span class="nf">mul</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span> <span class="nv">B</span><span class="p">),</span> <span class="nf">num</span><span class="p">(</span><span class="nv">Result</span><span class="p">))</span> <span class="p">:-</span>
    <span class="nf">interp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span> <span class="nv">A</span><span class="p">,</span> <span class="nf">num</span><span class="p">(</span><span class="nv">RA</span><span class="p">)),</span>
    <span class="nf">interp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span> <span class="nv">B</span><span class="p">,</span> <span class="nf">num</span><span class="p">(</span><span class="nv">RB</span><span class="p">)),</span>
    <span class="nv">Result</span> <span class="o">is</span> <span class="nv">RA</span> <span class="o">*</span> <span class="nv">RB</span><span class="p">.</span>

<span class="nf">interp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span> <span class="nf">id</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nv">Result</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">atom</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span>
    <span class="nf">member</span><span class="p">(</span><span class="nv">X</span> <span class="o">=</span> <span class="nv">Result</span><span class="p">,</span> <span class="nv">Env</span><span class="p">).</span>

<span class="nf">interp</span><span class="p">(</span><span class="nv">DefnEnv</span><span class="p">,</span> <span class="nf">fun</span><span class="p">(</span><span class="nv">ArgSym</span><span class="p">,</span> <span class="nv">Body</span><span class="p">),</span> <span class="nf">fun</span><span class="p">(</span><span class="nv">DefnEnv</span><span class="p">,</span> <span class="nv">ArgSym</span><span class="p">,</span> <span class="nv">Body</span><span class="p">)).</span>

<span class="nf">interp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span> <span class="nf">apply</span><span class="p">(</span><span class="nv">Fun</span><span class="p">,</span> <span class="nv">Arg</span><span class="p">),</span> <span class="nv">Result</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">interp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span> <span class="nv">Fun</span><span class="p">,</span> <span class="nf">fun</span><span class="p">(</span><span class="nv">DefEnv</span><span class="p">,</span> <span class="nv">ArgSym</span><span class="p">,</span> <span class="nv">Body</span><span class="p">)),</span>
    <span class="nf">interp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span> <span class="nv">Arg</span><span class="p">,</span> <span class="nv">ArgVal</span><span class="p">),</span>
    <span class="nf">interp</span><span class="p">([</span><span class="nv">ArgSym</span> <span class="o">=</span> <span class="nv">ArgVal</span><span class="p">|</span><span class="nv">DefEnv</span><span class="p">],</span> <span class="nv">Body</span><span class="p">,</span> <span class="nv">Result</span><span class="p">).</span>
</pre></div>
</div>
<p>The expression <code class="code docutils literal notranslate"><span class="pre">[ArgSym</span> <span class="pre">=</span> <span class="pre">ArgVal|DefEnv]</span></code> adds a term <code class="code docutils literal notranslate"><span class="pre">ArgSym</span> <span class="pre">=</span> <span class="pre">ArgVal</span></code>
which is a pair of values along with the functor <code class="code docutils literal notranslate"><span class="pre">=</span></code>, to the head of the
environment list <code class="code docutils literal notranslate"><span class="pre">DefEnv</span></code>.</p>
<p>Using <code class="code docutils literal notranslate"><span class="pre">=</span></code> as the functor helps readability but could be confusing about
whether any binding is happening in <strong>prolog</strong>. To clarify that, you could’ve
used any functor name, for example, you can use <code class="code docutils literal notranslate"><span class="pre">bind</span></code> like this too –
<code class="code docutils literal notranslate"><span class="pre">[bind(ArgSym,ArgVal)|DefEnv]</span></code> – as long as you also modify the
interpretation of <code class="code docutils literal notranslate"><span class="pre">id(X)</span></code> to use <code class="code docutils literal notranslate"><span class="pre">member(bind(X,Result),</span> <span class="pre">Env)</span></code>
instead of <code class="code docutils literal notranslate"><span class="pre">member(X</span> <span class="pre">=</span> <span class="pre">Result,</span> <span class="pre">Env)</span></code>.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Add booleans and conditional expressions to this interpreter.</p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Comp308: Principles of Programming Languages</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Welcome note</a></li>
<li class="toctree-l1"><a class="reference internal" href="racket-intro.html">A quick introduction to Racket and Scheme</a></li>
<li class="toctree-l1"><a class="reference internal" href="lambda.html">Lambda - the everything</a></li>
<li class="toctree-l1"><a class="reference internal" href="piclang.html">A language for pictures</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine.html">A mental model for the machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="growing.html">Growing the language</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun.html">Functions and scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="stacks-and-scope.html">Stacks and scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun-in-piclang.html">Functions in PicLang</a></li>
<li class="toctree-l1"><a class="reference internal" href="mutations.html">Mutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="control.html">Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="objects.html">Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="generators.html">Generators</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Alternative application semantics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#solving-for-goals">Solving for goals</a></li>
<li class="toctree-l2"><a class="reference internal" href="#goals">Goals</a></li>
<li class="toctree-l2"><a class="reference internal" href="#structural-unification">Structural unification</a></li>
<li class="toctree-l2"><a class="reference internal" href="#generalizing-pair-s">Generalizing “pair”s</a></li>
<li class="toctree-l2"><a class="reference internal" href="#prolog">Prolog</a></li>
<li class="toctree-l2"><a class="reference internal" href="#our-interpreter-expressed-in-prolog">Our interpreter expressed in Prolog</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adding-functions-to-our-interpreter">Adding functions to our interpreter</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="types.html">Types: Checking some program invariants statically</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="generators.html" title="previous chapter">Generators</a></li>
      <li>Next: <a href="types.html" title="next chapter">Types: Checking some program invariants statically</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Srikumar K. S..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/appsem.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>