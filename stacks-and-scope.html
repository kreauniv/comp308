<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Stacks and scope &#8212; Comp308: Principles of Programming Languages v1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=3d3fbe02" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=12dfc556" />
    <script src="_static/documentation_options.js?v=5cb08e4e"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Functions in PicLang" href="fun-in-piclang.html" />
    <link rel="prev" title="Functions and scope (arithmetic track)" href="fun-arith.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="stacks-and-scope">
<h1>Stacks and scope<a class="headerlink" href="#stacks-and-scope" title="Link to this heading">Â¶</a></h1>
<p>We considered a minimally useful <span class="target" id="index-0"></span>stack machine in the preceding quiz,
which is reproduced below for reference -</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="kn">#lang </span><span class="nn">racket</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">stack</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="n">stack</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">stack</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">stack-machine</span><span class="w"> </span><span class="n">program</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">empty?</span><span class="w"> </span><span class="n">program</span><span class="p">)</span>
<span class="w">      </span><span class="n">stack</span>
<span class="w">      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">instr</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">program</span><span class="p">)])</span>
<span class="w">        </span><span class="p">(</span><span class="n">stack-machine</span>
<span class="w">         </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">program</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="n">process-instruction</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">stack</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">process-instruction</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span>
<span class="w">    </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">+</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))]</span>
<span class="w">    </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">-</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))]</span>
<span class="w">    </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">*</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))]</span>
<span class="w">    </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">/</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))]</span>
<span class="w">    </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">dup</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="n">stack</span><span class="p">)]</span>
<span class="w">    </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">rot2</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span>
<span class="w">                 </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">))))]</span>
<span class="w">    </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">rot3</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))</span>
<span class="w">                 </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">))))))]</span>
<span class="w">    </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">rot4</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))</span>
<span class="w">                 </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">))))</span>
<span class="w">                       </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span>
<span class="w">                             </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">))))))))]</span>
<span class="w">    </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">drop</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)]</span>
<span class="w">    </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">sqrt</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">))]</span>
<span class="w">    </span><span class="p">[(</span><span class="nb">number?</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">stack</span><span class="p">)]</span>
<span class="w">    </span><span class="p">[</span><span class="no">#t</span>
<span class="w">     </span><span class="p">(</span><span class="nb">raise-argument-error</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">do-instruction</span><span class="w"> </span><span class="s2">&quot;Valid instruction&quot;</span><span class="w"> </span><span class="n">instr</span><span class="p">)]))</span>
</pre></div>
</div>
<p>This machine lets us perform simple arithmetic calculations. For example,
<code class="code highlight racket docutils literal highlight-racket"><span class="o">&#39;</span><span class="p">(</span><span class="ss">dup</span><span class="w"> </span><span class="ss">*</span><span class="w"> </span><span class="ss">rot2</span><span class="w"> </span><span class="ss">dup</span><span class="w"> </span><span class="ss">*</span><span class="w"> </span><span class="ss">+</span><span class="w"> </span><span class="ss">sqrt</span><span class="p">)</span></code> is a program that can be used to compute the
distance from the origin to a point <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span></code> where the coordinates are
given on the stack. For example,</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">stack-machine</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">dup</span><span class="w"> </span><span class="ss">*</span><span class="w"> </span><span class="ss">rot2</span><span class="w"> </span><span class="ss">dup</span><span class="w"> </span><span class="ss">*</span><span class="w"> </span><span class="ss">+</span><span class="w"> </span><span class="ss">sqrt</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span>
<span class="c1">; Produces &#39;(5) as the result stack</span>
</pre></div>
</div>
<p>While this program is understandable without much effort, it is not obvious
that the program <code class="code highlight racket docutils literal highlight-racket"><span class="o">&#39;</span><span class="p">(</span><span class="ss">dup</span><span class="w"> </span><span class="ss">dup</span><span class="w"> </span><span class="ss">*</span><span class="w"> </span><span class="ss">rot3</span><span class="w"> </span><span class="ss">rot2</span><span class="w"> </span><span class="ss">dup</span><span class="w"> </span><span class="ss">dup</span><span class="w"> </span><span class="ss">*</span><span class="w"> </span><span class="ss">rot3</span><span class="w"> </span><span class="ss">*</span><span class="w"> </span><span class="ss">dup</span><span class="w"> </span><span class="ss">+</span><span class="w"> </span><span class="ss">+</span><span class="w"> </span><span class="ss">+</span><span class="p">)</span></code>
computes the algebraic expression <span class="math notranslate nohighlight">\((a^2 + 2ab + b^2)\)</span>, so that we can
transform it into the equivalent program <code class="code highlight racket docutils literal highlight-racket"><span class="o">&#39;</span><span class="p">(</span><span class="ss">+</span><span class="w"> </span><span class="ss">dup</span><span class="w"> </span><span class="ss">*</span><span class="p">)</span></code> â i.e.
<span class="math notranslate nohighlight">\((a+b)^2\)</span>. Maybe if we work with such expressions enough, weâll build
sufficient algebraic prowess to see how the longer expression can be reduced to
the shorter one.</p>
<p>Given that the mechanisms we donât have prior familiarity with are the
<code class="code highlight racket docutils literal highlight-racket"><span class="n">dup</span></code> and <code class="code highlight racket docutils literal highlight-racket"><span class="n">rotN</span></code> family which juggle elements on the stack in
preparation for future operations, it is easy to see that if we can simply
name the elements on top of the stack, the program can become more comprehensible.
For example, if <code class="code highlight racket docutils literal highlight-racket"><span class="n">a</span></code> and <code class="code highlight racket docutils literal highlight-racket"><span class="n">b</span></code> stood for the top two elements of the stack,
the longer program above could be written as <code class="code highlight racket docutils literal highlight-racket"><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">a</span><span class="w"> </span><span class="ss">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">*</span><span class="w"> </span><span class="ss">*</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">*</span><span class="w"> </span><span class="ss">+</span><span class="w"> </span><span class="ss">+</span><span class="p">)</span></code>,
which is much better for the human reader. Similarly, the distance formula
also can be written as <code class="code highlight racket docutils literal highlight-racket"><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">a</span><span class="w"> </span><span class="ss">*</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">*</span><span class="w"> </span><span class="ss">+</span><span class="w"> </span><span class="ss">sqrt</span><span class="p">)</span></code>.</p>
<p>This version of the distance formula should look familiar!</p>
<p>Consider the expression we wouldâve written in Racket â</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">distance</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">b</span><span class="p">))))</span>

<span class="c1">; Focus on the &quot;sqrt&quot; expression</span>
<span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">b</span><span class="p">)))</span>

<span class="c1">; Remove all the parentheses</span>
<span class="nb">sqrt</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">b</span>
</pre></div>
</div>
<p>This is just the <span class="target" id="index-1"></span>stack machine program written from right to left
order! For this reason, programs like the ones we wrote for the
<code class="code highlight racket docutils literal highlight-racket"><span class="n">stack-machine</span></code> are said to be âpostfix notationâ while LiSPâs notation is
also called âprefix notationâ. LiSPâs notation admits variadic functions
(functions which can take any number of arguments such as <code class="code highlight racket docutils literal highlight-racket"><span class="nb">+</span></code>) whereas
with the postfix notation the âarityâ of an operator, or âwordsâ as operators
are called in such languages, is in general fixed. âArityâ refers to the number
of arguments to a function or procedure.</p>
<div class="admonition-aside admonition">
<p class="admonition-title"><strong>Aside</strong></p>
<p>Apart from <a class="reference external" href="https://en.wikipedia.org/wiki/Forth_(programming_language)">Forth</a> being the canonical âpostfix notation languageâ, you
perhaps pretty much use a postfix language on a daily basis without knowing
it â <a class="reference external" href="https://en.wikipedia.org/wiki/PostScript">PostScript</a> and PDF files! Adobeâs <a class="reference external" href="https://en.wikipedia.org/wiki/PostScript">PostScript</a> (âPostâ is there in
the name for a reason) is actually a programming language for drawing. PDF
, while advertised as a âportable document formatâ, is a compressed version
of the drawing commands produced by a <a class="reference external" href="https://en.wikipedia.org/wiki/PostScript">PostScript</a> program. Apple (well,
NeXT) also adapted Postscript for use in the NeXT OS for controlling the
display, called <a class="reference external" href="https://en.wikipedia.org/wiki/Display_PostScript">Display PostScript</a> , which enabled the OS to capture
scalable on-screen vector graphics as <a class="reference external" href="https://en.wikipedia.org/wiki/PostScript">PostScript</a> or PDF files easily for
print. As we saw, Postfix languages are very easy to write interpeters for
and these turn out to be low resource processors that can be used in
devices like printers.</p>
</div>
<section id="adding-names-to-the-stack-machine">
<h2>Adding names to the stack-machine<a class="headerlink" href="#adding-names-to-the-stack-machine" title="Link to this heading">Â¶</a></h2>
<p>So weâd like to be able to â<span class="target" id="index-2"></span>bindâ symbols to values picked from the
stack so we can recall them whenever we need their values. For this, we need a
kind of âdictionaryâ in which we can lookup values associated with symbols.
There is a Scheme function <code class="code highlight racket docutils literal highlight-racket"><span class="nb">assoc</span></code> thatâll do this for us -</p>
<div class="highlight-racket notranslate" id="index-3"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">alist</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">one</span><span class="w"> </span><span class="s2">&quot;ek&quot;</span><span class="p">)</span>
<span class="w">                    </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">two</span><span class="w"> </span><span class="s2">&quot;do&quot;</span><span class="p">)</span>
<span class="w">                    </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">three</span><span class="w"> </span><span class="s2">&quot;teen&quot;</span><span class="p">)</span>
<span class="w">                    </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">three</span><span class="w"> </span><span class="s2">&quot;theen&quot;</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">display</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">three</span><span class="w"> </span><span class="n">alist</span><span class="p">))</span>
<span class="c1">; Prints out (three &quot;teen&quot;)</span>
<span class="c1">; Notice that only the first occurrence is returned.</span>
<span class="p">(</span><span class="nb">display</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">four</span><span class="w"> </span><span class="n">alist</span><span class="p">)</span>
<span class="c1">; Prints out #f to indicate &quot;not found&quot;.</span>
</pre></div>
</div>
<p>So letâs augment our stack machine with such a â<span class="target" id="index-4"></span>dictionaryâ and
interpret âsymbolsâ we find in the instruction stream to mean âlookup this
symbol in the dictionary and push the value you find on the top of the stackâ.
Weâll call this dictionary âbindingsâ because it is a list of symbols bound to
values. Weâll also add a new âcompound instructionâ for popping off a value
from the stack and binding it to a symbol - as <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">def</span><span class="w"> </span><span class="n">&lt;symbol&gt;</span><span class="p">)</span></code>.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="c1">; Since our stack-machine now has to consume a stack</span>
<span class="c1">; and a bindings list and produce new versions of those</span>
<span class="c1">; as a result, we&#39;ll group them into a simple struct</span>
<span class="c1">; we&#39;ll call &quot;State&quot;.</span>
<span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">stack</span><span class="w"> </span><span class="n">bindings</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">stack-machine</span><span class="w"> </span><span class="n">program</span><span class="w"> </span><span class="n">state</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">empty?</span><span class="w"> </span><span class="n">program</span><span class="p">)</span>
<span class="w">      </span><span class="n">state</span>
<span class="w">      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">instr</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">program</span><span class="p">)])</span>
<span class="w">        </span><span class="p">(</span><span class="n">stack-machine</span>
<span class="w">         </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">program</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="n">process-instruction</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">state</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">process-instruction</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">state</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="n">state</span>
<span class="w">     </span><span class="p">[(</span><span class="n">State</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="n">bindings</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">cond</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">+</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))</span><span class="w"> </span><span class="n">bindings</span><span class="p">)]</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">-</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))</span><span class="w"> </span><span class="n">bindings</span><span class="p">)]</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">*</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))</span><span class="w"> </span><span class="n">bindings</span><span class="p">)]</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">/</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))</span><span class="w"> </span><span class="n">bindings</span><span class="p">)]</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">dup</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="n">bindings</span><span class="p">)]</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">rot2</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">))</span>
<span class="w">                      </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span>
<span class="w">                            </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">))))</span>
<span class="w">                </span><span class="n">bindings</span><span class="p">)]</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">rot3</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">))</span>
<span class="w">                      </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))</span>
<span class="w">                            </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">))))))</span>
<span class="w">                </span><span class="n">bindings</span><span class="p">)]</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">rot4</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">))</span>
<span class="w">                      </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)))</span>
<span class="w">                            </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">))))</span>
<span class="w">                                  </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span>
<span class="w">                                        </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">))))))))</span>
<span class="w">                </span><span class="n">bindings</span><span class="p">)]</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">drop</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="n">bindings</span><span class="p">)]</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">sqrt</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">))</span><span class="w"> </span><span class="n">bindings</span><span class="p">)]</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">number?</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="n">bindings</span><span class="p">)]</span>
<span class="w">        </span><span class="c1">; Handle (def &lt;symbol&gt;) instruction</span>
<span class="w">        </span><span class="p">[(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">list?</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nb">empty?</span><span class="w"> </span><span class="n">instr</span><span class="p">))</span>
<span class="w">              </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">def</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">symbol?</span><span class="w"> </span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="n">instr</span><span class="p">)))</span>
<span class="w">         </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">))</span><span class="w"> </span><span class="n">bindings</span><span class="p">))]</span>
<span class="w">        </span><span class="c1">; Handle symbols that occur that we don&#39;t already know about</span>
<span class="w">        </span><span class="c1">; as a &quot;lookup operation&quot;</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">symbol?</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">bindings</span><span class="p">)</span>
<span class="w">             </span><span class="p">[(</span><span class="nb">list</span><span class="w"> </span><span class="n">sym</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="n">bindings</span><span class="p">)]</span>
<span class="w">             </span><span class="p">[</span><span class="no">#f</span><span class="w"> </span><span class="p">(</span><span class="nb">raise-argument-error</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">process-instruction</span>
<span class="w">                                       </span><span class="s2">&quot;Defined symbol expected&quot;</span>
<span class="w">                                       </span><span class="n">instr</span><span class="p">)])]</span>
<span class="w">        </span><span class="p">[</span><span class="no">#t</span>
<span class="w">         </span><span class="p">(</span><span class="nb">raise-argument-error</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">process-instruction</span><span class="w"> </span><span class="s2">&quot;Valid instruction&quot;</span><span class="w"> </span><span class="n">instr</span><span class="p">)])]))</span>
</pre></div>
</div>
<p>With these two additions, we can now express our âEuclidean distanceâ function
as <code class="code highlight racket docutils literal highlight-racket"><span class="p">((</span><span class="n">def</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">def</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="nb">sqrt</span><span class="p">)</span></code>. Note how this closely
resembles <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">y</span><span class="p">)))))</span></code>.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>To make the resemblance to <code class="code highlight racket docutils literal highlight-racket"><span class="k">lambda</span></code> even closer, modify the
implementation of the <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">def</span><span class="w"> </span><span class="n">&lt;symbol&gt;</span><span class="p">)</span></code> instruction to support multiple
symbols. The idea is to pull one value off the stack for each symbol and
bind it to the corresponding symbol. So encountering a <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">def</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span></code>
instruction will cause our machine to pull the top two values from the
stack and bind them to <code class="code highlight racket docutils literal highlight-racket"><span class="n">x</span></code> and <code class="code highlight racket docutils literal highlight-racket"><span class="n">y</span></code>.</p>
</div>
</section>
<section id="blocks">
<h2>Blocks<a class="headerlink" href="#blocks" title="Link to this heading">Â¶</a></h2>
<p>Though weâve been able to bind symbols to values and use them, our
stack-machine programming language does not have the ability to reuse such
calculations. For example, weâll have to repeat the whole distance calculation
code whenever we need to do it.</p>
<p>We can invent another type of value â the â<span class="target" id="index-5"></span>blockâ â which contains a
list of instructions (a âprogramâ) that we can store bound to a symbol and
âinvokeâ whenever we need. Surprisingly, this requires only a small change to
our stack-machine. Weâll also have to add a <code class="code highlight racket docutils literal highlight-racket"><span class="k">do</span></code> instruction that will pop
a block off the top of the stack and run its program on the stack.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="n">Block</span><span class="w"> </span><span class="p">(</span><span class="n">program</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">process-instruction</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">state</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="n">state</span>
<span class="w">     </span><span class="p">[(</span><span class="n">State</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="n">bindings</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">cond</span>
<span class="w">        </span><span class="c1">; &lt;common-operators&gt;</span>
<span class="w">        </span><span class="c1">; ...</span>
<span class="w">        </span><span class="c1">; &lt;/common-operators&gt;</span>

<span class="w">        </span><span class="c1">; A &quot;block&quot; compound instruction is given like (block dup + sqrt)</span>
<span class="w">        </span><span class="p">[(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">list?</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nb">empty?</span><span class="w"> </span><span class="n">instr</span><span class="p">))</span>
<span class="w">              </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">block</span><span class="p">))</span>
<span class="w">         </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">Block</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">instr</span><span class="p">))</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="n">bindings</span><span class="p">)]</span>

<span class="w">        </span><span class="c1">; A &quot;do&quot; instruction will pop a Block value off the top of the</span>
<span class="w">        </span><span class="c1">; stack and &quot;run&quot; it.</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">do</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span>
<span class="w">             </span><span class="p">[(</span><span class="n">Block</span><span class="w"> </span><span class="n">program</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="n">stack-machine</span><span class="w"> </span><span class="n">program</span><span class="w"> </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="n">bindings</span><span class="p">))]</span>
<span class="w">             </span><span class="p">[</span><span class="k">_</span><span class="w"> </span><span class="p">(</span><span class="nb">raise-argument-error</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">process-instruction</span>
<span class="w">                                      </span><span class="s2">&quot;Block value on stack&quot;</span>
<span class="w">                                      </span><span class="n">stack</span><span class="p">)])]</span>

<span class="w">        </span><span class="c1">; Handle (def &lt;symbol&gt;) instruction</span>
<span class="w">        </span><span class="p">[(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">list?</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nb">empty?</span><span class="w"> </span><span class="n">instr</span><span class="p">))</span>
<span class="w">              </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">def</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">symbol?</span><span class="w"> </span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="n">instr</span><span class="p">)))</span>
<span class="w">         </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">))</span><span class="w"> </span><span class="n">bindings</span><span class="p">))]</span>

<span class="w">        </span><span class="c1">; Handle symbols that occur that we don&#39;t already know about</span>
<span class="w">        </span><span class="c1">; as a &quot;lookup operation&quot;</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">symbol?</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">bindings</span><span class="p">)</span>
<span class="w">             </span><span class="p">[(</span><span class="nb">list</span><span class="w"> </span><span class="n">sym</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="n">bindings</span><span class="p">)]</span>
<span class="w">             </span><span class="p">[</span><span class="no">#f</span><span class="w"> </span><span class="p">(</span><span class="nb">raise-argument-error</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">process-instruction</span>
<span class="w">                                       </span><span class="s2">&quot;Defined symbol expected&quot;</span>
<span class="w">                                       </span><span class="n">instr</span><span class="p">)])]</span>

<span class="w">        </span><span class="p">[</span><span class="no">#t</span>
<span class="w">         </span><span class="p">(</span><span class="nb">raise-argument-error</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">process-instruction</span><span class="w"> </span><span class="s2">&quot;Valid instruction&quot;</span><span class="w"> </span><span class="n">instr</span><span class="p">)])]))</span>
</pre></div>
</div>
<p>Now, weâre actually equipped to define a âeuclidean distanceâ function in our
stack-machine language!</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">program</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="ss">block</span><span class="w"> </span><span class="p">(</span><span class="ss">def</span><span class="w"> </span><span class="ss">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="ss">def</span><span class="w"> </span><span class="ss">y</span><span class="p">)</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">*</span><span class="w"> </span><span class="ss">y</span><span class="w"> </span><span class="ss">y</span><span class="w"> </span><span class="ss">*</span><span class="w"> </span><span class="ss">+</span><span class="w"> </span><span class="ss">sqrt</span><span class="p">)</span>
<span class="w">                   </span><span class="p">(</span><span class="ss">def</span><span class="w"> </span><span class="ss">distance</span><span class="p">)</span>
<span class="w">                   </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="ss">distance</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="p">(</span><span class="n">display-state</span><span class="w"> </span><span class="p">(</span><span class="n">stack-machine</span><span class="w"> </span><span class="n">program</span><span class="w"> </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())))</span>
<span class="c1">; Prints out (5) as the result stack.</span>
</pre></div>
</div>
</section>
<section id="which-programs-are-valid-blocks">
<h2>Which programs are valid blocks?<a class="headerlink" href="#which-programs-are-valid-blocks" title="Link to this heading">Â¶</a></h2>
<p>The way weâve implemented block execution, the final value of a blockâs
bindings will be available after block execution. So the following
program will actually produce a value with our stack-machine.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">stack-machine</span><span class="w"> </span><span class="o">&#39;</span><span class="p">((</span><span class="ss">block</span><span class="w"> </span><span class="p">(</span><span class="ss">def</span><span class="w"> </span><span class="ss">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="ss">def</span><span class="w"> </span><span class="ss">y</span><span class="p">)</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">*</span><span class="w"> </span><span class="ss">y</span><span class="w"> </span><span class="ss">y</span><span class="w"> </span><span class="ss">*</span><span class="w"> </span><span class="ss">+</span><span class="w"> </span><span class="ss">sqrt</span><span class="p">)</span>
<span class="w">                 </span><span class="p">(</span><span class="ss">def</span><span class="w"> </span><span class="ss">distance</span><span class="p">)</span>
<span class="w">                 </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="ss">distance</span><span class="w"> </span><span class="ss">do</span>
<span class="w">                 </span><span class="ss">x</span><span class="w"> </span><span class="ss">y</span><span class="w"> </span><span class="ss">+</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()))</span>
<span class="c1">; will produce (7 5) as the result stack.</span>
</pre></div>
</div>
<p>What does this program really mean? Why should the <code class="code highlight racket docutils literal highlight-racket"><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="nb">+</span></code> part
of the program care what variable names the block implementing the
<code class="code highlight racket docutils literal highlight-racket"><span class="n">distance</span></code> calculation uses <strong>internally</strong>?</p>
<p>Our âblockâ defines a âregion of codeâ that we wish to be self contained. In
other words, we want âwhat happens within the block, stays within the blockâ to
hold, except for the effect it has on the stack. In yet more words, we want to
throw away all symbol bindings done within the block once the block is done.
We donât want all our variables to be âglobalâ and interfere with each other.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Why is this required?  Think about it before reading on.</p>
</div>
<p>Letâs first fix the problem we noted above, assuming <span class="target" id="index-6"></span>global variables
are âa bad ideaâ.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">process-instruction</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">state</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="n">state</span>
<span class="w">     </span><span class="p">[(</span><span class="n">State</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="n">bindings</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">cond</span>
<span class="w">        </span><span class="c1">; &lt;common-operators&gt;</span>
<span class="w">        </span><span class="c1">; ...</span>
<span class="w">        </span><span class="c1">; &lt;/common-operators&gt;</span>

<span class="w">        </span><span class="c1">; A &quot;block&quot; compound instruction is given like (block dup + sqrt)</span>
<span class="w">        </span><span class="p">[(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">list?</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nb">empty?</span><span class="w"> </span><span class="n">instr</span><span class="p">))</span>
<span class="w">              </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">block</span><span class="p">))</span>
<span class="w">         </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">Block</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">instr</span><span class="p">))</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="n">bindings</span><span class="p">)]</span>

<span class="w">        </span><span class="c1">; A &quot;do&quot; instruction will pop a Block value off the top of the</span>
<span class="w">        </span><span class="c1">; stack and &quot;run&quot; it.</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">do</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span>
<span class="w">             </span><span class="p">[(</span><span class="n">Block</span><span class="w"> </span><span class="n">program</span><span class="p">)</span>
<span class="w">              </span><span class="c1">; &lt;&lt;&lt;----&gt;&gt;&gt;&gt;</span>
<span class="w">              </span><span class="c1">; We&#39;ve modified this expression to consider only the stack</span>
<span class="w">              </span><span class="c1">; as part of the result state of executing a block. We discard</span>
<span class="w">              </span><span class="c1">; the bindings it produces and retain the original bindings list.</span>
<span class="w">              </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">State-stack</span><span class="w"> </span><span class="p">(</span><span class="n">stack-machine</span><span class="w"> </span><span class="n">program</span><span class="w"> </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="n">bindings</span><span class="p">)))</span>
<span class="w">                     </span><span class="n">bindings</span><span class="p">)]</span>
<span class="w">             </span><span class="p">[</span><span class="k">_</span><span class="w"> </span><span class="p">(</span><span class="nb">raise-argument-error</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">process-instruction</span>
<span class="w">                                      </span><span class="s2">&quot;Block value on stack&quot;</span>
<span class="w">                                      </span><span class="n">stack</span><span class="p">)])]</span>

<span class="w">        </span><span class="c1">; Handle (def &lt;symbol&gt;) instruction</span>
<span class="w">        </span><span class="p">[(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">list?</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nb">empty?</span><span class="w"> </span><span class="n">instr</span><span class="p">))</span>
<span class="w">              </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">def</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">symbol?</span><span class="w"> </span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="n">instr</span><span class="p">)))</span>
<span class="w">         </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">))</span><span class="w"> </span><span class="n">bindings</span><span class="p">))]</span>

<span class="w">        </span><span class="c1">; Handle symbols that occur that we don&#39;t already know about</span>
<span class="w">        </span><span class="c1">; as a &quot;lookup operation&quot;</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">symbol?</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">bindings</span><span class="p">)</span>
<span class="w">             </span><span class="p">[(</span><span class="nb">list</span><span class="w"> </span><span class="n">sym</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="n">bindings</span><span class="p">)]</span>
<span class="w">             </span><span class="p">[</span><span class="no">#f</span><span class="w"> </span><span class="p">(</span><span class="nb">raise-argument-error</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">process-instruction</span>
<span class="w">                                       </span><span class="s2">&quot;Defined symbol expected&quot;</span>
<span class="w">                                       </span><span class="n">instr</span><span class="p">)])]</span>

<span class="w">        </span><span class="p">[</span><span class="no">#t</span>
<span class="w">         </span><span class="p">(</span><span class="nb">raise-argument-error</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">process-instruction</span><span class="w"> </span><span class="s2">&quot;Valid instruction&quot;</span><span class="w"> </span><span class="n">instr</span><span class="p">)])]))</span>
</pre></div>
</div>
<p>This version of the <code class="code highlight racket docutils literal highlight-racket"><span class="n">stack-machine</span></code> rightly rejects the program we considered to
be erroneous. However we have not solved the problem completely. While weâve
eliminated the âglobal variables onlyâ meaning in our program, our blocks can still
reference variables that are meaningless in certain ways.</p>
</section>
<section id="dynamic-scoping">
<h2>Dynamic scoping<a class="headerlink" href="#dynamic-scoping" title="Link to this heading">Â¶</a></h2>
<p id="index-7">Consider the program below â</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">stack-machine</span><span class="w"> </span><span class="o">&#39;</span><span class="p">((</span><span class="ss">block</span><span class="w"> </span><span class="p">(</span><span class="ss">def</span><span class="w"> </span><span class="ss">x</span><span class="p">)</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">*</span><span class="w"> </span><span class="ss">y</span><span class="w"> </span><span class="ss">y</span><span class="w"> </span><span class="ss">*</span><span class="w"> </span><span class="ss">+</span><span class="w"> </span><span class="ss">sqrt</span><span class="p">)</span>
<span class="w">                 </span><span class="p">(</span><span class="ss">def</span><span class="w"> </span><span class="ss">distance</span><span class="p">)</span>
<span class="w">                 </span><span class="p">(</span><span class="ss">block</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">(</span><span class="ss">def</span><span class="w"> </span><span class="ss">y</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="ss">distance</span><span class="w"> </span><span class="ss">do</span><span class="p">)</span>
<span class="w">                 </span><span class="ss">do</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()))</span>
</pre></div>
</div>
<p>Note that in this program, weâve removed the <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">def</span><span class="w"> </span><span class="n">y</span><span class="p">)</span></code> within the block,
so the <code class="code highlight racket docutils literal highlight-racket"><span class="n">distance</span></code> definition will only pop one value off the stack and
name it as <code class="code highlight racket docutils literal highlight-racket"><span class="n">x</span></code>. Our use of <code class="code highlight racket docutils literal highlight-racket"><span class="n">y</span></code> within the block is meaningless at the
point at which the block is being defined, because there is no guarantee that
it will become defined later on, and that could happen within another block
which accidentally uses a âlocal variableâ <code class="code highlight racket docutils literal highlight-racket"><span class="n">y</span></code>, which would interfere with
the reference to <code class="code highlight racket docutils literal highlight-racket"><span class="n">y</span></code> within our <code class="code highlight racket docutils literal highlight-racket"><span class="n">distance</span></code> block.</p>
<p>So, we want this program to also be treated as erroneous and fail rather than
be given a spurious meaning.</p>
<p>Programming languages which give meaning to such programs are said to have
â<span class="target" id="index-8"></span>dynamic scopingâ. The word âdynamicâ here refers to the fact that as
the program is running, the symbol <code class="code highlight racket docutils literal highlight-racket"><span class="n">y</span></code> takes on different values and the
meaning being attributed by the interpreter to the <code class="code highlight racket docutils literal highlight-racket"><span class="n">y</span></code> within the first
block is âwhatever value <code class="code highlight racket docutils literal highlight-racket"><span class="n">y</span></code> happens to have <strong>right now</strong>â.</p>
<p>That global variables are a bad idea is quite easily argued â two different
parts of a large program accidentally using the same symbol to refer to
different kinds of values should not cause the whole program to become invalid.
The reason dynamic scoping is also âa bad ideaâ is less obvious.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Think about why, before you read on.</p>
</div>
<p>In general, when we encapsulate some computation as a function for purposes of
reuse, we want to be able to reason about the behaviour of the function without
having to consider anything apart from the arguments supplied to it. If weâre
able to do that, the task of ensuring the correctness of a large program is
tractable â since we only have to validate each function based on the
constraints of the functions that it relies on. We <strong>do not</strong> want to have to
check how a function behaves in every context it is being invoked.</p>
</section>
<section id="fixing-dynamic-scoping">
<h2>Fixing dynamic scoping<a class="headerlink" href="#fixing-dynamic-scoping" title="Link to this heading">Â¶</a></h2>
<p id="index-9">To fix the âdynamic scoping bugâ, we need to clarify what exactly is the problem
in the first place.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Think about it before reading on. Why is the stray variable <code class="code highlight racket docutils literal highlight-racket"><span class="n">y</span></code>
in our last example taking on an actual value when weâre invoking the block?</p>
</div>
<p>The set of bindings in effect when evaluating a particular instruction is
called its âenvironmentâ. For a block, we therefore need to distinguish between
two such âenvironmentsâ.</p>
<p id="index-10">The bindings in effect at the point weâre creating the âblock valueâ (or âblock
objectâ if you want) is its â<strong>definition environment</strong>â. This âblock valueâ
refers to the <code class="code highlight racket docutils literal highlight-racket"><span class="n">Block</span></code> type value weâre placing on the stack and therefore
the âdefinition environmentâ is the environment in effect when weâre creating
this <code class="code highlight racket docutils literal highlight-racket"><span class="n">Block</span></code> type value.</p>
<p id="index-11">The bindings in effect at the point weâre invoking the block is called its
â<strong>evaluation environment</strong>â. This is the environment in effect when we
evaluate <code class="code highlight racket docutils literal highlight-racket"><span class="n">distance</span><span class="w"> </span><span class="k">do</span></code>. The problem we currently have is that weâre not
distinguishing between these two environments. More specifically, weâre letting
the evaluation environment affect the inside of the block where the definition
environment is the one thatâs supposed to be in effect. This is because the
definition environment is what lends meaning to the value of the symbols used
within the block and we donât want the evaluation environment to be responsible
for that.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Think about why it is the definition environment that lends meaning
to the inside of a block. What consequences does it have when building
large programs as a collection of small pieces of functionality?</p>
</div>
<p>As with many problems, identifying the problem is the major part of fixing it.
In this case, because we only have one notion of environment, we need to store
away the definition environment along with the block when weâre creating it, so
that we can refer to it later at evaluation time.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="n">Block</span><span class="w"> </span><span class="p">(</span><span class="n">program</span><span class="w"> </span><span class="n">definition-time-bindings</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">process-instruction</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">state</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="n">state</span>
<span class="w">     </span><span class="p">[(</span><span class="n">State</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="n">bindings</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">cond</span>
<span class="w">        </span><span class="c1">; &lt;common-operators&gt;</span>
<span class="w">        </span><span class="c1">; ...</span>
<span class="w">        </span><span class="c1">; &lt;/common-operators&gt;</span>

<span class="w">        </span><span class="c1">; A &quot;block&quot; compound instruction is given like (block dup + sqrt)</span>
<span class="w">        </span><span class="p">[(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">list?</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nb">empty?</span><span class="w"> </span><span class="n">instr</span><span class="p">))</span>
<span class="w">              </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">block</span><span class="p">))</span>
<span class="w">         </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="p">(</span><span class="n">Block</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span><span class="w"> </span><span class="n">bindings</span><span class="p">)</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="n">bindings</span><span class="p">)]</span>
<span class="w">         </span><span class="c1">;                                ^---- Note that we added this</span>
<span class="w">         </span><span class="c1">;                                to store the definition time</span>
<span class="w">         </span><span class="c1">;                                bindings when we&#39;re making the block.</span>

<span class="w">        </span><span class="c1">; A &quot;do&quot; instruction will pop a Block value off the top of the</span>
<span class="w">        </span><span class="c1">; stack and &quot;run&quot; it.</span>
<span class="w">        </span><span class="p">[(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">do</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span>
<span class="w">             </span><span class="p">[(</span><span class="n">Block</span><span class="w"> </span><span class="n">program</span><span class="w"> </span><span class="n">definition-time-bindings</span><span class="p">)</span>
<span class="w">              </span><span class="c1">;              ^---- Now we pick up what we stored away</span>
<span class="w">              </span><span class="c1">;                    at definition time.</span>
<span class="w">              </span><span class="c1">; &lt;&lt;&lt;----&gt;&gt;&gt;&gt;</span>
<span class="w">              </span><span class="c1">; We&#39;ve modified this expression to consider only the stack</span>
<span class="w">              </span><span class="c1">; as part of the result state of executing a block. We discard</span>
<span class="w">              </span><span class="c1">; the bindings it produces and retain the original</span>
<span class="w">              </span><span class="c1">; definition-time-bindings that were captured when the block</span>
<span class="w">              </span><span class="c1">; was created.</span>
<span class="w">              </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">State-stack</span><span class="w"> </span><span class="p">(</span><span class="n">stack-machine</span><span class="w"> </span><span class="n">program</span>
<span class="w">                                                 </span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="n">definition-time-bindings</span><span class="p">)))</span>
<span class="w">                                                 </span><span class="c1">;                  ^---- Note this.</span>
<span class="w">                     </span><span class="n">bindings</span><span class="p">)]</span>
<span class="w">              </span><span class="c1">;      ^------------ These bindings are unaffected by what happens</span>
<span class="w">              </span><span class="c1">;                    when running the block.</span>

<span class="w">             </span><span class="p">[</span><span class="k">_</span><span class="w"> </span><span class="p">(</span><span class="nb">raise-argument-error</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">process-instruction</span>
<span class="w">                                      </span><span class="s2">&quot;Block value on stack&quot;</span>
<span class="w">                                      </span><span class="n">stack</span><span class="p">)])]</span>

<span class="w">        </span><span class="c1">; ...</span>
<span class="w">        </span><span class="c1">; THE REST OF (def &lt;symbol&gt;) and (symbol? x) etc.</span>
<span class="w">        </span><span class="c1">; ...</span>
<span class="w">        </span><span class="p">[</span><span class="no">#t</span>
<span class="w">         </span><span class="p">(</span><span class="nb">raise-argument-error</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">process-instruction</span><span class="w"> </span><span class="s2">&quot;Valid instruction&quot;</span><span class="w"> </span><span class="n">instr</span><span class="p">)])]))</span>
</pre></div>
</div>
<p>With this, weâve dealt the final blow to dynamic scoping in our interpreter.
Our interpreter now properly implements â<span class="target" id="index-12"></span>lexical scopingâ â i.e. the
meaning of a particular symbol used is taken to be available in the region of
program text where itâs used. Thatâs an informal way of saying it though. We
usually imply that there is some region of code (usually delimited by some form
of brackets or pair of keywords like <code class="code highlight racket docutils literal highlight-racket"><span class="k">begin</span></code> and <code class="code highlight racket docutils literal highlight-racket"><span class="n">end</span></code>) which is the
intended âregion of program textâ.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>While weâve âfixedâ dynamic scoping, think about whether weâve lost any
useful ability along the way.</p>
</div>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Btw weâve also gained another ability when we implemented proper lexical
scoping in <code class="code highlight racket docutils literal highlight-racket"><span class="n">stack-machine</span></code>. Can you spot it? What possible ways to use
blocks would you try to exhaust some of these possibilities?</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Comp308: Principles of Programming Languages</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Welcome note</a></li>
<li class="toctree-l1"><a class="reference internal" href="racket-intro.html">A quick introduction to Racket and Scheme</a></li>
<li class="toctree-l1"><a class="reference internal" href="lambda.html">Î» - the everything</a></li>
<li class="toctree-l1"><a class="reference internal" href="church.html">Lambda - via Î²-abstraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="piclang.html">A language for pictures</a></li>
<li class="toctree-l1"><a class="reference internal" href="arithlang.html">A language for arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine.html">A mental model for the machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="notional-machine.html">Notional machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="growing.html">Growing the language</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun.html">Functions and scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun-arith.html">Functions and scope (arithmetic track)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Stacks and scope</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#adding-names-to-the-stack-machine">Adding names to the stack-machine</a></li>
<li class="toctree-l2"><a class="reference internal" href="#blocks">Blocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#which-programs-are-valid-blocks">Which programs are valid blocks?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dynamic-scoping">Dynamic scoping</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fixing-dynamic-scoping">Fixing dynamic scoping</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="fun-in-piclang.html">Functions in PicLang</a></li>
<li class="toctree-l1"><a class="reference internal" href="mutations.html">Mutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="control.html">Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="generators.html">Generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="errornot.html">On the choice between âerrorâ and âdo something reasonableâ in design</a></li>
<li class="toctree-l1"><a class="reference internal" href="dispatch.html">Polymorphism via dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="appsem.html">Alternative application semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html">Types: Checking some program invariants statically</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="fun-arith.html" title="previous chapter">Functions and scope (arithmetic track)</a></li>
      <li>Next: <a href="fun-in-piclang.html" title="next chapter">Functions in PicLang</a></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2022, Srikumar K. S..
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="_sources/stacks-and-scope.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>