
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lambda - the everything &#8212; Comp308: Principles of Programming Languages v1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="A quick introduction to Racket and Scheme" href="racket-intro.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="lambda-the-everything">
<h1>Lambda - the everything<a class="headerlink" href="#lambda-the-everything" title="Permalink to this headline">¶</a></h1>
<p>If Alonzo Church were asked “how far does the computational rabbit hole go?”,
he might have answered “It’s <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">lambda</span></span></code> all the way through.”.</p>
<p>Alonzo Church, in the 1930s (yes, that’s getting to be a century ago!), and his
students formulated what could be called the essence of anything computable.
The insight they had was that given functions and function applications,
anything that can be computed is expressible. Note that we aren’t talking about
functions of numbers or strings or booleans or anything else. The only entities
in Church’s world are functions, and the only thing you can do with them is to
apply them to other things (which are … functions) … and he claimed that
all of what’s computable is expressible using these! What’s known as the
<a class="reference external" href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">Church-Turing thesis</a> is the proof that Church’s “lambda calculus” is
equivalent in its universality to Alan Turing’s “Turing machine”.</p>
<p>Take a moment to digest that large claim, for the <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">lambda</span></span></code> construct in
Scheme is directly based on that foundational insight. In studying programming
languages, we repeatedly encounter this idea of “we can express X in terms of
Y” and where we make larger sets of these “X”s for our convenience where a much
smaller set of “Y”s will suffice for the job. This “extra”, we call “syntactic
sugar”, which draws from Alan Perlis’ joke - “Syntactic sugar causes cancer of
the semicolon.” – made in reference to unessential syntactic cruft often added
on to programming languages by their creators without a taste for minimalism.</p>
<p>The process of taking an expression that’s rich in “syntactic sugar” and
producing an equivalent expression using fewer “primitives” is something we’ll
refer to as “desugaring”. Since it is a kind of translation, it could also be
taken as a kind of “compilation”, but in case that scares you, don’t worry
and just stick to “desugaring”.</p>
<p>The point of lambdas is that lambdas are at the end of the entire stack of
sugarings. The buck stops with them.</p>
<div class="section" id="so-what-s-lambda">
<h2>So what’s <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">lambda</span></span></code><a class="headerlink" href="#so-what-s-lambda" title="Permalink to this headline">¶</a></h2>
<p>In Scheme, a “lambda expression” is an expression of the general form
shown below –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">..&lt;list-of-var-names&gt;..</span><span class="p">)</span> <span class="n">&lt;expr-using-vars-in-the-list&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>It represents a packaged computation that can be performed when given concrete
values for the variables listed after <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">lambda</span></span></code> in the above expression.</p>
<p>For example, :rkt:`` is the function that squares numbers.
When given a number <code class="code highlight racket docutils literal notranslate"><span class="literal number integer"><span class="pre">2</span></span></code>, by substituting <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code> with <code class="code highlight racket docutils literal notranslate"><span class="literal number integer"><span class="pre">2</span></span></code>, you can compute
the result of what the lambda expression denotes – which is <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">*</span></span> <span class="literal number integer"><span class="pre">2</span></span> <span class="literal number integer"><span class="pre">2</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="name builtin"><span class="pre">=</span></span> <span class="literal number integer"><span class="pre">4</span></span></code>.</p>
<p>There are two main rules you need to know when working with <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">lambda</span></span></code>
expressions (the abstract ones).</p>
<dl>
<dt><strong>α-renaming</strong></dt><dd><p>If <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="keyword"><span class="pre">lambda</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="name"><span class="pre">E</span></span><span class="punctuation"><span class="pre">[</span></span><span class="name"><span class="pre">x</span></span><span class="punctuation"><span class="pre">])</span></span></code> is a lambda expression in one argument where <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">E</span></span><span class="punctuation"><span class="pre">[</span></span><span class="name"><span class="pre">x</span></span><span class="punctuation"><span class="pre">]</span></span></code>
denotes some expression involving the variable <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code>, then you can change
the name of <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code> to anything else and what the expression denotes is
considered to be the same. i.e. You can rewrite it to <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="keyword"><span class="pre">lambda</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">y</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="name"><span class="pre">E</span></span><span class="punctuation"><span class="pre">[</span></span><span class="name"><span class="pre">y</span></span><span class="punctuation"><span class="pre">])</span></span></code>
(where we use the same <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">E</span></span></code>) and it means the same thing.</p>
</dd>
<dt><strong>β-reduction</strong></dt><dd><p>If you have an expression of the form <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword"><span class="pre">lambda</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="name"><span class="pre">E1</span></span><span class="punctuation"><span class="pre">[</span></span><span class="name"><span class="pre">x</span></span><span class="punctuation"><span class="pre">])</span></span> <span class="name"><span class="pre">E2</span></span><span class="punctuation"><span class="pre">)</span></span></code> where <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">E1</span></span><span class="punctuation"><span class="pre">[</span></span><span class="name"><span class="pre">x</span></span><span class="punctuation"><span class="pre">]</span></span></code>
is an expression that (optionally) uses the variable <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code> and <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">E2</span></span></code> is some other
expression, then it is equivalent to <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">E1</span></span><span class="punctuation"><span class="pre">[</span></span><span class="name"><span class="pre">E2</span></span><span class="punctuation"><span class="pre">]</span></span></code>. i.e.</p>
<blockquote>
<div><p><code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword"><span class="pre">lambda</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="name"><span class="pre">E1</span></span><span class="punctuation"><span class="pre">[</span></span><span class="name"><span class="pre">x</span></span><span class="punctuation"><span class="pre">])</span></span> <span class="name"><span class="pre">E2</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="keyword"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">E1</span></span><span class="punctuation"><span class="pre">[</span></span><span class="name"><span class="pre">E2</span></span><span class="punctuation"><span class="pre">]</span></span></code></p>
</div></blockquote>
<p>It is important to note that when we say “is equivalent to”, it means you
can rewrite a sub-expression that looks like one side to the other form
<strong>anywhere</strong>. We refer to the above left-to-right rewrite as “β-reduction”
and the corresponding right-to-left rewrite as “β-abstraction”.</p>
<p>Just as lambdas are the conceptual basis of all of computation, all
abstraction in computing boils down to β-abstraction.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>“β-reduction” can be considered a fancy term for “substitution”,
for that’s what it is. We don’t have a corresponding simple term for the
opposite transformation though. So we’ll continue to call it “β-abstraction”.
We’ll refer to the transformation <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">E1</span></span><span class="punctuation"><span class="pre">[</span></span><span class="name"><span class="pre">E2</span></span><span class="punctuation"><span class="pre">]</span></span> <span class="keyword"><span class="pre">=&gt;</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword"><span class="pre">lambda</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="name"><span class="pre">E1</span></span><span class="punctuation"><span class="pre">[</span></span><span class="name"><span class="pre">x</span></span><span class="punctuation"><span class="pre">])</span></span> <span class="name"><span class="pre">E2</span></span><span class="punctuation"><span class="pre">)</span></span></code>
as “β-abstracting over <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">E2</span></span></code>”.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When performing a β-reduction step in Scheme, you need to be careful
not to substitute symbols within a <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">quote</span></span></code> sub-expression. For example,
<code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword"><span class="pre">lambda</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="keyword"><span class="pre">quote</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="literal string symbol"><span class="pre">+</span></span> <span class="literal string symbol"><span class="pre">x</span></span> <span class="literal string symbol"><span class="pre">x</span></span><span class="punctuation"><span class="pre">)))</span></span> <span class="literal number integer"><span class="pre">3</span></span><span class="punctuation"><span class="pre">)</span></span></code> reduces to the list <code class="code highlight racket docutils literal notranslate"><span class="operator"><span class="pre">‘</span></span><span class="punctuation"><span class="pre">(</span></span><span class="literal string symbol"><span class="pre">+</span></span> <span class="literal string symbol"><span class="pre">x</span></span> <span class="literal string symbol"><span class="pre">x</span></span><span class="punctuation"><span class="pre">)</span></span></code>
whereas <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword"><span class="pre">lambda</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">+</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">x</span></span><span class="punctuation"><span class="pre">))</span></span> <span class="literal number integer"><span class="pre">3</span></span><span class="punctuation"><span class="pre">)</span></span></code> reduces to <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">+</span></span> <span class="literal number integer"><span class="pre">3</span></span> <span class="literal number integer"><span class="pre">3</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="name builtin"><span class="pre">=</span></span> <span class="literal number integer"><span class="pre">6</span></span></code>.</p>
</div>
<p>Take the expression <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword"><span class="pre">lambda</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">*</span></span> <span class="name"><span class="pre">x</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword"><span class="pre">lambda</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">-</span></span> <span class="name"><span class="pre">x</span></span> <span class="literal number integer"><span class="pre">1</span></span><span class="punctuation"><span class="pre">))</span></span> <span class="name"><span class="pre">x</span></span><span class="punctuation"><span class="pre">)))</span></span> <span class="literal number integer"><span class="pre">10</span></span><span class="punctuation"><span class="pre">)</span></span></code> and
try to apply the reduction rules. If you took the “β-reduction” rule in the
naive way, you might end up with <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">*</span></span> <span class="literal number integer"><span class="pre">10</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword"><span class="pre">lambda</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="literal number integer"><span class="pre">10</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">-</span></span> <span class="literal number integer"><span class="pre">10</span></span> <span class="literal number integer"><span class="pre">1</span></span><span class="punctuation"><span class="pre">))</span></span> <span class="literal number integer"><span class="pre">10</span></span><span class="punctuation"><span class="pre">))</span></span></code> and
then scratch your head about what you have at hand and what to do with it next!
To do this correctly, you must see that the original expression is the same as
<code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword"><span class="pre">lambda</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">*</span></span> <span class="name"><span class="pre">x</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword"><span class="pre">lambda</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">y</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">-</span></span> <span class="name"><span class="pre">y</span></span> <span class="literal number integer"><span class="pre">1</span></span><span class="punctuation"><span class="pre">))</span></span> <span class="name"><span class="pre">x</span></span><span class="punctuation"><span class="pre">)))</span></span> <span class="literal number integer"><span class="pre">10</span></span><span class="punctuation"><span class="pre">)</span></span></code> .. where we’ve “α-renamed”
the inner lambda’s <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code> variable to <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">y</span></span></code>, because, well they’re supposed to
be equivalent right? If you now do β-reduction on this equivalent expression,
you won’t be left with the confused expression.</p>
<p>So the two rules are taken to be <strong>always</strong> applicable in evaluating an
expression and all correct applications of the rules must evaluate to
the same result no matter the sequence in which they’re applied.</p>
</div>
<div class="section" id="tall-claims-need-taller-evidence">
<h2>Tall claims need taller evidence<a class="headerlink" href="#tall-claims-need-taller-evidence" title="Permalink to this headline">¶</a></h2>
<p>Back to Church, what he made was a tall claim – that all computable functions
are expressible in terms of lambdas. When we make such a claim, we have to back
it up though. To recap, he’s saying that you don’t need <code class="code highlight racket docutils literal notranslate"><span class="name builtin"><span class="pre">cons</span></span></code>, <code class="code highlight racket docutils literal notranslate"><span class="name builtin"><span class="pre">car</span></span></code>,
<code class="code highlight racket docutils literal notranslate"><span class="name builtin"><span class="pre">cdr</span></span></code>, <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">if</span></span></code>, <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">let</span></span></code>, <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">cond</span></span></code>, booleans or numbers or strings or whatever
we’re used to in normal programming. He claimed that all of these are
representable using lambdas <strong>alone</strong> .. and showed how to do it.</p>
<p>We’ll now work through how to represent basic things in terms of which we
can build a whole computational edifice.</p>
<div class="section" id="pairs">
<h3>Pairs<a class="headerlink" href="#pairs" title="Permalink to this headline">¶</a></h3>
<p>Pairs are the simplest of data structures. Once you can make a pair of two
things like <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">pair</span></span> <span class="name"><span class="pre">a</span></span> <span class="name"><span class="pre">b</span></span><span class="punctuation"><span class="pre">)</span></span></code> or the equivalent in a programming language, you can
get lists using –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">pair</span> <span class="n">a</span> <span class="p">(</span><span class="n">pair</span> <span class="n">b</span> <span class="p">(</span><span class="n">pair</span> <span class="n">c</span> <span class="k">...</span> <span class="p">(</span><span class="n">pair</span> <span class="n">x</span> <span class="n">sentinel</span><span class="p">)))</span> <span class="k">...</span><span class="p">)</span>
</pre></div>
</div>
<p>where we use a <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">sentinel</span></span></code> to indicate end of the list. You can also make
trees using nested structures like –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">pair</span> <span class="p">(</span><span class="n">pair</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="n">pair</span> <span class="p">(</span><span class="n">pair</span> <span class="n">c</span> <span class="n">d</span><span class="p">)</span> <span class="p">(</span><span class="n">pair</span> <span class="n">e</span> <span class="n">f</span><span class="p">)))</span>
</pre></div>
</div>
<p>Or tables as a list of lists. Or even graphs. So if we can show we can
represent pairs using just <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">lambda</span></span></code>, we’re good with the other structures.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">pair</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="k">...</span><span class="p">))</span>
</pre></div>
</div>
<p>What should we put within the <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">…</span></span></code>? In fact, what <strong>can</strong> we put in there
when all we have are functions (i.e. lambda expressions)? So we’re now
looking at –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">pair</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">...</span><span class="p">)))</span>
</pre></div>
</div>
<p>Again, what can we put in there? We have a <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">p</span></span></code> and some two arbitrary values
<code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code> and <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">y</span></span></code> that we’re expected to “store” in the pair. About the only
thing we can do (apart from nesting lambda once more, which would seem
pointless) is to apply <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">p</span></span></code> to the <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code> and <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">y</span></span></code>.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">pair</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span> <span class="n">x</span> <span class="n">y</span><span class="p">))))</span>
</pre></div>
</div>
<p>We can now make “pairs” like below –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">p1</span> <span class="p">(</span><span class="n">pair</span> <span class="mi">12</span> <span class="mi">100</span><span class="p">))</span>
</pre></div>
</div>
<p>(taking the liberty to use numbers just to illustrate). Since <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">p1</span></span></code> is a function
that takes one argument, the only thing we can do with it is call it. Since its
argument is also a function that’s applied to 2 arguments, let’s consider
some simple 2-argument functions shown below –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">.first</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">.second</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<p>The functions ignore one of their arguments and just evaluate to the other.
Now what happens when you apply <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">p1</span></span></code> to these two functions.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">p1</span> <span class="n">.first</span><span class="p">)</span>
<span class="k">=&gt;</span> <span class="p">((</span><span class="n">pair</span> <span class="mi">12</span> <span class="mi">100</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">x</span><span class="p">))</span> <span class="c1">; substitute their definitions</span>
<span class="k">=&gt;</span> <span class="p">(((</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span> <span class="n">x</span> <span class="n">y</span><span class="p">)))</span> <span class="mi">12</span> <span class="mi">100</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">x</span><span class="p">))</span>
<span class="c1">; β-reduce the first term</span>
<span class="k">=&gt;</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span> <span class="mi">12</span> <span class="mi">100</span><span class="p">))</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">x</span><span class="p">))</span>
<span class="c1">; β-reduce the expression again</span>
<span class="k">=&gt;</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">x</span><span class="p">)</span> <span class="mi">12</span> <span class="mi">100</span><span class="p">)</span>
<span class="c1">; β-reduce the expression again</span>
<span class="k">=&gt;</span> <span class="mi">12</span>
</pre></div>
</div>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Work it out similarly and show that <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">p1</span></span> <span class="name"><span class="pre">.second</span></span><span class="punctuation"><span class="pre">)</span></span></code> results in <code class="code highlight racket docutils literal notranslate"><span class="literal number integer"><span class="pre">100</span></span></code>.</p>
</div>
<p>So we have a function now named <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">pair</span></span></code> that can make so-called “pair objects”
and we can get the individual values out of the pair object using the
“accessor” functions <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">.first</span></span></code> and <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">.second</span></span></code>.</p>
<p>Many of you are familiar with “object oriented languages” like Python and will
see the reasoning behind naming the accessor functions that way .. since the
expression <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">p1</span></span> <span class="name"><span class="pre">.first</span></span><span class="punctuation"><span class="pre">)</span></span></code> looks very similar to <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">p1.first</span></span></code> typical of such
languages.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The ones with a careful eye might’ve noticed that while we claimed to
only use lambdas, we ended up using <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">define</span></span></code> in the above definitions. We
use it here only as a substitute for writing the mathematical definitional
equality <span class="math notranslate nohighlight">\(pair = (λ\ (x\ y)\ (λ\ (p)\ (p\ x\ y)))\)</span> and because it
actually permits you to type it into Racket and check things out for
yourself. We therefore lose no generality by using <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">define</span></span></code> in the above
code. Also, lambda calculus deals only with one-argument functions and we’ve
used two here. However, <span class="math notranslate nohighlight">\((λ\ (x\ y)\ E[x,y])\)</span> can be mechanically
rewritten to <span class="math notranslate nohighlight">\((λ\ (x)\ (λ\ (y)\ E[x,y]))\)</span> with corresponding changes
to substitution steps without loss of logical correctness. So we’ll take
that additional liberty here too.</p>
</div>
</div>
<div class="section" id="booleans">
<h3>Booleans<a class="headerlink" href="#booleans" title="Permalink to this headline">¶</a></h3>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>The only place we use boolean values is to do a branch within an <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">if</span></span></code>
condition. So if we can implement <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">if</span></span></code> purely using <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">lambda</span></span></code>, we’re
good. For this exercise, you’ll need to consider “lazy evaluation” instead
of “eager evaluation” to keep things simple. In fact, for the rest of this
demonstration, we’ll use lazy evaluation with <code class="code highlight racket docutils literal notranslate"><span class="keyword namespace"><span class="pre">#lang</span> </span><span class="name namespace"><span class="pre">lazy</span></span></code>. The earlier
ones will also work with <code class="code highlight racket docutils literal notranslate"><span class="keyword namespace"><span class="pre">#lang</span> </span><span class="name namespace"><span class="pre">lazy</span></span></code>. So complete the definition below –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">IF</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">bool</span> <span class="n">then-expr</span> <span class="n">else-expr</span><span class="p">)</span> <span class="n">....</span><span class="p">))</span>
</pre></div>
</div>
<p>Remember the trick we used with <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">pair</span></span></code>. You have all you need in that
code.</p>
</div>
</div>
<div class="section" id="numbers">
<h3>Numbers<a class="headerlink" href="#numbers" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="recursion">
<h2>Recursion<a class="headerlink" href="#recursion" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Comp308: Principles of Programming Languages</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="racket-intro.html">A quick introduction to Racket and Scheme</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Lambda - the everything</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#so-what-s-lambda">So what’s <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">lambda</span></span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#tall-claims-need-taller-evidence">Tall claims need taller evidence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#recursion">Recursion</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="racket-intro.html" title="previous chapter">A quick introduction to Racket and Scheme</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Srikumar K. S..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/lambda.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>