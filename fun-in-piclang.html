
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Functions in PicLang &#8212; Comp308: Principles of Programming Languages v1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Stacks and scope" href="stacks-and-scope.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="functions-in-piclang">
<h1>Functions in PicLang<a class="headerlink" href="#functions-in-piclang" title="Permalink to this headline">¶</a></h1>
<p>Having seen how to implement proper lexical scoping in our <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">stack-machine</span></span></code>
in the section <a class="reference internal" href="stacks-and-scope.html"><span class="doc">Stacks and scope</span></a>, we’re now well placed to do that within
our expression interpreter for PicLang.</p>
<p>We’re going to need corresponding notions of “blocks” in this language
and the notion of “do” as well. We’ll also have to have our interpreter
keep track of bindings as wel go along, so we can eliminate the whole
substitution process and replace it with a single pass interpreter that
does effectively the same (and correctly) without having to run through a
“substitution pass” before performing interpretation.</p>
<p>We’ll call the equivalent of a “block” a <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">FunC</span></span></code> in PicLang, defined
as below –</p>
<div class="highlight-racket notranslate" id="index-0"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">struct</span> <span class="n">FunC</span> <span class="p">(</span><span class="n">argname</span> <span class="n">expr</span><span class="p">))</span>
</pre></div>
</div>
<p>We’ll call the equivalent of the <code class="code highlight racket docutils literal notranslate"><span class="keyword"><span class="pre">do</span></span></code> instruction <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">ApplyC</span></span></code> here.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">struct</span> <span class="p">(</span><span class="n">ApplyC</span> <span class="p">(</span><span class="n">funexpr</span> <span class="n">valexpr</span><span class="p">)))</span>
</pre></div>
</div>
<p>An important thing to note is that we’re now considering <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">FunC</span></span></code> and
<code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">ApplyC</span></span></code> terms to be valid <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">PicExprC</span></span></code> terms. While we can expect
<code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">ApplyC</span></span></code> to produce pictures, evaluating <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">FunC</span></span></code> clearly does not
produce a picture. Just as the <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">block</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">def</span></span> <span class="name"><span class="pre">x</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="keyword"><span class="pre">…</span></span><span class="punctuation"><span class="pre">)</span></span></code> instruction produces a
<code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">Block</span></span></code> object on the stack in our <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">stack-machine</span></span></code>, a <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">FunC</span></span></code>
expression produces a … “function value”.</p>
<p>This means we need to expand the notion of what our PicLang :rkt`interpret`
function can return to include such function values. Incidentally, we’ve
now expanded the scope of what <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">ApplyC</span></span></code> can produce to include
function values too. In other words, we’ve in two strokes admitted
first class functions into our language!</p>
<p>We’ll now formalize the return type of <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">interp</span></span></code> using a type
consisting of a set of “value terms” - denoted by the <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">V</span></span></code> suffix.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">struct</span> <span class="n">PictureV</span> <span class="p">(</span><span class="n">pic</span><span class="p">))</span>
<span class="p">(</span><span class="k">struct</span> <span class="n">FunV</span> <span class="p">(</span><span class="n">argname</span> <span class="n">bindings</span> <span class="n">expr</span><span class="p">))</span>
</pre></div>
</div>
<p>Here is the modified interpreter …</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="c1">; bindings takes on the same list of two-element lists</span>
<span class="c1">; structure we used in stack-machine.</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">interp</span> <span class="n">picexprC</span> <span class="n">bindings</span><span class="p">)</span>
    <span class="p">(</span><span class="k">match</span> <span class="n">picexprC</span>
        <span class="c1">; ...</span>
        <span class="p">[(</span><span class="n">FunC</span> <span class="n">argname</span> <span class="n">expr</span><span class="p">)</span>
         <span class="c1">; Store away the definition time bindings</span>
         <span class="p">(</span><span class="n">FunV</span> <span class="n">argname</span> <span class="n">bindings</span> <span class="n">expr</span><span class="p">)]</span>
        <span class="p">[(</span><span class="n">ApplyC</span> <span class="n">funexpr</span> <span class="n">valexpr</span><span class="p">)</span>
         <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">fun</span> <span class="p">(</span><span class="n">interp</span> <span class="n">funexpr</span> <span class="n">bindings</span><span class="p">)]</span>
               <span class="p">[</span><span class="n">val</span> <span class="p">(</span><span class="n">interp</span> <span class="n">valexpr</span> <span class="n">bindings</span><span class="p">)])</span>
            <span class="p">(</span><span class="k">match</span> <span class="n">fun</span>
                <span class="p">[(</span><span class="n">FunV</span> <span class="n">argname</span> <span class="n">definition-time-bindings</span> <span class="n">expr</span><span class="p">)</span>
                 <span class="c1">; Now to apply the function, we add a new</span>
                 <span class="c1">; binding for its argument name and evaluate</span>
                 <span class="c1">; the body.</span>
                 <span class="p">(</span><span class="n">interp</span> <span class="n">expr</span> <span class="p">(</span><span class="n">extend-bindings</span> <span class="n">argname</span> <span class="n">val</span> <span class="n">definition-time-bindings</span><span class="p">))]</span>
                <span class="p">[</span><span class="k">_</span> <span class="p">(</span><span class="nb">raise-argument-error</span> <span class="o">&#39;</span><span class="ss">interp</span>
                                         <span class="s2">&quot;Function value for application&quot;</span>
                                         <span class="n">funexpr</span><span class="p">)]))]</span>
        <span class="p">[(</span><span class="n">IdC</span> <span class="n">id</span><span class="p">)</span>
         <span class="p">(</span><span class="n">lookup-bindings</span> <span class="n">bindings</span> <span class="n">id</span><span class="p">)]</span>
        <span class="c1">; ...</span>
        <span class="p">))</span>
</pre></div>
</div>
<p>We’ve chosen to keep the “bindings” structure abstract by referring to the two things
we need to do with it - “name lookup” and “extension” separate, so we can defer the
actual choice of structure.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Write appropriate test expressions for this revised interpreter to check
whether the scoping behaviour is indeed lexical.</p>
</div>
<div class="section" id="a-standard-library">
<h2>A standard library<a class="headerlink" href="#a-standard-library" title="Permalink to this headline">¶</a></h2>
<p>Notice that we’ve gotten rid of the <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">fundefs</span></span></code> argument which was a list of
<code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">FunDefC</span></span></code> terms. Technically, we do not need it any more, as we can pass
any functions as arguments to an <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">ApplyC</span></span></code> term and refer to it within the
value expression of the function term via the argument name. However, doing this
for even 20 functions is cumbersome.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>What exactly is cumbersome about it? Is it simply that we have to
nest many <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">ApplyC</span></span></code> terms?</p>
</div>
<p>From a user interface perspective, all we need to do is to provide a starter
set of bindings to the interpreter that expressions can use. These bindings
must be mappings from symbols to <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">FunV</span></span></code> terms. However, note that
our <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">FunV</span></span></code> terms also have their own list of bindings. The question
then is “what should these bindings lists be?”.</p>
<p>We’re calling this initial set of bindings a “standard library” of functions
that may be useful when writing PicLang expressions. This also means that
this standard library is also available to the standard library functions
themselves. So one way to resolve this conundrum is to make these <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">FunV</span></span></code>
values given the standard library! The snake must eat its own tail!</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="c1">; definitions is a list of bindings where a &quot;binding&quot; is given</span>
<span class="c1">; as a list of two values - the first being the symbol to be bound</span>
<span class="c1">; and the second being the :rkt:`FunC` expression to bind to it.</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">make-standard-library</span> <span class="n">definitions</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">empty?</span> <span class="n">definitions</span><span class="p">)</span>
        <span class="p">(</span><span class="n">make-empty-bindings</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">def</span> <span class="p">(</span><span class="nb">first</span> <span class="n">definitions</span><span class="p">)])</span>
            <span class="p">(</span><span class="n">extend-bindings</span>
                <span class="p">(</span><span class="nb">first</span> <span class="n">def</span><span class="p">)</span>
                <span class="p">(</span><span class="n">interp</span> <span class="p">(</span><span class="nb">second</span> <span class="n">def</span><span class="p">)</span> <span class="p">(</span><span class="n">make-standard-library</span> <span class="n">definitions</span><span class="p">))</span>
                <span class="p">(</span><span class="n">make-standard-library</span> <span class="p">(</span><span class="nb">rest</span> <span class="n">definitions</span><span class="p">))))))</span>
</pre></div>
</div>
<p>There, in all its naïvette, is a fully self referential expression of what we
actually want to produce. But we <a class="reference internal" href="lambda.html"><span class="doc">kind of know how</span></a> to deal with
such self reference. Let’s rewrite the above self referential function.</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">make-standard-library</span> <span class="n">definitions</span> <span class="n">stdlib</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">empty?</span> <span class="n">definitions</span><span class="p">)</span>
        <span class="p">(</span><span class="n">make-empty-bindings</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">def</span> <span class="p">(</span><span class="nb">first</span> <span class="n">definitions</span><span class="p">)])</span>
            <span class="p">(</span><span class="n">extend-bindings</span>
                <span class="p">(</span><span class="nb">first</span> <span class="n">def</span><span class="p">)</span>
                <span class="p">(</span><span class="n">interp</span> <span class="p">(</span><span class="nb">second</span> <span class="n">def</span><span class="p">)</span> <span class="n">stdlib</span><span class="p">)</span>
                <span class="p">(</span><span class="n">make-standard-library</span> <span class="p">(</span><span class="nb">rest</span> <span class="n">definitions</span><span class="p">)</span> <span class="n">stdlib</span><span class="p">)))))</span>
</pre></div>
</div>
<p>Here we’re assuming that our function will be passed the result <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">stdlib</span></span></code>
we’re constructing and it makes use of this to construct its result!! That’s
something we did earlier as well in <a class="reference internal" href="lambda.html"><span class="doc">Lambda - the everything</span></a>. We
want to solve for the fixed point in the following “equation”, given a list of
<code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">definitions</span></span></code> -</p>
<div class="highlight-racket notranslate" id="index-1"><div class="highlight"><pre><span></span><span class="n">stdlib</span> <span class="nb">=</span> <span class="p">(</span><span class="n">make-standard-library</span> <span class="n">definitions</span> <span class="n">stdlib</span><span class="p">)</span>
</pre></div>
</div>
<p>If we now rewrite the RHS –</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="n">spec</span> <span class="nb">=</span> <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="n">stdlib</span><span class="p">)</span> <span class="p">(</span><span class="n">make-standard-library</span> <span class="n">definitions</span> <span class="n">stdlib</span><span class="p">))</span>
<span class="n">stdlib</span> <span class="nb">=</span> <span class="p">(</span><span class="n">spec</span> <span class="n">stdlib</span><span class="p">)</span>
</pre></div>
</div>
<p>We can now apply our “function is called with itself to enable the function to
call itself” trick to get -</p>
<div class="highlight-racket notranslate" id="index-2"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="n">G</span> <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="n">spec</span><span class="p">)</span> <span class="p">(</span><span class="n">spec</span> <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="p">(((</span><span class="n">f</span> <span class="n">f</span><span class="p">)</span> <span class="n">spec</span><span class="p">)</span> <span class="n">g</span><span class="p">))))))</span>
<span class="p">(</span><span class="k">define</span> <span class="n">F</span> <span class="p">(</span><span class="n">G</span> <span class="n">G</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="n">stdlib</span> <span class="p">(</span><span class="n">F</span> <span class="n">spec</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that we’ve modified the trick above so it would work with eager evaluation
strategy instead of the original <code class="code highlight racket docutils literal notranslate"><span class="keyword namespace"><span class="pre">#lang</span> </span><span class="name namespace"><span class="pre">lazy</span></span></code> choice. The expression
<code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="keyword"><span class="pre">λ</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">g</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="punctuation"><span class="pre">(</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">f</span></span> <span class="name"><span class="pre">f</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="name"><span class="pre">spec</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="name"><span class="pre">g</span></span><span class="punctuation"><span class="pre">))</span></span></code> is logically equivalent to <code class="code highlight racket docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">f</span></span> <span class="name"><span class="pre">f</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="name"><span class="pre">spec</span></span><span class="punctuation"><span class="pre">)</span></span></code>
by “<span class="target" id="index-3"></span>η-reduction”, but helps delay the evaluation of the recursive
parts by enough so we don’t get stuck in an infinite loop.</p>
<p>But this is still pending a specific representation for “bindings”. Lets do a
simple one -</p>
<div class="highlight-racket notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">make-empty-bindings</span><span class="p">)</span>
    <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">raise-argument-error</span> <span class="o">&#39;</span><span class="ss">lookup-binding</span>
                             <span class="s2">&quot;Valid name&quot;</span>
                             <span class="n">name</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">lookup-binding</span> <span class="n">name</span> <span class="n">bindings</span><span class="p">)</span>
    <span class="p">(</span><span class="n">bindings</span> <span class="n">name</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">extend-bindings</span> <span class="n">name</span> <span class="n">value</span> <span class="n">bindings</span><span class="p">)</span>
    <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">equal?</span> <span class="n">n</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">value</span>
            <span class="p">(</span><span class="n">lookup-binding</span> <span class="n">n</span> <span class="n">bindings</span><span class="p">))))</span>
</pre></div>
</div>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Check that the above way of defining the standard library works. Add
functions to print out the various intermediate structures to see how this
actually works.</p>
</div>
<div class="admonition-exercise admonition">
<p class="admonition-title"><strong>Exercise</strong></p>
<p>Reflect on the efficiency of this approach to making the “standard library”
of definitions. Can we do something simpler if we allow ourselves some new
feature of the language (Racket, not PicLang) that we haven’t used so far?</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An extension to the question in <a class="reference internal" href="stacks-and-scope.html"><span class="doc">Stacks and scope</span></a> – we got an
additional super power apart from ordinary functions with the approach to
<code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">FunC</span></span></code> and <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">ApplyC</span></span></code> and <code class="code highlight racket docutils literal notranslate"><span class="name"><span class="pre">IdC</span></span></code> above. Can you recognize it?
You’re so familiar with it by now it probably slipped past you without your
notice.</p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Comp308: Principles of Programming Languages</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="racket-intro.html">A quick introduction to Racket and Scheme</a></li>
<li class="toctree-l1"><a class="reference internal" href="lambda.html">Lambda - the everything</a></li>
<li class="toctree-l1"><a class="reference internal" href="piclang.html">A language for pictures</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine.html">A mental model for the machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="growing.html">Growing the language</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun.html">Functions and scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="stacks-and-scope.html">Stacks and scope</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Functions in PicLang</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#a-standard-library">A standard library</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="stacks-and-scope.html" title="previous chapter">Stacks and scope</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Srikumar K. S..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/fun-in-piclang.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>