<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>On the choice between “error” and “do something reasonable” in design &#8212; Comp308: Principles of Programming Languages v1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=3d3fbe02" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=12dfc556" />
    <script src="_static/documentation_options.js?v=5cb08e4e"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Objects" href="objects.html" />
    <link rel="prev" title="Control" href="control.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="on-the-choice-between-error-and-do-something-reasonable-in-design">
<h1>On the choice between “error” and “do something reasonable” in design<a class="headerlink" href="#on-the-choice-between-error-and-do-something-reasonable-in-design" title="Link to this heading">¶</a></h1>
<p>As some of you noted in your implementations, you faced a choice between using
(error ..) and returning a default or nil-potent value of some kind (like zero,
empty list). This is common choice point that we need to face when designing
functions. There is relatively little in terms of “science” to this though and
in the case of user interfaces is more “art” than “science”. To the extent
there is, here are some thoughts –</p>
<p>A function is said to be “<strong>total</strong>” in the domain of its arguments, if for
every possible argument it terminates with a valid value in its co-domain.
Total functions are easy to program and reason with. However they’re somewhat
of a rarity as well. Given that the reason to lean towards total functions is
that they become <strong>easier to reason with</strong>, that ought to be useful as a
criterion to go for making a function total by specification. i.e. if making it
total is not making it easier to reason with, then there may be benefit to
introducing error behaviours.</p>
<p>One way a function can be (somewhat artificially) made total is to make its
result a “<strong>sum type</strong>” or (in Racket teminology) a “<strong>union</strong>” of possible
types. For example, we’ve used <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">U</span><span class="w"> </span><span class="n">False</span><span class="w"> </span><span class="n">Value</span><span class="p">)</span></code> as the result type of
lookup functions. When choosing this, consider whether the types involved in
the union have any overlap. It is easier to reason if they don’t overlap (i.e.
are “disjoint”). For example, if <code class="code highlight racket docutils literal highlight-racket"><span class="n">Value</span></code> can include <code class="code highlight racket docutils literal highlight-racket"><span class="n">Boolean</span></code>, then
<code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="n">U</span><span class="w"> </span><span class="n">False</span><span class="w"> </span><span class="n">Value</span><span class="p">)</span></code> is superfluous and not informative or useful as a type.
Go for a sum type result if the function cannot know whether the conditions
under which it returns the various types are true “errors” as far as the
program goes and the caller has to decide that. In some cases, the caller may
choose to wrap such a function into a total function and in other cases the
caller may wrap it to raise an error. An example of this is our “lookup”
function that <strong>may</strong> give you a value associated with an identifier. Go for an
error if there is some <strong>contract</strong> that would be violated if some property of
the arguments does not hold. This is often the case in writing interpreters
where you (usually) want to fail early on encountering an invalid program
instead of trying to do something “reasonable” with invalid input. One of the
points in favour of compiled languages (especially those with good type
systems) is to signal “bad program” <strong>BEFORE</strong> the program gets to run and
(maybe) cause damage – think programs used in nuclear reactor control or X-ray
machine control. We’ll discuss type systems soon in this course.</p>
<p>So far, we’ve only used <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="k">...</span><span class="p">)</span></code> in a way where our programs bomb
totally and terminate on encountering an <code class="code highlight racket docutils literal highlight-racket"><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="k">...</span><span class="p">)</span></code> expression. In case
you missed a central point of this course – <strong>this is also a design choice</strong>!
For many kinds of target domains, such “unwind the stack until you reach a
handler or terminate” is a usable and efficient means of dealing with such
errors. Such an “unwinding of the stack” is a simple “one shot continuation”
that can be efficiently implemented on most hardware at O(1) space and time
cost. Some languages like Common Lisp don’t unwind the stack, but give control
to the higher level error handlers so they can decide what to do – whether to
terminate the program, or “bubble up” the condition to the next handler, or
make a correction and resume or restart the operation that produced the
condition with a different starting point. This is a powerful tool in the hands
of good programmers who know that higher up in the call sequence there is more
information available to decide what to do about an error condition than down
in the deeps of the call sequence. Common Lisp therefore does not call these
“errors” and uses “conditions” to talk about them, because the handler may
choose to ignore a condition if it sees fit. A limited version of this flexible
approach was also useful in the context of my own muSE dialect of Scheme used
to express video editing styles -
<a class="reference external" href="https://github.com/srikumarks/muSE/wiki/ExceptionHandlingLinks">https://github.com/srikumarks/muSE/wiki/ExceptionHandlingLinks</a> to an external
site. .</p>
<p>The language Erlang and its newer protege “Elixir” use “processes”
(memory-isolated concurrent distributed computational units with a message
queue) as a primitive. Processes are cheap in Erlang and can cost as little as
300 bytes compared to about 1MB for a thread in, say, C++. So the Erlang design
philosophy encourages a kind of “happy path” style - where it is considered
perfectly reasonable to “<strong>just crash</strong>” on error. Only the process running the
code will terminate and Erlang libraries (called “OTP” for Open Telephony
Platform) provide utilities and patterns for how to handle such crashes to
build error resilient systems – through restarts and process “supervisor
trees”.</p>
<p>You can design <strong>arbitrary</strong> control structures using reified continuations. So
you could work out the details of the ideal control mechanisms for a particular
domain and model them using continuations to understand their semantics before
you commit to an existing mechanism such as “exceptions”. You’ll then be in a
position to decide whether a new control structure is appropriate or an
existing one will do. In most of the common programming languages, the language
designers have made some reasonable default choice of mechanism for you. You’re
now a language designer too, so you may find their choice “unreasonable” in
your context and can do something about it.</p>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Comp308: Principles of Programming Languages</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Welcome note</a></li>
<li class="toctree-l1"><a class="reference internal" href="racket-intro.html">A quick introduction to Racket and Scheme</a></li>
<li class="toctree-l1"><a class="reference internal" href="lambda.html">λ - the everything</a></li>
<li class="toctree-l1"><a class="reference internal" href="church.html">Lambda - via β-abstraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="piclang.html">A language for pictures</a></li>
<li class="toctree-l1"><a class="reference internal" href="arithlang.html">A language for arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine.html">A mental model for the machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="notional-machine.html">Notional machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="growing.html">Growing the language</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun.html">Functions and scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun-arith.html">Functions and scope (arithmetic track)</a></li>
<li class="toctree-l1"><a class="reference internal" href="stacks-and-scope.html">Stacks and scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="fun-in-piclang.html">Functions in PicLang</a></li>
<li class="toctree-l1"><a class="reference internal" href="mutations.html">Mutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="control.html">Control</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">On the choice between “error” and “do something reasonable” in design</a></li>
<li class="toctree-l1"><a class="reference internal" href="objects.html">Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="objects-self.html">Objects - the Self way</a></li>
<li class="toctree-l1"><a class="reference internal" href="dispatch.html">Polymorphism via dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="generators.html">Generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="appsem.html">Alternative application semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html">Types: Checking some program invariants statically</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="control.html" title="previous chapter">Control</a></li>
      <li>Next: <a href="objects.html" title="next chapter">Objects</a></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2022, Srikumar K. S..
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="_sources/errornot.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>